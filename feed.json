{
    "version": "https://jsonfeed.org/version/1",
    "title": "Whispering's Blog",
    "subtitle": "无需过去，无关未来，只有现在",
    "icon": "http://ntmydb/github.io/images/favicon.ico",
    "description": "Whispering's Blog",
    "home_page_url": "http://ntmydb/github.io",
    "items": [
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-3/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-3/",
            "title": "操作系统408-5-3",
            "date_published": "2024-08-13T06:56:29.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"磁盘结构\"><a class=\"anchor\" href=\"#磁盘结构\">#</a> 磁盘结构</h3>\n<h4 id=\"磁盘-磁面-扇区\"><a class=\"anchor\" href=\"#磁盘-磁面-扇区\">#</a> 磁盘、磁面、扇区</h4>\n<p>磁盘的表面由一些磁性物质组成，可以用这些磁性物质来记录二进制数据</p>\n<p>磁盘的盘面被划分成一个个磁道。</p>\n<p>一个磁道又被划分为一个个扇区，每个扇区就是一个磁盘块。各个扇区存放的数据量相同</p>\n<p>最内侧磁道上的扇区面积最小，因此数据密度最大</p>\n<h4 id=\"盘片-柱面\"><a class=\"anchor\" href=\"#盘片-柱面\">#</a> 盘片、柱面</h4>\n<p>一个盘片可能会有两个盘片，每个盘片对应一个磁头，所有的磁头都是连在同一个磁臂上的，因此所有磁头只能 &quot;共进退&quot;</p>\n<p>所有盘面中相对位置相同的磁道组成柱面</p>\n<h4 id=\"磁盘的物理地址\"><a class=\"anchor\" href=\"#磁盘的物理地址\">#</a> 磁盘的物理地址</h4>\n<p>可用（柱面号，盘面号，扇区号）来定位任意一个 &quot;磁盘块&quot;。</p>\n<p>可以根据该地址去读一个块</p>\n<ul>\n<li>根据柱面号移动磁臂，让磁头指向指定柱面</li>\n<li>激活指定盘面对应的磁头</li>\n<li>磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读 / 写</li>\n</ul>\n<h4 id=\"磁头的分类\"><a class=\"anchor\" href=\"#磁头的分类\">#</a> 磁头的分类</h4>\n<p>磁头可以移动的称为活动头磁盘。磁臂可以来回伸缩来带动磁头定位磁道</p>\n<p>磁头不可移动的称为固定头磁盘。这种磁盘中每个磁道有一个磁头</p>\n<h4 id=\"磁盘的分类\"><a class=\"anchor\" href=\"#磁盘的分类\">#</a> 磁盘的分类</h4>\n<p>盘片可以更换的称为可换盘磁盘，盘片不可更换的称为固定盘磁盘</p>\n<h3 id=\"磁盘调度算法\"><a class=\"anchor\" href=\"#磁盘调度算法\">#</a> 磁盘调度算法</h3>\n<p><strong>一次磁盘读 / 写操作需要的时间</strong></p>\n<p>寻找时间（寻道时间）Ts：在读 / 写数据前，将磁头移动到指定磁道所花的时间</p>\n<ul>\n<li>启动磁头臂是需要时间的。假设耗时为 s</li>\n<li>移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为 m，总共需要跨越 n 条磁道。则：寻道时间 Ts=s+m*n</li>\n</ul>\n<p>延迟时间 TR：通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为 r（单位：转 / 秒，或转 / 分），则平均所需的延迟时间 TR=1/2r</p>\n<p>传输时间 Tt：从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为 r，此次读 / 写的字节数为 b，每个磁道上的字节数为 N。则：传输时间 Tt=b/(rN)</p>\n<p>总的平均存取时间 Ta=Ts+1/2r+b/(rN)</p>\n<p>延迟时间和传输时间都与磁盘转速有关，且为线性相关。而转速是硬件的固有属性，因此操作系统也无法优化延迟时间和传输时间</p>\n<h4 id=\"先来先服务算法fcfs\"><a class=\"anchor\" href=\"#先来先服务算法fcfs\">#</a> 先来先服务算法（FCFS）</h4>\n<p>根据进程请求访问磁盘的先后顺序进行调度</p>\n<p>优点：公平；如果请求访问的磁道比较集中的话，算法性能还算过得去</p>\n<p>缺点：如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则 FCFS 在性能上很差，寻道时间长</p>\n<h4 id=\"最短寻找时间优先sstf\"><a class=\"anchor\" href=\"#最短寻找时间优先sstf\">#</a> 最短寻找时间优先（SSTF）</h4>\n<p>SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但并不能保证总的寻道时间最短。（其实就是贪心算法思想）</p>\n<p>优点：性能较好，平均寻道时间段</p>\n<p>缺点：可能产生 &quot;饥饿&quot; 现象</p>\n<ul>\n<li>原因：磁头在一个小区域内来回来去地移动</li>\n</ul>\n<h4 id=\"扫描算法scan\"><a class=\"anchor\" href=\"#扫描算法scan\">#</a> 扫描算法（SCAN）</h4>\n<p>SSTF 会产生饥饿的原因在于：磁头有可能在一个小区域内来回来去地移动。为了防止这个问题可以规定，只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动。这就是扫描算法的思想。由于磁头移动的方式很像电梯，因此也叫电梯算法</p>\n<p>优点：性能较好，平均寻道时间较短，不会产生饥饿现象</p>\n<p>缺点：</p>\n<ul>\n<li>只有到达最边上的磁道时才能改变磁头移动方向。</li>\n<li>SCAN 算法对于各个位置磁道的响应频率不平均</li>\n</ul>\n<h4 id=\"look调度算法\"><a class=\"anchor\" href=\"#look调度算法\">#</a> LOOK 调度算法</h4>\n<p>扫描算法（SCAN）中，只有到达了最边上的磁道时才能改变磁头方向。LOOK 算法就是为了解决这个问题，如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向。</p>\n<p>优点：比起 SCAN 算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>\n<h4 id=\"循环扫描算法c-scan\"><a class=\"anchor\" href=\"#循环扫描算法c-scan\">#</a> 循环扫描算法（C-SCAN）</h4>\n<p>SCAN 算法对于各个位置磁道的响应频率不平均，而 C-SCAN 算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p>\n<p>优点：比起 SCAN 算法，对于各个位置磁道的响应频率很平均</p>\n<p>缺点：只有到达最边上的磁道时才能改变磁头方向。比起 SCAN 算法来，平均寻道时间更长</p>\n<h4 id=\"c-look调度算法\"><a class=\"anchor\" href=\"#c-look调度算法\">#</a> C-LOOK 调度算法</h4>\n<p>C-SCAN 算法的主要缺点是只有到达最边上的磁道时才能改变磁头方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK 算法就是为了解决这个问题的。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可</p>\n<p>优点：比起 C-SCAN 算法，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短</p>\n<h3 id=\"减少磁盘延迟时间的方法\"><a class=\"anchor\" href=\"#减少磁盘延迟时间的方法\">#</a> 减少磁盘延迟时间的方法</h3>\n<p>磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的 &quot;延迟时间&quot;</p>\n<h4 id=\"减少延迟时间方法交替编号\"><a class=\"anchor\" href=\"#减少延迟时间方法交替编号\">#</a> 减少延迟时间方法：交替编号</h4>\n<p>若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小</p>\n<h4 id=\"磁盘地址结构的设计\"><a class=\"anchor\" href=\"#磁盘地址结构的设计\">#</a> 磁盘地址结构的设计</h4>\n<p>为什么磁盘的物理地址是（柱面号，盘面号，扇区号）而不是（盘面号，柱面号，扇区号）</p>\n<ul>\n<li>读取地址连续的磁盘块时，采用（柱面号，盘面号，扇区号）的地址结构可以减少磁头移动消耗的时间</li>\n</ul>\n<h4 id=\"减少延迟时间方法错位命名\"><a class=\"anchor\" href=\"#减少延迟时间方法错位命名\">#</a> 减少延迟时间方法：错位命名</h4>\n<p>让相邻盘面的扇区编号错位</p>\n<p>原理：与交替编号的原理相同，错位命名法可以降低延迟时间</p>\n<h3 id=\"磁盘的管理\"><a class=\"anchor\" href=\"#磁盘的管理\">#</a> 磁盘的管理</h3>\n<h4 id=\"磁盘初始化\"><a class=\"anchor\" href=\"#磁盘初始化\">#</a> 磁盘初始化</h4>\n<ul>\n<li>进行低级格式化（物理格式化），将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区检验码（如奇偶校验、CRC 等，校验码用于校验扇区中的数据是否发生错误）</li>\n<li>将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的 C 盘、D 盘、F 盘）</li>\n<li>进行逻辑格式化，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构</li>\n</ul>\n<h4 id=\"引导块\"><a class=\"anchor\" href=\"#引导块\">#</a> 引导块</h4>\n<p>引导块：计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行初始化程序（自举程序）完成的</p>\n<p>初始化程序可以放在 ROM（只读存储器）中，ROM 中的数据在出厂时就写入了，并且以后不能再修改</p>\n<p>注：ROM 一般是出厂时就集成在主板上的</p>\n<p>ROM 中只存放很小的 &quot;自举装入程序&quot;，完整的自举程序放在磁盘的启动块（即引导块 / 启动分区）上，启动块位于磁盘的固定位置</p>\n<p>开机时计算机先运行 &quot;自举装入程序&quot;，通过执行该程序就可以找到引导块，并将完整的 &quot;自举程序&quot; 读入内存，完成初始化</p>\n<p>拥有启动分区的磁盘称为启动磁盘或系统磁盘（C 盘）</p>\n<h4 id=\"坏块的管理\"><a class=\"anchor\" href=\"#坏块的管理\">#</a> 坏块的管理</h4>\n<p>坏了，无法正常使用的扇区就是坏块。这属于硬件故障，操作系统无法修复的。应该将坏块标记出来，以免错误地使用到它</p>\n<p>对于简单的磁盘，可以在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如：在 FAT 表上表明（在这种方式中，坏块对操作系统不透明）</p>\n<p>对于复杂的磁盘，磁盘控制器（磁盘设备内部的一个硬件部件）会维护一块坏块链表</p>\n<p>在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化</p>\n<p>会保留一些 &quot;备用扇区&quot;，用于替换坏块。这种方案称为扇区备用、且这种处理方式中，坏块对操作系统透明。</p>\n<h3 id=\"固态硬盘ssd\"><a class=\"anchor\" href=\"#固态硬盘ssd\">#</a> 固态硬盘 SSD</h3>\n<ul>\n<li>原理：基于闪存技术 Flash Memory，属于电可擦除 ROM，即 EEPROM</li>\n<li>组成：\n<ul>\n<li>闪存翻译层：负责翻译逻辑模块号，找到对应页</li>\n<li>存储介质：多个闪存芯片 (Flash Chip)—— 每个芯片包含多个块 —— 每个块包含多个页</li>\n</ul>\n</li>\n<li>读写性能特性：\n<ul>\n<li>以页为单位读 / 写 —— 相当于磁盘的扇区</li>\n<li>以块为单位擦除，擦干净的块，其中的每一页都可以写一次，读无限次</li>\n<li>支持随机访问，系统给定一个逻辑地址，闪存翻译层可通过电路迅速定位到对应的物理地址</li>\n<li>读快、写慢。要写的页如果有数据，则不能写入，需要块内其他页全部复制到一个新的 (擦除过的) 块中，再写入新的页</li>\n</ul>\n</li>\n<li>与机械硬盘相比的特点：\n<ul>\n<li>SSD 读写速度快、随机访问性能高，用电路控制访问位置；机械硬盘通过移动磁臂旋转磁盘控制访问位置，有寻道时间和旋转延迟</li>\n<li>SSD 安静无噪音、耐摔抗震、能耗低、造价更贵</li>\n<li>SSD 的一个块被擦除次数过多 (重复写同一个块) 可能会坏掉，而机械硬盘的扇区不会因为写的次数太多而坏掉</li>\n</ul>\n</li>\n<li>磨损均衡技术\n<ul>\n<li>思想：将 &quot;擦除&quot; 平均分布在各个块上，以提升使用寿命</li>\n<li>动态磨损均衡：写入数据时，优先选择累计擦除次数少的新闪存块</li>\n<li>静态磨损均衡：SSD 监测并自动进行数据分配、迁移，让老旧的闪存块承担以读为主的存储任务，让较新的闪存块承担更多的写任务</li>\n</ul>\n</li>\n</ul>\n<p>理想情况下，固态硬盘的寿命：</p>\n<p>某固态硬盘采用磨损均衡技术，大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>40</mn></msup><mi>B</mi><mo>=</mo><mn>1</mn><mi>T</mi><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">2^{40}B=1TB</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">4</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，闪存块的擦写寿命只有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>10</mn></msup><mo>=</mo><mn>1</mn><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">2^{10}=1K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 次。某男子平均每天会对该固态硬盘写<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>37</mn></msup><mi>B</mi><mo>=</mo><mn>128</mn><mi>G</mi><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">2^{37}B=128GB</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">8</span><span class=\"mord mathnormal\">G</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span> 数据。在最理想的情况下，这个固态硬盘可以用多久？</p>\n<p>最理想情况下，SSD 中每个块被擦除的次数都是完全均衡的。<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi>T</mi><mi>B</mi><mi mathvariant=\"normal\">/</mi><mn>128</mn><mi>G</mi><mo>=</mo><mn>8</mn></mrow><annotation encoding=\"application/x-tex\">1TB/128G=8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mord\">/</span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">8</span><span class=\"mord mathnormal\">G</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">8</span></span></span></span></p>\n<p>因此平均每 8 天，每个闪存块就要被擦除一次。每个闪存块可以被擦除<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">1K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 次。因此经过<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>8</mn><mi>K</mi></mrow><annotation encoding=\"application/x-tex\">8K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\">8</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span></span></span></span> 天，约 23 年后，该固态硬盘损坏</p>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-2/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-2/",
            "title": "操作系统408-5-2",
            "date_published": "2024-08-12T11:30:29.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"io核心子系统\"><a class=\"anchor\" href=\"#io核心子系统\">#</a> I/O 核心子系统</h3>\n<p>属于操作系统的内核部分，即 I/O 系统，或称 I/O 核心子系统：</p>\n<ul>\n<li>设备独立性软件\n<ul>\n<li>I/O 调度、设备保护；设备分配与回收、缓冲区管理（即缓冲与高速缓存）\n<ul>\n<li>I/O 调度：用某种算法确定一个好的顺序来处理各个 I/O 请求</li>\n<li>设备保护：操作系统需要实现文件保护功能；不同用户对各个文件有不同的访问权限</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>设备驱动程序</li>\n<li>中断处理程序</li>\n</ul>\n<p>用户层软件：假脱机技术（SPOOLing 技术）（归为 I/O 核心子系统可实现功能）</p>\n<h3 id=\"假脱机spooling技术\"><a class=\"anchor\" href=\"#假脱机spooling技术\">#</a> 假脱机（SPOOLing）技术</h3>\n<h4 id=\"脱机技术\"><a class=\"anchor\" href=\"#脱机技术\">#</a> 脱机技术</h4>\n<p>批处理阶段引入了脱机输入 / 输出技术（用磁带完成）</p>\n<p>在外围控制机的控制下，慢速输入设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，从而缓解了速度矛盾</p>\n<p>引入脱机技术后，缓解了 CPU 与慢速 I/O 设备的速度矛盾。另一方面，即使 CPU 在忙碌，也可以提前将数据输入到磁带；即使慢速的输出设备正在忙碌，也可以提前将数据输出到磁带</p>\n<h4 id=\"假脱机技术输入井和输出井\"><a class=\"anchor\" href=\"#假脱机技术输入井和输出井\">#</a> 假脱机技术 —— 输入井和输出井</h4>\n<p>假脱机技术，又称 SPOOLing 技术，是用软件的方式模拟脱机技术。SPOOLing 系统的组成如下：</p>\n<p><img data-src=\"F:%5CBlog%5Cimages%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-2-1.png\" alt=\"输入井和输出井\" /></p>\n<p>&quot;输入进程&quot; 模拟脱机输入时的外围控制机，&quot;输出进程&quot; 模拟脱机输出时的外围控制机</p>\n<p>要实现 SPOOLing 技术，必须要有多道程序技术的支持。系统会建立 &quot;输入进程&quot; 和 &quot;输出进程&quot;</p>\n<p>注意，输入缓冲区和输出缓冲区是在内存的缓冲区</p>\n<p>在输入进程的控制下，&quot;输入缓冲区&quot; 用于暂存从输入设备输入的数据，之后再转存到输入井中</p>\n<p>在输出进程的控制下，&quot;输出缓冲区&quot; 用于暂存从输出井送来的数据，之后再传送到到输入设备中</p>\n<h4 id=\"共享打印机原理\"><a class=\"anchor\" href=\"#共享打印机原理\">#</a> 共享打印机原理</h4>\n<p>独占式设备 —— 只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求</p>\n<p>共享设备 —— 允许多个进程 &quot;同时&quot; 使用的设备（宏观上同时使用，微观上可能是文件交替使用）。可以同时满足多个进程的使用请求</p>\n<p>打印机是 &quot;独占式设备&quot;，但是可以用 SPOOLing 技术改造成 &quot;共享设备&quot;</p>\n<p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给它们，而是由假脱机管理进程为每个进程做两件事</p>\n<ul>\n<li>在磁盘输出井中为进程申请一个空闲缓冲区（也就是说，这个缓冲区是在磁盘上建立的），并将要打印的数据送入其中</li>\n<li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上</li>\n</ul>\n<p>当打印机空闲时，输入进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务</p>\n<p>虽然系统中只有一台打印机，但是每个进程提出打印请求时，系统都会为在输出井中为其分配一个存储区（相当于分配了一个逻辑设备），使每个用户进程都觉得自己在独占一台打印机，从而实现对打印机的共享</p>\n<p>SPOOLing 技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备</p>\n<h3 id=\"设备的分配与回收\"><a class=\"anchor\" href=\"#设备的分配与回收\">#</a> 设备的分配与回收</h3>\n<h4 id=\"设备分配时应考虑的因素\"><a class=\"anchor\" href=\"#设备分配时应考虑的因素\">#</a> 设备分配时应考虑的因素</h4>\n<p><strong>设备的固有属性</strong></p>\n<p>设备的固定属性可分为：独占设备、共享设备、虚拟设备</p>\n<p>独占式设备 —— 只允许各个进程串行使用的设备。一段时间内只能满足一个进程的请求</p>\n<p>共享设备 —— 允许多个进程 &quot;同时&quot; 使用的设备（宏观上同时使用，微观上可能是文件交替使用）。可以同时满足多个进程的使用请求</p>\n<p>虚拟设备 —— 采用 SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用 SPOOLing 技术实现的共享打印机）</p>\n<p><strong>设备分配算法</strong></p>\n<p>先来先服务、优先级高者优先、短任务优先</p>\n<p><strong>设备分配中的安全性</strong></p>\n<p>从进程运行的安全性上考虑，设备分配有两种方式：</p>\n<p>安全分配方式：为进程分配一个设备后就将进程阻塞，本次 I/O 完成后才将进程唤醒。</p>\n<ul>\n<li>一个时间段内每个进程只能使用一个设备</li>\n<li>优点：破坏了请求和保持的条件，不会死锁</li>\n<li>缺点：对于一个进程来说，CPU 与 I/O 设备只能串行工作</li>\n</ul>\n<p>不安全分配方式：进程发出 I/O 后，系统为其分配 I/O 设备，进程可继续执行，之后还可以发出新的 I/O 请求。只有某个 I/O 请求得不到满足时才将进程阻塞</p>\n<ul>\n<li>一个进程可以同时使用多个设备</li>\n<li>优点：进程的计算任务和 I/O 任务可以并行处理，使进程迅速推进</li>\n<li>缺点：有可能发生死锁（死锁避免、死锁的检测和解除）</li>\n</ul>\n<h4 id=\"静态分配和动态分配\"><a class=\"anchor\" href=\"#静态分配和动态分配\">#</a> 静态分配和动态分配</h4>\n<p>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源</p>\n<p>动态分配：进程运行过程中动态申请设备资源</p>\n<h4 id=\"设备分配管理中的数据结构\"><a class=\"anchor\" href=\"#设备分配管理中的数据结构\">#</a> 设备分配管理中的数据结构</h4>\n<p>设备、控制器、通道之间的关系：</p>\n<p>一个通道可控制多个控制器，每个设备控制器可控制多个设备</p>\n<p>控制设备表（DCT）：系统为每个设备配置一张 DCT，用于记录设备情况</p>\n<ul>\n<li>设备类型</li>\n<li>设备标识符：即物理设备名，系统中的每个设备的物理设备名唯一</li>\n<li>设备状态：忙碌 / 空闲 / 故障</li>\n<li>指向控制器的指针：每个设备由一个控制器控制，该指针可找到相应控制器的信息</li>\n<li>重复执行次数或时间：当重复执行多次 I/O 操作后扔不成立，才认为此次 I/O 失败</li>\n<li>设备队列的队首指针：指向正在等待该设备的进程队列（由进程 PCB 组成队列）</li>\n</ul>\n<p>设备控制表（COCT）：每个设备控制器都会对应一张 COCT，操作系统根据 COCT 的信息对控制器进行操作和管理</p>\n<ul>\n<li>控制器标识符：各个控制器的唯一标识符</li>\n<li>控制器状态：忙碌 / 空闲 / 故障</li>\n<li>指向通道表的指针：每个控制器由一个通道控制，该指针可找到相应通道的信息</li>\n<li>控制器队列的队首指针</li>\n<li>控制器队列的队尾指针：指向正在等待该控制器的进程队列（由进程 PCB 组成队列）</li>\n</ul>\n<p>通道控制表（CHCT）：每个通道都会对应一张 DHCT。操作系统根据 CHCT 的信息对通道进行操作和管理</p>\n<ul>\n<li>通道标识符：各个通道的唯一 ID</li>\n<li>通道状态：忙碌 / 空闲 / 故障</li>\n<li>与通道连接的控制器首址：可通过该指针找到该通道管理的所有控制器相关信息（COCT）</li>\n<li>通道队列的队首指针</li>\n<li>通道队列的队尾指针：指向正在等待该通道的进程队列（由进程 PCB 组成队列）</li>\n</ul>\n<p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目。</p>\n<ul>\n<li>每个表目中由设备类型、设备标识符、DCT、驱动程序入口组成</li>\n</ul>\n<h4 id=\"设备分配的步骤\"><a class=\"anchor\" href=\"#设备分配的步骤\">#</a> 设备分配的步骤</h4>\n<ul>\n<li>\n<p>根据进程请求的物理设备名查找 SDT（注：物理设备名是进程请求分配时提供的参数）</p>\n</li>\n<li>\n<p>根据 SDT 找到 DCT，若设备忙碌则将进程 PCB 挂到设备等待队列中，不忙碌则将设备分配给进程</p>\n</li>\n<li>\n<p>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程</p>\n</li>\n<li>\n<p>根据 COCT 找到 CHCT，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进程</p>\n</li>\n</ul>\n<p>注：只有设备、控制器、通道三设备都分配成功时，这次设备才算成功，之后便可启动 I/O 设备进行数据传送</p>\n<p>缺点：</p>\n<ul>\n<li>用户编程时必须使用 &quot;物理设备名&quot;，底层细节对用户不透明，不方便编程</li>\n<li>若换了一个物理设备，则程序无法运行</li>\n<li>若进程请求的物理设备正在忙碌，则即使用系统中还有同类型的设备，进程也必须阻塞等待</li>\n</ul>\n<p>改进方法：建立逻辑设备名与物理设备名的映射机制，用户编程时只需提供逻辑设备名</p>\n<p><strong>设备分配步骤改进</strong></p>\n<ul>\n<li>根据进程请求的逻辑设备名查找 SDT（注：用户编程时提供的逻辑设备名其实就是 &quot;设备类型&quot;）</li>\n<li>查找 SDT，找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备表（LUT）中新增一个表项</li>\n<li>根据 DCT 找到 COCT，若控制器忙碌则将进程 PCB 挂到控制器等待队列中，不忙碌则将控制器分配给进程</li>\n<li>根据 COCT 找到 CHCT，若通道忙碌则将进程 PCB 挂到通道等待队列中，不忙碌则将通道分配给进程</li>\n</ul>\n<p>逻辑设备表（LUT）建立了逻辑设备名与物理设备名之间的映射关系</p>\n<p>某用户进程第一次使用逻辑设备名向操作系统发出请求，操作系统根据用户进程指定的设备类型（逻辑设备名）查找系统设备表。找到一个空闲设备分配给进程，并在 LUT 中增加相应表项</p>\n<p>如果之后用户进程再次通过相同的逻辑设备名请求使用设备，则操作系统通过 LUT 表即可知道用户进程实际要使用的是哪个物理设备了，并且也能知道该设备的驱动程序入口地址</p>\n<p>逻辑设备表的设置问题：</p>\n<p>整个系统只有一张逻辑设备表 LUT：各用户所用的逻辑设备名不允许重复，适用于单用户操作系统</p>\n<p>每个用户一张 LUT：不同的用户的逻辑设备名可重复，适用于多用户操作系统</p>\n<h3 id=\"缓冲区管理\"><a class=\"anchor\" href=\"#缓冲区管理\">#</a> 缓冲区管理</h3>\n<p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区</p>\n<p>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p>\n<p>一般情况下，更多的是利用内存作为缓冲区，&quot;设备独立性软件&quot; 的缓冲区管理就是要组织管理好这些缓冲区</p>\n<p><strong>缓冲区的作用</strong></p>\n<ul>\n<li>缓和 CPU 和 I/O 设备之间速度不匹配的矛盾</li>\n<li>减少对 CPU 的中断频率，放宽对 CPU 中断相应时间的限制</li>\n<li>解决数据粒度不匹配的问题</li>\n<li>提高 CPU 与 I/O 设备之间的并行性</li>\n</ul>\n<p><strong>单缓冲</strong></p>\n<p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>\n<p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后才能从缓冲区把数据传出</p>\n<p>结论：采用单缓冲区的策略，处理一块数据平均耗时 Max (C,T)+M（其中，C 为 CPU 处理数据时间，M 为缓冲区传输数据到用户进程工作区时间，T 为块设备将数据传入缓冲区的时间）</p>\n<p><strong>双缓冲</strong></p>\n<p>假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</p>\n<p>假设初始状态为：工作区空，其中一个缓冲区满，另一个缓冲区空</p>\n<p>结论：采用双缓冲区，处理一个数据块的平均耗时为 Max (T,C+M)</p>\n<p><strong>使用单 / 双缓冲区在通信时的区别</strong></p>\n<p>单缓冲区：在任意时刻只能实现数据的单向传输（单缓冲区）</p>\n<p>双缓冲区：在同一时刻可以实现双向的数据传输（发送数据缓冲区，接收数据缓冲区）</p>\n<p><strong>循环缓冲区</strong></p>\n<p>将多个大小相等的缓冲区链接成一个循环队列</p>\n<p>in 指针，指向下一个可以冲入数据的空缓冲区</p>\n<p>out 指针，指向下一个可以取出数据的满缓冲区</p>\n<p><strong>缓冲池</strong></p>\n<p>缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）</p>\n<p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于收容输入数据的工作缓冲区（hin），用于提取输入数据的工作缓冲区（sin）、用于收容输出数据的工作缓冲区（hout）、用于提取输出数据的工作缓冲区（sout）</p>\n<ul>\n<li>输入进程请求输入数据\n<ul>\n<li>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hin）。充满数据后将缓冲区挂到输入队列队尾</li>\n</ul>\n</li>\n<li>计算进程想要取出一块输入数据\n<ul>\n<li>从输入队列中取得一块充满输入数据的缓冲区作为 &quot;提取输入数据的工作缓冲区（sin）&quot;。缓冲区读空后挂到空缓冲区队列</li>\n</ul>\n</li>\n<li>计算进程想要将准备好的数据冲入缓冲区\n<ul>\n<li>从空缓冲队列中取出一块作为收容输入数据的工作缓冲区（hout）。充满数据后将缓冲区挂到输出队列队尾</li>\n</ul>\n</li>\n<li>输出进程请求输出数据\n<ul>\n<li>从输出队列中取得一块充满输入数据的缓冲区作为 &quot;提取输入数据的工作缓冲区（sout）&quot;。缓冲区读空后挂到空缓冲区队列</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-6/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-6/",
            "title": "计网408-6",
            "date_published": "2024-08-12T07:40:57.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"应用层概述\"><a class=\"anchor\" href=\"#应用层概述\">#</a> 应用层概述</h3>\n<p>应用层是计算机网络体系结构的最顶层，是设计和建立计算机网络的最终目的，也是计算机网络中发展最快的部分</p>\n<ul>\n<li>从早期基于文本的应用（电子邮件、远程登录、文件传输、新闻组）</li>\n<li>20 世纪 90 年代将因特网带入千家万户的万维网 WWW</li>\n<li>当今流行的即时通信、P2P 文件共享及各种音视频应用</li>\n<li>计算机设备的小型化和无处不在，宽带住宅接入和无线接入</li>\n</ul>\n<p>网络应用：</p>\n<ul>\n<li>万维网 WWW</li>\n<li>域名系统 DNS</li>\n<li>动态主机配置 DHCP</li>\n<li>电子邮件</li>\n<li>多媒体网络应用</li>\n<li>文件传送 FTP 和 P2P 文件共享</li>\n</ul>\n<h3 id=\"客户服务器方式和对等方式\"><a class=\"anchor\" href=\"#客户服务器方式和对等方式\">#</a> 客户服务器方式和对等方式</h3>\n<p>网络应用程序运行处在网络边缘的不同的端系统上，通过彼此间的通信来共同完成某项任务</p>\n<p>开发一种新的网络应用首先要考虑的问题就是网络应用程序在各种端系统上的组织方式和它们之间的关系。目前流行的主要有以下两种：</p>\n<ul>\n<li>客户 / 服务器方式（C/S）方式</li>\n<li>对等（P2P）方式</li>\n</ul>\n<h4 id=\"客户服务器方式\"><a class=\"anchor\" href=\"#客户服务器方式\">#</a> 客户 / 服务器方式</h4>\n<ul>\n<li>\n<p>客户和服务器是指通信中所涉及的两个应用进程</p>\n</li>\n<li>\n<p>客户 / 服务器方式所描述的是进程之间服务和被服务的关系</p>\n</li>\n<li>\n<p>客户是服务请求方，服务器是服务提供方</p>\n</li>\n<li>\n<p>服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号（如 HTTP 服务器的默认端口为 80），而运行服务器的主机也具有固定的 IP 地址</p>\n</li>\n</ul>\n<p>C/S 方式是因特网上传统的，同时也是最成熟的方式，很多熟悉应用采用的都是 C/S 方式。包括万维网 WWW、电子邮件、文件传输 FTP 等</p>\n<p>基于 C/S 方式的应用服务通常是服务集中型的，即应用服务集中在网络中比客户计算机少得多的服务器计算机上</p>\n<ul>\n<li>由于一台服务计算机要为多个客户机提供服务，在 C/S 应用中，常会出现服务器计算机跟不上众多客户机请求的情况</li>\n<li>为此，在 C/S 应用中，常用计算机群集（或服务器场）构建一个强大的虚拟服务器</li>\n</ul>\n<h4 id=\"对等方式\"><a class=\"anchor\" href=\"#对等方式\">#</a> 对等方式</h4>\n<ul>\n<li>在 P2P 方式中，没有固定的服务请求者和服务提供者，分布在网络边缘各端系统中的应用进程是对等的，被称为对等方。对等放相互之间直接通信，每个对等方既是服务的请求者，又是服务的提供者</li>\n</ul>\n<p>目前，在因特网上流行的 P2P 应用主要包括 P2P 文件共享、即时通信、P2P 流媒体、分布式存储等。</p>\n<p>基于 P2P 的应用是服务分散型的，因为服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中，这些计算机并不为服务提供商所有，而是为个人控制的桌面计算机和笔记本电脑，它们通常位于住宅、校园和办公室中</p>\n<p>P2P 方式的最突出特征之一就是它的可扩展性。因为系统每增加一个对等放，不仅增加的是服务的请求者，同时也增加了服务的提供者，系统性能不会因规模的增大而降低</p>\n<p>P2P 方式具有成本上的优势，因为它通常不需要庞大的服务器设施和服务器带宽。为了降低成本，服务提供商对于将 P2P 方式用于应用的兴趣越来越大。</p>\n<h3 id=\"动态主机配置协议dhcp\"><a class=\"anchor\" href=\"#动态主机配置协议dhcp\">#</a> 动态主机配置协议 DHCP</h3>\n<p>DHCP 的作用：通过 DHCP 自动获取网络配置信息</p>\n<p>动态主机配置协议 DHCP 提供了一种机制，称为即插即用连网。这种机制允许一台计算机加入新网络时可自动获取 IP 地址等网络配置信息而不用手工参与</p>\n<p>DHCP 的工作过程：</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/85p9XaLnWo7ZwCY.png\" alt=\"DHCP工作过程\" /></p>\n<p>DHCP 主要使用以下报文来实现其功能：</p>\n<ul>\n<li>DHCP DISCOVER：DHCP 发现报文</li>\n<li>DHCP OFFER：DHCP 提供报文</li>\n<li>DHCP REQUEST：DHCP 请求报文</li>\n<li>DHCP ACK：DHCP 确认报文</li>\n<li>DHCP NACK：DHCP 否认报文</li>\n<li>DHCP RELEASE：DHCP 释放报文</li>\n</ul>\n<p>DHCP 报文在运输层使用 UDP 协议封装：</p>\n<ul>\n<li>DHCP 客户使用的 UDP 端口号为 68</li>\n<li>DHCP 服务器使用的 UDP 端口号为 67</li>\n</ul>\n<p>DHCP 在未获取到 IP 地址时使用地址 0.0.0.0</p>\n<p>在每一个网络上都设置一个 DHCP 服务器会使 DHCP 服务器的数量太多。因此现在时使用每一个网络至少有一个 DHCP 中继代理（通常是一台路由器），它配置了 DHCP 服务器的 IP 地址信息，作为各网路中计算机与 DHCP 服务器的桥梁</p>\n<h3 id=\"域名系统dns\"><a class=\"anchor\" href=\"#域名系统dns\">#</a> 域名系统 DNS</h3>\n<p>因特网不可使用一台 DNS 服务器，因为因特网的规模很大，这样的域名服务器肯定会因为超负荷而无法正常工作，而且一旦域名服务器出现故障，整个因特网就会瘫痪</p>\n<p>因特网在 1983 年采用层次结构的命名树作为主机的名字（即域名），并使用分布式的域名系统 DNS</p>\n<p>DNS 使大多数域名都在本地解析，仅少量解析需要在因特网上通信，因此系统效率很高</p>\n<p>由于 DNS 时分布式系统，即使单个计算机出了故障，也不会妨碍整个系统的正常运行</p>\n<p>DNS 报文使用运输层的 UDP 协议进行封装，运输层端口号为 53</p>\n<p><strong>层次树状结构的域名结构</strong></p>\n<p>因特网采用层次树状结构的域名结构</p>\n<p>域名结构由若干个分量组成，各分量之间用 &quot;点&quot; 隔开，分别代表不同级别的域名（如：三级域名。二级域名。顶级域名）</p>\n<ul>\n<li>每一级的域名都由英文字母和数字组成，不超过 63 个字符，不区分大小写字母</li>\n<li>级别最低的域名写在最左边，而级别最高的顶级域名写在最右边</li>\n<li>完整的域名不超过 255 个字符</li>\n</ul>\n<p>域名系统既不规定一个域名需要包含多少个下级域名，也不规定每一级的域名代表什么意思</p>\n<p>各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由因特网名称与数字地址分配机构 ICANN 进行管理</p>\n<p><strong>域名分类</strong></p>\n<p>顶级域名分为一下三类：</p>\n<ul>\n<li>国家顶级域名 nTLD：采用 ISO 3166 规定，如 cn 表示中国，us 表示美国，uk 表示英国等等</li>\n<li>通用顶级域名 gTLD：最常见的通用顶级域名由七个，即 com（公司企业）、net（网络服务机构）、org（非营利性组织）、int（国际组织）、edu（美国教育机构）、gov（美国政府部门）、mil（美国军事部分）</li>\n<li>反向域 arpa：用于反向域名解析，即 IP 地址反向解析为域名</li>\n</ul>\n<p>在国家顶级域名下注册的二级域名均由该国家自行确定。</p>\n<p>我国则将二级域名划分为以下两类：</p>\n<ul>\n<li>类别域名：一共七个：ac（科研机构）、com（工、商、金融等企业）、edu（教育机构）、gov（政府部门）、net（提供网络服务的机构）、mil（军事机构）和 org（非营利性组织）</li>\n<li>行政区域名：共 34 个，适用于我国的各省、自治直辖市，例如 bj 为北京市，sh 为上海市等</li>\n</ul>\n<p><strong>因特网的域名空间</strong></p>\n<p>因特网的域名可看做一颗倒着生长的树</p>\n<p>这种按等级管理的命名方法便于维护名字的唯一性，并且也容易设计出一种高效的域名查询机制。需要注意的是，域名只是个逻辑概念，并不代表计算机所在物理地点</p>\n<p><strong>域名服务器</strong></p>\n<p>域名和 IP 地址的映射关系必须保存在域名服务器中，供所有其他应用查询。显然不能将所有信息都储存在一台域名服务器中。DNS 使用分布在各地的域名服务器来实现域名到 IP 地址的转换</p>\n<p>域名服务器可以划分为以下四种不同的类型</p>\n<ul>\n<li>根域名服务器\n<ul>\n<li>根域名服务器是最高层次的域名服务器，每个根域名服务器都知道所有顶级域名服务器的域名及其 IP 地址。因特网上共有 13 个不同 IP 地址的根域名服务器。尽管我们将这 13 个根域名服务器中的每一个都视为单个的服务器，但 &quot;每台服务器&quot; 实际上是由许多分布在世界各地的计算机构组成的服务器群集。当本地域名服务器向根域名服务器发出请求时，路由器就把查询请求报文转发到离这个 DNS 客户最近的一个根域名服务器。这就加快了 DNS 的查询过程，同时也更合理地利用了因特网的资源。根域名服务器通常并不直接对域名进行解析，而是返回该域名所属顶级域名的顶级域名服务器的 IP 地址。</li>\n</ul>\n</li>\n<li>顶级域名服务器\n<ul>\n<li>这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名，当收到 DNS 查询请求时就给出相应的回答（可能是最后的结果，也可能是下一级权限域名服务器的 IP 地址）</li>\n</ul>\n</li>\n<li>权限域名服务器\n<ul>\n<li>这些域名服务器负责管理某个地区的域名。每一个主机的域名都必须在某个权限域名服务器处注册登记。因此权限域名服务器直到其管辖的域名和 IP 地址的映射关系。另外，权限域名服务器还知道其下级域名服务器的地址</li>\n</ul>\n</li>\n<li>本地域名服务器\n<ul>\n<li>本地域名服务器不属于上述的域名服务器的等级结构。当一个主机发出 DNS 请求报文时，这个报文就首先被送往该主机的本地域名服务器。本地域名服务器起着代理的作用，会将该报文转发到上述的域名服务器的等级结构中。每一个因特网服务提供者 ISP，一个大学，甚至一个大学里的学院，都可以拥有一个本地域名服务器，它有时也称为默认域名服务器，本地域名服务器离用户较近，一般不超过几个路由器的距离，也有可能就在同一个局域网内。本地域名服务器的 IP 地址需要直接配置在需要域名解析的主机中。</li>\n</ul>\n</li>\n</ul>\n<p><strong>域名解析过程</strong></p>\n<ul>\n<li>递归查询</li>\n<li>迭代查询</li>\n</ul>\n<p><img data-src=\"F:%5CBlog%5Cimages%5C%E8%AE%A1%E7%BD%91408-6-2.png\" alt=\"递归查询与迭代查询\" /></p>\n<p>为了提高 DNS 的查询效率，并减轻根域名服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存。高速缓存用来存放最近查询的域名以及从何处获得域名映射信息的记录</p>\n<p>由于域名到 IP 地址的映射关系并不是永久不变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并删除超过合理时间的项（例如，每个项目只存放两天）</p>\n<p>不但在本地域名服务器中需要缓存，在用户主机中也很需要。许多用户主机在启动时从本地域名服务器下载域名和 IP 地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到域名时才向域名服务器查询。同理，主机也需要保持高速缓存中内容的正确性</p>\n<p><strong>习题</strong></p>\n<p>1、如果本地域名服务器无缓存，当采用递归方法解析另一网络某主机域名时，用户主机、本地域名服务器发送的域名请求消息数分别为（A）</p>\n<p>A. 一条、一条              B、一条、多条             C、多条、一条           D、多条、多条</p>\n<p>解析：主机发送一条 DNS 查询给本地域名服务器，由于本地域名服务器中没有缓存，因此本地域名服务器就会向根域名服务器发出一条 DNS 查询，最终根域名服务器将结果返回给本地域名服务器，本地域名服务器再将结果返回给主机</p>\n<p>2、<img data-src=\"https://s2.loli.net/2024/08/13/Wrtali2oEjwO93G.png\" alt=\"习题\" /></p>\n<p>解析：H4 发出域名查询时，DNS 服务器可能有对域名的缓存，因此 DNS 查询最少为 0 次，而由于采用的是迭代查询方式，因此，DNS 查询最多次数为 3 次，分别向根域名服务器、顶级域名服务器 (.com)、权限域名服务器 (<span class=\"exturl\" data-url=\"aHR0cDovL3h5ei5jb20=\">xyz.com</span>) 和权限域名服务器 (<span class=\"exturl\" data-url=\"aHR0cDovL2FiYy54eXouY29t\">abc.xyz.com</span>) 发送 DNS 查询，因此答案选 C</p>\n<h3 id=\"文件传送协议ftp\"><a class=\"anchor\" href=\"#文件传送协议ftp\">#</a> 文件传送协议 FTP</h3>\n<p>将某台计算机中的文件通过网络传送到可能相距很远的一台计算机中，是一项基本的网络应用，即文件传送</p>\n<p>文件传送协议 FTP 是因特网上使用得最广泛的文件传送协议</p>\n<ul>\n<li>FTP 提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用 ASCII 码），并允许文件具有存取权限（如访问文件的用户必须经过授权，并输入有效的口令）</li>\n<li>FTP 屏蔽了各计算机系统的细节，因而适用于在各异构网络中任意计算机之间传送文件</li>\n</ul>\n<p>在因特网发展的早期阶段，用 FTP 传送文件约占整个因特网的通信量的三分之一，而由电子邮件和域名系统所产生的通信量还要小于 FTP 所产生的通信量。</p>\n<p>根据应用需求的不同，FTP 服务器可能需要一台高性能和高可靠性的服务器计算机，也可能只需要一台普通的个人计算机即可</p>\n<p>FTP 的常见用途是在计算机之间传输文件，尤其是用于批量传输文件</p>\n<p>FTP 的另一个常见用途是让网站设计者将构成网站内容的大量文件批量上传到他们的 Web 服务器</p>\n<p><strong>FTP 基本工作原理</strong></p>\n<p>主动模式（建立数据通道时，FTP 服务器主动连接 FTP 客户）</p>\n<ul>\n<li>FTP 客户发起的 TCP 连接\n<ul>\n<li>用于传送控制命令的 TCP 连接\n<ul>\n<li>控制连接在整个会话期间一直保持打开，用于传送 FTP 相关控制命令</li>\n</ul>\n</li>\n<li>有数据要传输时，FTP 客户通过命令通道告知 FTP 服务器来与自己的另一个临时临时端口建立连接，建立数据通道</li>\n</ul>\n</li>\n<li>FTP 服务器发起的 TCP 连接\n<ul>\n<li>用于传送数据的 TCP 连接\n<ul>\n<li>数据连接用于文件传输，在每次文件传输时才建立传输结束就关闭</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>被动模式（建立数据通道时，FTP 服务器被动等待 FTP 客户的连接）</p>\n<ul>\n<li>FTP 客户发起的 TCP 连接\n<ul>\n<li>用于传送控制命令的 TCP 连接\n<ul>\n<li>控制连接在整个会话期间一直保持打开，用于传送 FTP 相关控制命令</li>\n</ul>\n</li>\n<li>有数据要传输时，FTP 客户通过命令通道告知 FTP 服务器开启某个临时端口被动等待 TCP 连接，建立数据通道</li>\n</ul>\n</li>\n<li>FTP 客户发起的 TCP 连接\n<ul>\n<li>用于传送数据的 TCP 连接\n<ul>\n<li>数据连接用于文件传输，在每次文件传输时才建立传输结束就关闭</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、FTP 客户和服务器间传递 FTP 命令时，使用的连接是（A）</p>\n<p>A. 建立在 TCP 之上的控制连接     B. 建立在 TCP 之上的数据连接          C. 建立在 UDP 之上的控制连接     D. 建立在 UDP 之上的数据连接</p>\n<p>解析：FTP 客户和服务器之间要建立两个并行的 TCP 连接：一个是控制连接，在整个会话期间一直保持打开，用于传送 FTP 相关控制命令。另一个是数据连接，在每次文件传输时才建立，传输结束就关闭</p>\n<p>2、下列关于 FTP 协议的叙述中，错误的是（C）</p>\n<p>A. 数据连接在每次数据传输完毕后就关闭           B. 控制连接在整个会话期间保持打开状态</p>\n<p>C. 服务器与客户端的 TCP 20 端口建立数据连接     D. 客户端与服务器的 TCP 20 端口建立控制连接</p>\n<p>解析：默认情况下，FTP 使用 TCP 21 端口进行控制连接，TCP 20 端口进行数据连接。但是，是否使用 TCP 20 端口建立数据连接与传输模式有关，主动方式使用 TCP 20 端口，被动方式由服务器和客户端自行协商决定</p>\n<h3 id=\"电子邮件\"><a class=\"anchor\" href=\"#电子邮件\">#</a> 电子邮件</h3>\n<p>电子邮件是因特网上最早流行的一种应用，并且仍然是当今因特网上最重要、最实用的应用之一</p>\n<p>传统的电话通信属于实时通信，存在以下两个缺点：</p>\n<ul>\n<li>电话通信的主叫和被叫双方必须同时在场</li>\n<li>一些不是十分紧迫的电话也常常不必要地打断人们的工作或休息</li>\n</ul>\n<p>而电子邮件与邮政系统的寄信相似</p>\n<ul>\n<li>发件人将邮件发送到自己使用的邮件服务器</li>\n<li>发件人的邮件服务器将收到的邮件按其目的地址转发到收件人邮件服务器中的收件人邮箱</li>\n<li>收件人在方便的时候访问收件人邮件服务器中自己的邮箱，获取收到的电子邮件</li>\n</ul>\n<p>电子邮件使用方便、传递迅速且费用低廉。它不仅可以传送文字信息，而且还可以附上声音和图像</p>\n<p>由于电子邮件的广泛使用，现在许多国家已经正式取消了电报业务。在我国，电信局的电报业也因电子邮件的普及而濒临消失</p>\n<p><strong>电子邮件系统</strong></p>\n<p>电子邮件系统采用客户 / 服务器方式</p>\n<p>电子邮件系统的三个主要组成构件：用户代理，邮件服务器，以及电子邮件所需的协议</p>\n<ul>\n<li>用户代理是用户与电子邮件系统的接口，又称为电子邮件客户端软件</li>\n<li>邮件服务器是电子邮件系统的基础设施。因特网上所有的 ISP 都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱</li>\n<li>协议包括发送协议（例如 SMTP）和邮件读取协议（例如 POP3，IMAP）</li>\n</ul>\n<p><strong>简单邮件传送协议 SMTP</strong></p>\n<p>SMTP 基本工作原理</p>\n<p><img data-src=\"F:%5CBlog%5Cimages%5C%E8%AE%A1%E7%BD%91408-6-4.png\" alt=\"SMTP原理\" /></p>\n<p>电子邮件的信息格式并不是由 SMTP 定义的，而是在 RFC 22 中单独定义的。这个 RFC 文档已更新为 RFC 5322。一个电子邮件由信封和内容两部分。而内容又由首部和主体两部分构成</p>\n<p>SMTP 协议只能传送 ASCII 码文本数据，不能传送可执行文件或其他的二进制对象</p>\n<p>SMTP 不能满足传送多媒体邮件（例如带有图片、音频或视频数据）的需要。并且许多其他非英语国家的文字也无法用 SMTP 传送</p>\n<p>为解决 SMTP 传送非 ASCII 码文本的问题，提出了多用途因特网邮件扩展 MIME</p>\n<ul>\n<li>增加了 5 个新的邮件首部字段，这些字段提供了有关邮件主体信息</li>\n<li>定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li>\n<li>定义了传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li>\n</ul>\n<p>实际上，MIME 不仅仅用于 SMTP，也用于后来的同样面向 ASCII 字符的 HTTP</p>\n<p><strong>邮件读取</strong></p>\n<p>常用的邮件读取协议有以下两个：</p>\n<ul>\n<li>邮局协议 POP，POP3 是其第三个版本，是因特网正式标准\n<ul>\n<li>非常简单、功能有限的邮件读取协议。用户只能以下载并删除方式或下载并保留方式从邮件服务器下载邮件到用户方计算机。不允许用户在邮件服务器上管理自己的邮件（例如创建文件夹，对邮件进行分类管理等）</li>\n</ul>\n</li>\n<li>因特网邮件访问协议 IMAP，IMAP4 是其第四个版本，目前还只是因特网建议标准\n<ul>\n<li>功能比 POP3 强大的邮件读取协议。用户在自己的计算机上就可以操控邮件服务器中的邮箱，就像在本地操控一样，因此 IMAP 是一个联机协议</li>\n</ul>\n</li>\n<li>POP3 和 IMAP4 都采用基于 TCP 连接的客户 / 服务器方式。POP3 使用熟知端口 110，IMAP4 使用熟知端口 143</li>\n</ul>\n<p><strong>基于万维网的电子邮件</strong></p>\n<ul>\n<li>通过浏览器登录（提供用户名和口令）邮件服务器万维网网站就可以撰写、收发、阅读和管理电子邮件。这种工作模式与 IMAP 很类似，不同的是用户计算机无需安装专门的用户代理程序，只需要使用通过的万维网浏览器</li>\n<li>邮件服务器网站通常都提供非常强大和方便的邮件管理功能，用户可以在邮件服务器网站上管理和处理自己的邮件，而不需要将邮件下载到本地进行管理</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、<img data-src=\"F:%5CBlog%5Cimages%5C%E8%AE%A1%E7%BD%91408-6-5.png\" alt=\"习题\" /></p>\n<p>解析：用户给用户服务器发送使用 SMTP 协议，用户邮件服务器发送给另一个用户邮件服务器使用 SMTP 协议，用户从用户邮件服务器接收邮件使用 POP3 协议，因此答案选 D</p>\n<p>2、下列关于 SMTP 协议的叙述中，正确的是（A）</p>\n<p>I. 只支持传输 7 比特 ASCII 码内容        II. 支持在邮件服务器之间发送邮件</p>\n<p>III. 支持从用户代理向邮件服务器发送邮件         IV. 支持从邮件服务器向用户代理发送邮件</p>\n<p>A. 仅 I、II 和 III        B. 仅 I、II 和 IV         C. 仅 I、III 和 IV       D. 仅 II、III 和 IV</p>\n<p>解析：邮件服务器向用户代理发送邮件需要使用 POP3 或者 IMAP4 协议，IV 错误，SMTP 只支持 ASCII 码传输，非 ASCII 码数据需要经过 MIME 转换，因此选 A</p>\n<p>3、无需转换即可由 SMTP 协议直接传输的内容是（D）</p>\n<p>A.JPEG 图形      B.MPEG 视频           C.EXE 文件            D.ASCII 文本</p>\n<p>解析：SMTP 协议只支持传输 ASCII 码，因此只有 D 才可以不经转换直接传输</p>\n<h3 id=\"万维网www\"><a class=\"anchor\" href=\"#万维网www\">#</a> 万维网 WWW</h3>\n<p>万维网 WWW 并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用</p>\n<p>万维网利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网</p>\n<p>浏览器最重要的部分是渲染引擎，也就是浏览器内核。负责对网页内容进行解析和显示</p>\n<ul>\n<li>不同的浏览器内核对网页内容的解析也有不同，因此同一网页在不同内核的浏览器里的显示效果可能不同</li>\n<li>网页编写者需要在不同内核的浏览器中测试网页显示效果</li>\n</ul>\n<p>为了方便地访问在世界范围内的文档，万维网使用统一资源定位符 URL 来指明因特网上任何种类 &quot;资源&quot; 的位置。</p>\n<p>URL 的一般形式由以下四个部分组成：&lt;协议&gt;://&lt; 主机 &gt;:&lt; 端口 &gt;/&lt; 路径 &gt;</p>\n<p>万维网的文档：</p>\n<ul>\n<li>超文本标记语言 HTML\n<ul>\n<li>使用多种标签来描述网页的结构和内容</li>\n</ul>\n</li>\n<li>层叠样式表 CSS\n<ul>\n<li>从审美的角度来描述网页的样式</li>\n</ul>\n</li>\n<li>一种脚本语言 JavaScript\n<ul>\n<li>控制网页的行为</li>\n</ul>\n</li>\n</ul>\n<p><strong>超文本传输协议 HTTP</strong></p>\n<p>HTTP 定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器</p>\n<p>HTTP/1.0 采用非持续连接方式。在该方式下，每次浏览器要请求一个文件都要与服务器建立 TCP 连接，当收到响应后就立即关闭连接</p>\n<ul>\n<li>每请求一个文档就要有两倍的 RTT 的开销。若一个网页上有很多引用对象（例如图片等），那么请求每一个对象都需要花费 2RTT 的时间</li>\n<li>为了减小时延，浏览器通常会建立多个并行的 TCP 连接同时请求多个对象。但是，这会大量占用万维网服务器的资源，特别是万维网服务器往往要同时服务于大量客户的请求，这会使其负担很重</li>\n</ul>\n<p>HTTP/1.1 采用持续连接方式。在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的 HTTP 请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，而是只要这些文档都在同一个服务器上就行。</p>\n<ul>\n<li>为了进一步提高效率，HTTP/1.1 的持续连接还可以使用流水线方式工作，即浏览器在收到 HTTP 的响应报文之前就能够连续发送多个请求报文。这样的一个接一个的请求报文到达服务器后，服务器就发回一个接一个的响应报文，这样就节省了很多个 RTT 时间，使 TCP 连接中的空闲时间减少，提高了下载文档的效率</li>\n</ul>\n<p>HTTP 的报文格式：</p>\n<ul>\n<li>HTTP 是面向文本的，其报文的每一个字段都是一些 ASCII 码串，并且每个字段的长度都是不确定的</li>\n</ul>\n<p><img data-src=\"F:%5CBlog%5Cimages%5C%E8%AE%A1%E7%BD%91408-6-6.png\" alt=\"HTTP报文格式\" /></p>\n<p>使用 Cookie 在服务器上记录用户信息</p>\n<ul>\n<li>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此 HTTP 被设计为了一种无状态的协议。这样可以简化服务器的设计</li>\n<li>现在，用户可以通过万维网实现各种复杂的应用，如网上购物、电子商务等。这些应用往往需要万维网服务器能够识别用户</li>\n<li>Cookie 提供了一种机制使得万维网服务器能够记住用户，而无需用户主动提供用户标识信息。也就是说，Cookie 是一种对无状态的 HTTP 进行状态化的技术</li>\n</ul>\n<p><img data-src=\"F:%5CBlog%5Cimages%5C%E8%AE%A1%E7%BD%91408-6-7.png\" alt=\"Cookie工作过程\" /></p>\n<p>万维网缓存和代理服务器</p>\n<ul>\n<li>在万维网中还可以使用缓存机制以提高万维网的效率</li>\n<li>万维网缓存又称为 Web 缓存，可位于客户机，也可位于中间系统上，位于中间系统上的 Web 缓存又称为代理服务器</li>\n<li>Web 缓存把最近的一些请求和响应暂存在本地磁盘中。当新请求达到时，若发现这个请求与暂时存放的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去因特网访问该资源</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、某浏览器发出的 HTTP 请求报文如下：</p>\n<figure class=\"highlight http\"><figcaption data-lang=\"HTTP\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token request-line\"><span class=\"token method property\">GET</span> <span class=\"token request-target url\">/index.html</span> <span class=\"token http-version property\">HTTP/1.1</span></span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">Host</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">www.test.edu.cn</span></span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">Connection</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">Close</span></span></pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token header\"><span class=\"token header-name keyword\">Cookie</span><span class=\"token punctuation\">:</span> <span class=\"token header-value\">123456</span></span></pre></td></tr></table></figure><p>下列叙述中，错误的是（C）</p>\n<p>A. 该浏览器请求浏览 index.html</p>\n<p>B.index.html 存放在 www.test.edu.cn 上</p>\n<p>C. 该浏览器请求使用持续连接</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL0QueG4tLXd3dy1uMjVlODE3ZWZ2aWNhMzI0OWNkYTgxNWN1eW1uMHcudGVzdC5lZHUuY24=\">D. 该浏览器曾静浏览过 www.test.edu.cn</span></p>\n<p>解析：请求行：指明方法 GET，URL，HTTP 版本。首部行开始：指明服务器的域名；Connection 告诉服务器发送完请求的文档后就可以释放连接，即非持续连接，若是持续连接方式，取值应为 keep-alive，而不是 close，因此 C 错误。Cookie 识别码有值，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS13d3ctbjI1ZTgxN2VmdmlnNHV6Z2t4d3Z3ZWRnNmczcm84b3QudGVzdC5lZHUuY24=\">表示浏览器曾经访问过 www.test.edu.cn</span></p>\n<p>2、假设 HTTP1.1 协议以持续的非流水线方式工作，一次请求 - 响应的时间为 RTT，rfc.html 页面引用了 2 个 JPEG 小图像，则浏览器从开始建立 TCP 连接到收到全部内容为止，需要多少个 RTT？</p>\n<p>解析：由于是非流水线方式，只有收到上一个响应，才能发送下一个请求。首先先建立 TCP 连接，进行三报文握手，因此需要 1 个 RTT，然后请求 rfc.html 花费一个 RTT，请求该 html 页面引用的两个图像，花费 2 个 RTT，因此总共花费了 4 个 RTT</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-1/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-1/",
            "title": "操作系统408-5-1",
            "date_published": "2024-08-11T11:02:07.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"io设备的概念和分享\"><a class=\"anchor\" href=\"#io设备的概念和分享\">#</a> I/O 设备的概念和分享</h3>\n<p><strong>什么是 I/O 设备</strong></p>\n<p>I/O 设备就是可以将数据输入到计算机，或者可以接受计算机输出数据的外部设备，属于计算机中的硬件部件</p>\n<p>UNIX 系统将外部设备抽象为一种特殊的文件，用户可以使用与文件操作相同的方式对外部设备进行操作</p>\n<p><strong>I/O 设备的分类 —— 按使用特性</strong></p>\n<ul>\n<li>人机交互类外部设备：\n<ul>\n<li>鼠标、键盘、打印机等</li>\n<li>数据传输速度慢</li>\n</ul>\n</li>\n<li>存储设备\n<ul>\n<li>移动硬盘、光盘等</li>\n<li>数据传输速度快</li>\n</ul>\n</li>\n<li>网络通信设备\n<ul>\n<li>路由器等</li>\n<li>介于上述二者之间</li>\n</ul>\n</li>\n</ul>\n<p><strong>I/O 设备的分类 —— 按传输速率分类</strong></p>\n<ul>\n<li>低速设备\n<ul>\n<li>鼠标、键盘等</li>\n<li>传输速率每秒几个到几百字节</li>\n</ul>\n</li>\n<li>中速设备\n<ul>\n<li>激光打印机</li>\n<li>传输速率每秒千至上万个字节</li>\n</ul>\n</li>\n<li>高速设备\n<ul>\n<li>磁盘等</li>\n<li>传输速率为每秒数千至千兆字节的设备</li>\n</ul>\n</li>\n</ul>\n<p><strong>I/O 设备的分类 —— 按信息交换的单位分类</strong></p>\n<ul>\n<li>块设备\n<ul>\n<li>磁盘等</li>\n<li>数据传输单位为块，传输速率比较高，可寻址</li>\n</ul>\n</li>\n<li>字符设备\n<ul>\n<li>鼠标、键盘等</li>\n<li>数据传输单位是字符，传输速率慢，不可寻址</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"io控制器\"><a class=\"anchor\" href=\"#io控制器\">#</a> I/O 控制器</h3>\n<h4 id=\"io设备的机械部件\"><a class=\"anchor\" href=\"#io设备的机械部件\">#</a> I/O 设备的机械部件</h4>\n<p>I/O 设备的机械部件主要用来执行具体 I/O 操作</p>\n<p>I/O 设备的电子部件通常是一块插入主板扩充槽的印刷电路板</p>\n<h4 id=\"io设备的电子部件io控制器\"><a class=\"anchor\" href=\"#io设备的电子部件io控制器\">#</a> I/O 设备的电子部件（I/O 控制器）</h4>\n<p>CPU 无法直接控制 I/O 设备的机械部件，因此 I/O 设备还要有一个电子部件作为 CPU 和 I/O 设备机械部件之间的 &quot;中介&quot;，用于实现 CPU 对设备的控制。</p>\n<p>这个电子部件就是 I/O 控制器，又称设备控制器。CPU 可控制 I/O 控制器，又由 I/O 控制器来控制设备的机械部件</p>\n<p>I/O 控制器的功能：</p>\n<ul>\n<li>接受和识别 CPU 发出的命令\n<ul>\n<li>如 CPU 发来的 read/write 命令，I/O 控制器中会有相应的控制寄存器来存放命令和参数</li>\n</ul>\n</li>\n<li>向 CPU 报告设备的状态\n<ul>\n<li>I/O 控制器中会有相应的状态寄存器，用于记录 I/O 设备的当前状态。如 1 表示空闲，0 表示忙碌</li>\n</ul>\n</li>\n<li>数据交换\n<ul>\n<li>I/O 控制器中会设置相应的数据寄存器。输出时，数据寄存器用于暂存 CPU 发来的数据，之后再由控制器传送设备。输入时，数据寄存器用于暂存设备发来的数据，之后 CPU 从数据寄存器中取走数据</li>\n</ul>\n</li>\n<li>地址识别\n<ul>\n<li>类似于内存的地址，为了区分设备控制器中的各个寄存器，也需要给各个寄存器设置一个特定的 &quot;地址&quot;。I/O 控制器通过 CPU 提供的 &quot;地址&quot; 来判断 CPU 要读 / 写的是哪个寄存器</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"io控制器的组成\"><a class=\"anchor\" href=\"#io控制器的组成\">#</a> I/O 控制器的组成</h4>\n<ul>\n<li>I/O 逻辑\n<ul>\n<li>负责接收和识别 CPU 的各种命令（如地址译码），并负责对设备发出命令</li>\n</ul>\n</li>\n<li>CPU 与控制器的接口\n<ul>\n<li>用于实现 CPU 与控制器之间的通信。CPU 通过控制线发出命令；通过地址线指明要操作的设备；通过数据线来取出（输入）数据，或放入（输出）数据</li>\n</ul>\n</li>\n<li>控制器与设备的接口\n<ul>\n<li>用于实现控制器与设备之间的通信</li>\n</ul>\n</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>一个 I/O 控制器可能会对应多个设备</li>\n<li>数据寄存器、控制寄存器、状态寄存器可能有多个（如：每个控制 / 状态寄存器对应一个具体的设备），且这些寄存器都要有相同的地址，才能方便 CPU 操作。有的计算机会让这些寄存器占用内存地址的一部分，称为内存映象 I/O，另一些计算机则采用 I/O 专用地址，即寄存器独立编址</li>\n</ul>\n<p><strong>内存映象 I/O vs 寄存器独立编址</strong></p>\n<p>内存映象 I/O：</p>\n<ul>\n<li>内存映射 I/O。控制器中的寄存器与内存地址统一编址</li>\n<li>优点：简化了指令。可以采用对内存进行操作的指令来对控制器进行操作</li>\n</ul>\n<p>寄存器独立编制：</p>\n<ul>\n<li>\n<p>寄存器独立编制。控制器中的寄存器使用单独的地址</p>\n</li>\n<li>\n<p>缺点：需要设置专门的指令来实现对控制器的操作，不仅要指明寄存器的地址，还要指明控制器的编号</p>\n</li>\n</ul>\n<h3 id=\"io控制方式\"><a class=\"anchor\" href=\"#io控制方式\">#</a> I/O 控制方式</h3>\n<h4 id=\"程序直接控制方式\"><a class=\"anchor\" href=\"#程序直接控制方式\">#</a> 程序直接控制方式</h4>\n<p>轮询</p>\n<ul>\n<li>完成一次读 / 写操作的流程（以读操作为例）\n<ul>\n<li>CPU 向控制器发出读指令。于是设备启动，并且状态寄存器设为 1（未就绪）</li>\n<li>轮询检查控制器的状态（其实就是在不断地执行程序的循环，若状态位一直是 1，说明设备还没准备好要输入的数据，于是 CPU 会不断地轮询）</li>\n<li>输入设备准备好数据后将数据传给控制器，并报告自身状态</li>\n<li>控制器将输入的数据放到数据寄存器中，并将状态数改为 0（已就绪）</li>\n<li>CPU 发现设备已就绪，即可将数据寄存器中的内容读入 CPU 的寄存器中，再把 CPU 寄存器中的内容放入内存</li>\n<li>若还要继续读入数据，则 CPU 继续发出读指令</li>\n</ul>\n</li>\n</ul>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/TvbZ6BUepErGWQS.png\" alt=\"程序控制方式\" /></p>\n<ul>\n<li>CPU 干预的频率\n<ul>\n<li>很频繁，I/O 操作开始之前、完成之后需要 CPU 介入，并且在等待 I/O 完成的过程中 CPU 需要不断地轮询检查</li>\n</ul>\n</li>\n<li>数据传送的单位：每次读 / 写一个字</li>\n<li>数据的流向\n<ul>\n<li>读操作（数据读入）：I/O 设备 -&gt;CPU（指 CPU 的寄存器）-&gt; 内存</li>\n<li>写操作（数据输出）：内存 -&gt;CPU-&gt;I/O 设备</li>\n<li>每个字的读 / 写都需要 CPU 的帮助</li>\n</ul>\n</li>\n<li>主要缺点和主要优点\n<ul>\n<li>优点：实现简单。在读 / 写指令之后，加上实现循环检查的一系列指令即可（因此才称为 &quot;程序直接控制方式&quot;）</li>\n<li>缺点：CPU 和 I/O 设备只能串行工作，CPU 需要一直轮询检查，长期处于 &quot;忙等&quot; 状态，CPU 利用率低</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"中断驱动方式\"><a class=\"anchor\" href=\"#中断驱动方式\">#</a> 中断驱动方式</h4>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/gYshUBfta65EeW8.png\" alt=\"中断驱动方式\" /></p>\n<p>引入中断机制。由于 I/O 设备速度很慢，因此在 CPU 发出读 / 写命令后，可将等待 I/O 的进程阻塞，先切换到别的进程执行。当 I/O 完成后，控制器会向 CPU 发出一个中断信号，CPU 检测到中断信号后，会保存当前进程的运行环境信息，转去执行中断处理程序处理该中断。处理中断的过程中，CPU 从 I/O 控制器读一个字的数据传送到 CPU 寄存器，再写入主存。接着，CPU 恢复等待 I/O 的进程（或其他进程）的运行环境，然后继续执行</p>\n<ul>\n<li>\n<p>注意：</p>\n<ul>\n<li>\n<p>CPU 会在每个指令周期的末尾检查中断</p>\n</li>\n<li>\n<p>中断处理过程中需要保存、恢复进程的运行环境，这个过程是需要一定时间开销的。可见，如果中断发生的频率太高，也会降低系统性能</p>\n</li>\n</ul>\n</li>\n<li>\n<p>CPU 的干预频率：每次 I/O 操作开始之前，完成之后需要 CPU 介入。等待 I/O 完成的过程中 CPU 可以切换到别的进程执行</p>\n</li>\n<li>\n<p>数据传送的单位</p>\n<ul>\n<li>每读 / 写一个字</li>\n</ul>\n</li>\n<li>\n<p>数据的流向：</p>\n<ul>\n<li>读操作（数据读入）：I/O 设备 -&gt;CPU（指 CPU 的寄存器）-&gt; 内存</li>\n<li>写操作（数据输出）：内存 -&gt;CPU-&gt;I/O 设备</li>\n</ul>\n</li>\n<li>\n<p>主要优点和主要缺点：</p>\n<ul>\n<li>优点：与 &quot;程序控制方式&quot; 相比，在 &quot;中断驱动方式&quot; 中，I/O 控制器会通过中断信号主动报告 I/O 已完成，CPU 不再需要不停地轮询。CPU 和 I/O 设备可并行工作，CPU 利用率得到明显提升</li>\n<li>缺点：每个字在 I/O 设备与内存之间的传输，都需要经过 CPU。而频繁的中断处理会消耗较多的 CPU 时间</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"dma方式\"><a class=\"anchor\" href=\"#dma方式\">#</a> DMA 方式</h4>\n<p>与中断驱动方式相比，DMA 方式（直接存储器存取。主要用于块设备的 I/O 控制）有这样几个改进：</p>\n<ul>\n<li>数据的传送单位是 &quot;块&quot; 不再是一个字、一个字的传送</li>\n<li>数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要 CPU 作为中间传递设备</li>\n<li>仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预</li>\n</ul>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/FxUirSlI8wKsLqa.png\" alt=\"DMA方式\" /></p>\n<p>CPU 指明此次要进行的操作（如：读操作），并说明读入多少数据、数据要存放在内存的什么位置、数据在外部设备上的地址（如：在磁盘上的地址）</p>\n<p>控制器会根据 CPU 提出的要求完成数据的读 / 写工作，整块数据的传输完成后，才向 CPU 发出中断信号</p>\n<p>DMA 控制器结构：</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/OtXYwbN8LPRFVmi.png\" alt=\"DMA控制器\" /></p>\n<ul>\n<li>CPU 干预的频率\n<ul>\n<li>仅在传送一个或多个数据块的开始和结束时，才需要 CPU 干预</li>\n</ul>\n</li>\n<li>数据传送的单位：\n<ul>\n<li>每次读 / 写一个或多个块（注意：每次读写的只能是连续的多个块，且这些块在读入内存后在内存中也必须是连续的）</li>\n</ul>\n</li>\n<li>数据的流向：\n<ul>\n<li>读操作（数据读入）：I/O 设备 -&gt; 内存</li>\n<li>写操作（数据输出）：内存 -&gt;I/O 设备</li>\n</ul>\n</li>\n<li>主要缺点和优点：\n<ul>\n<li>优点：数据传输以 &quot;块&quot; 为单位，CPU 介入频率进一步降低。数据的传输不再需要先经过 CPU 再写入内存，数据传输效率进一步增加。CPU 和 I/O 设备的并行性得到提升</li>\n<li>缺点：CPU 每发出一条 I/O 指令，只能读 / 写一个或多个连续的数据块</li>\n<li>如果要读 / 写多个离散存储的数据块，或者要将数据分别写在不同的内存区域时，CPU 要分别发出多条 I/O 指令，进行多次中断处理才能完成</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"通道控制方式\"><a class=\"anchor\" href=\"#通道控制方式\">#</a> 通道控制方式</h4>\n<p>通道：一种硬件，可以理解为是 &quot;弱化版的 CPU&quot;（与 CPU 相比，通道可以执行的指令很单一，并且通道程序是放在主机内存中的，也就是说通道与 CPU 共享内存）。通道可以识别并执行一系列通道指令</p>\n<ul>\n<li>\n<p>CPU 向通道发出 I/O 指令。指明通道程序在内存中的位置，并指明要操作的是哪个 I/O 设备。之后 CPU 就切换到其他进程执行了</p>\n</li>\n<li>\n<p>通道执行内存中的通道程序（其中指明了要读入 / 写出多少数据，读 / 写的数据应放在内存的什么位置等信息）</p>\n</li>\n<li>\n<p>通道执行完规定的任务后，向 CPU 发出中断信号，之后 CPU 对中断进行处理</p>\n</li>\n</ul>\n<p>CPU 的干预频率：</p>\n<ul>\n<li>极低，通道会根据 CPU 的指示执行相应的通道程序，只有完成一组数据块的读 / 写后才需要发出中断信号，请求 CPU 干预</li>\n</ul>\n<p>数据传送的单位</p>\n<ul>\n<li>每次读 / 写一组数据块</li>\n</ul>\n<p>数据的流向（在通道的控制下进行）：</p>\n<ul>\n<li>读操作（数据读入）：I/O 设备 -&gt; 内存</li>\n<li>写操作（数据输出）：内存 -&gt;I/O 设备</li>\n</ul>\n<p>主要缺点优点：</p>\n<ul>\n<li>缺点：实现复杂，需要专门的通道硬件支持</li>\n<li>优点：CPU、通道、I/O 设备可并行工作，资源利用率很高</li>\n</ul>\n<h3 id=\"io软件层次结构\"><a class=\"anchor\" href=\"#io软件层次结构\">#</a> I/O 软件层次结构</h3>\n<h4 id=\"用户层软件\"><a class=\"anchor\" href=\"#用户层软件\">#</a> 用户层软件</h4>\n<p>用户层软件实现了与用户交互的接口，用户可直接使用该层提供的、与 I/O 操作相关的库函数对设备进行操作</p>\n<p>用户层软件将用户请求翻译成格式化的 I/O 请求，并通过 &quot;系统调用&quot; 请求操作系统内核的服务</p>\n<p>用户层上封装了一系列更方便的库函数接口供用户使用</p>\n<h4 id=\"设备独立性软件\"><a class=\"anchor\" href=\"#设备独立性软件\">#</a> 设备独立性软件</h4>\n<p>设备独立性软件，又被称为设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现</p>\n<p>主要实现的功能：</p>\n<ul>\n<li>向上层提供统一的调用接口</li>\n<li>设备的保护（原理类似于对文件的保护。设备被看成一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样）</li>\n<li>差错处理（设备独立性软件需要对一些设备的错误进行处理）</li>\n<li>设备的分配与回收</li>\n<li>数据缓冲区管理（可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异）</li>\n<li>建立逻辑设备名到物理设备名的映射关系：根据设备类型选择调用相应的驱动程序\n<ul>\n<li>设备独立性软件需要通过 &quot;逻辑设备表&quot; 来确定逻辑设备对应的物理设备，并找到该设备对应的设备驱动程序</li>\n<li>操作系统可以采用两种方式管理逻辑设备表：\n<ul>\n<li>第一种：整个系统只设置一张 LUT，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统</li>\n<li>第二种：为每个用户设置一张 LUT，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而 LUT 就存放在用户管理进程的 PCB 中</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"设备驱动程序\"><a class=\"anchor\" href=\"#设备驱动程序\">#</a> 设备驱动程序</h4>\n<p>主要负责对硬件设备的具体控制，将上层发出的一系列命令（如 read/write）转化成特定设备 &quot;能听得懂&quot; 的一系列操作。包括设置设备寄存器；检查设备状态等</p>\n<p>不同设备的内部硬件特性不同，这些特性只有厂家才知道，因此厂家需要根据设备的硬件特性设计并提供相对应的驱动程序，CPU 执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作</p>\n<p>注：驱动程序一般会以一个独立进程的方式存在</p>\n<h4 id=\"中断处理程序\"><a class=\"anchor\" href=\"#中断处理程序\">#</a> 中断处理程序</h4>\n<p>当 I/O 任务完成时，I/O 控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。</p>\n<p><strong>总结</strong></p>\n<p>直接涉及到硬件具体细节、且与中断无关的操作肯定是设备驱动程序层完成的；没有设计硬件、对各种设备都需要进行的管理工作都是由设备独立性软件层完成的</p>\n<p>逻辑设备表作用：建立逻辑设备名到物理设备名的映射关系：根据设备类型选择调用相应的驱动程序</p>\n<h3 id=\"输入输出应用程序接口\"><a class=\"anchor\" href=\"#输入输出应用程序接口\">#</a> 输入输出应用程序接口</h3>\n<p>输入输出应用程序接口是由设备独立软件提供给用户 I/O 软件的，由于设备多种多样，因此需要提供若干类型的接口</p>\n<p><strong>字符设备接口</strong></p>\n<p>get/input 系统调用：向字符设备读 / 写一个字符</p>\n<p><strong>块设备接口</strong></p>\n<p>read/write 系统调用：向块设备的读写指针位置读 / 写多个字符；</p>\n<p>seek 系统调用：修改读写指针位置</p>\n<p><strong>网络设备接口</strong></p>\n<p>又称 &quot;网络套字接口&quot;</p>\n<p>socket 系统调用：创建一个网络套接字，需指明网络协议（TCP/UDP）</p>\n<p>bind：将套接字绑定到某个本地 &quot;端口&quot;</p>\n<p>connect：将套接字连接到远程地址</p>\n<p>read/write：从套接字读 / 写数据</p>\n<p><strong>阻塞 I/O，非阻塞 I/O</strong></p>\n<p>阻塞 I/O：应用程序发出 I/O 系统调用，进程需转为阻塞态等待</p>\n<ul>\n<li>如：字符设备接口 —— 从键盘读一个字符 get</li>\n</ul>\n<p>非阻塞 I/O：应用程序发出 I/O 系统调用，系统调用可迅速返回，进程无需阻塞等待</p>\n<ul>\n<li>如：块设备接口 —— 往磁盘中写数据</li>\n</ul>\n<h3 id=\"设备驱动程序接口\"><a class=\"anchor\" href=\"#设备驱动程序接口\">#</a> 设备驱动程序接口</h3>\n<p>不同的操作系统，对设备驱动程序接口的标准各不相同</p>\n<p>操作系统规定好设备驱动程序接口标准，各厂商必须按操作系统的接口要求，开发相应设备驱动程序，设备才能被使用</p>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-5/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-5/",
            "title": "计网408-5",
            "date_published": "2024-08-11T10:34:29.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"运输层概述\"><a class=\"anchor\" href=\"#运输层概述\">#</a> 运输层概述</h3>\n<p>计算机网络结构中的物理层、数据链路层和网络层共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信</p>\n<p>实际上计算机网络中进行通信的是真正实体是位于通信两端主机中的进程</p>\n<p>如何为运行在不同主机上的应用进程提供直接的通信服务是运输层的任务，运输层协议又称为端到端协议</p>\n<p>运输层直接为应用进程间的逻辑通信提供服务</p>\n<p>运输层向高层用户屏蔽了下面网络核心的细节（如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就好像是在两个运输层实体之间有一条端到端的逻辑通信信道</p>\n<p>根据应用需求不同，因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP</p>\n<h3 id=\"运输层端口号-复用与分用\"><a class=\"anchor\" href=\"#运输层端口号-复用与分用\">#</a> 运输层端口号、复用与分用</h3>\n<p><strong>运输层端口号</strong></p>\n<p>运行在计算机上的进程使用进程标识符 PID 来标志</p>\n<p>因特网上的计算机并不是使用统一的操作系统，不同的操作系统又使用不同格式的进程标识符</p>\n<p>为了使运行不同操作系统的计算机的应用进程之间能够进行网络通信，就必须使用统一的方法对 TCP/IP 体系的应用进程进行标识</p>\n<p>TCP/IP 体系的运输层使用端口号来区分应用层的不同应用进程</p>\n<ul>\n<li>端口号使用 16 比特表示，取值范围为 0~65535\n<ul>\n<li>熟知端口号：0~1023，IANA 把这些端口号指派给了 TCP/IP 体系中最重要的一些应用协议，例如：FTP 使用 21/20，HTTP 使用 80，DNS 使用 53</li>\n<li>登记端口号：1024~49151，为没有熟知端口号的应用程序使用，使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复</li>\n<li>短暂端口号：49152~65535，留给用户进程选择暂时使用。当服务器进程收到用户进程的报文件，就知道了客户进程所用的动态端口号，通信结束后，这个端口号可供其他客户进程以后使用</li>\n</ul>\n</li>\n<li>端口号只具有本地意义，即端口号只是为了标识本计算机应用层中各进程，在因特网中，不同计算机的相同端口号是没有联系的</li>\n</ul>\n<p><strong>发送方的复用和接收方的分用</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/hQeuoPGNXaJj82b.png\" alt=\"复用和分用\" /></p>\n<p><strong>TCP/IP 体系的应用层常用协议所使用的运输层熟知端口号</strong></p>\n<p>UDP：</p>\n<ul>\n<li>RIP：520</li>\n<li>DNS：53</li>\n<li>TFTP：69</li>\n<li>SNMP：161</li>\n<li>DHCP：67/68</li>\n</ul>\n<p>TCP：</p>\n<ul>\n<li>SMTP：25</li>\n<li>FTP：21/20</li>\n<li>BGP：179</li>\n<li>HTTP：80</li>\n<li>HTTPS：443</li>\n</ul>\n<h3 id=\"udp和tcp对比\"><a class=\"anchor\" href=\"#udp和tcp对比\">#</a> UDP 和 TCP 对比</h3>\n<p>UDP 和 TCP 是 TCP/IP 体系结构运输层中两个重要协议</p>\n<ul>\n<li>\n<p>用户数据报协议 UDP</p>\n<ul>\n<li>\n<p>UDP 是无连接的</p>\n</li>\n<li>\n<p>UDP 支持单播、多播以及广播（即支持一对一，一对多，多对一和多对多交互通信）</p>\n</li>\n<li>\n<p>UDP 是面向应用报文的</p>\n</li>\n<li>\n<p>UDP 向上层提供无连接不可靠传输服务（适用于 IP 电话、视频会议等实时应用）</p>\n</li>\n<li>\n<p>UDP 用户数据报首部仅 8 字节</p>\n</li>\n</ul>\n</li>\n<li>\n<p>传输控制协议 TCP</p>\n<ul>\n<li>TCP 是面向连接的</li>\n<li>TCP 仅支持单播（即每一条 TCP 连接只能有两个端点 EP，只能是一对一通信）</li>\n<li>TCP 是面向字节流的</li>\n<li>TCP 向上层提供面向连接可靠传输服务（适用于要求可靠传输的应用，例如文件传输）</li>\n<li>TCP 用户数据报首部最小 20 字节，最大 60 字节</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"tcp的流量控制\"><a class=\"anchor\" href=\"#tcp的流量控制\">#</a> TCP 的流量控制</h3>\n<p>一般来说，我们总是希望数据传输得更快一些</p>\n<ul>\n<li>但如果发送方把数据发送得过快，接收方就可能来不及接收，这就会造成数据的丢失</li>\n</ul>\n<p>所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收</p>\n<p>利用滑动窗口机制可以很方便地在 TCP 连接上实现对发送方的流量控制</p>\n<ul>\n<li>TCP 接收方利用自己的接收窗口的大小来限制发送窗口的大小</li>\n<li>TCP 发送方收到接收方的零窗口通知后，应启动持续计时器。持续计时器超时后，向接收方发送零窗口探测报文</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、主机甲和主机乙之间建立了一个 TCP 连接，TCP 最大段长度为 1000 字节。若主机甲的当前拥塞窗口为 4000 字节，在主机甲向主机乙连续发送两个最大段后，成功收到主机乙发送的第一个段的确认段，确认段中通告的接收窗口大小为 2000 字节，则此时主机甲还可以向主机乙发送的最大字节数是（A）</p>\n<p>A.1000       B.2000       C.3000        D.4000</p>\n<p>解析：主机甲发送两个最大段后，收到第一个段的确认段，此时窗口大小仍为 4000，因此窗口前移一个段，删除第一个段的缓存，然后通告接收窗口大小为 2000 字节，因此，主机甲调整拥塞窗口为 2000 字节，此时发送的第二个段的确认还没有收到，因此，还可以向主机乙发送的最大字节数为 1000 字节，选 A</p>\n<h3 id=\"tcp的拥塞控制\"><a class=\"anchor\" href=\"#tcp的拥塞控制\">#</a> TCP 的拥塞控制</h3>\n<p>若某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏。这种情况就叫做拥塞</p>\n<ul>\n<li>在计算机网络的链路容量（即带宽），交换节点的缓存和处理机等，都是网络的资源</li>\n</ul>\n<p>若出现拥塞而不进行控制，整个网络的吞吐量将随输入负荷的增大而下降</p>\n<p>假定有如下条件：</p>\n<ul>\n<li>数据是单方向传送，而另一个方向只传送确认</li>\n<li>接收方向总是有足够大的缓存空间，因而发送方发送窗口的大小由网络的拥塞程度来决定</li>\n<li>以最大报文段 MSS 的个数为讨论问题的单位，而不是以字节为单位</li>\n</ul>\n<p>发送方维护一个拥塞窗口 cwnd 的状态变量，其值取决于网络的拥塞程度，并且动态变化</p>\n<ul>\n<li>拥塞窗口 cwnd 的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些；但只要出现拥塞，拥塞窗口就减小一些</li>\n<li>判断出现网络拥塞的依据：没有按时收到应当到达的确认报文（即发生超时重传）。</li>\n</ul>\n<p>发送方将拥塞窗口作为发送窗口 swnd，即 swnd=cwnd</p>\n<p>发送方维护一个慢开始 ssthresh 状态变量：</p>\n<ul>\n<li>当 cwnd&lt;ssthresh 时，使用慢开始算法</li>\n<li>当 cwnd&gt;ssthresh 时，停止使用慢开始算法而改用拥塞避免算法</li>\n<li>当 cwnd=ssthresh 时，既可以使用慢开始算法也可以使用拥塞避免算法</li>\n</ul>\n<p><strong>慢开始</strong></p>\n<p>设置初始拥塞窗口值 cwnd 和慢开始门限值 ssthresh，每个传输轮次结束后，拥塞窗口值按指数增大，当拥塞窗口值到达慢开始门限值时，停止慢开始算法，启用拥塞避免算法。</p>\n<p>慢开始是指在一开始向网络注入的报文段少，而不是拥塞窗口 cwnd 增长速度慢</p>\n<p><strong>拥塞避免</strong></p>\n<p>每个传输轮次结束后，拥塞窗口值只能线性加 1。</p>\n<p>当重传计时器超时，判断网络很可能出现了拥塞，进行一下工作：</p>\n<ul>\n<li>将 ssthresh 值更新为发生拥塞时 cwnd 值的一半</li>\n<li>将 cwnd 值减少为 1，并重新开始慢开始算法</li>\n</ul>\n<p>拥塞避免并非指完全能够避免拥塞，而是指在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞</p>\n<p><strong>快重传</strong></p>\n<p>有时，个别报文段会在网络中丢失，但实际网络并未发生拥塞</p>\n<ul>\n<li>这将导致发送方超时重传，并误认为网络发生了拥塞</li>\n<li>发送方拥塞窗口 cwnd 又设置为最小值 1，并错误地启动慢开始算法，因而降低了传输效率</li>\n</ul>\n<p>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失</p>\n<p>所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传</p>\n<ul>\n<li>要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认</li>\n<li>即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认</li>\n<li>发送方一旦收到了 3 个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传</li>\n<li>对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口 cwnd 为 1）。使用快重传可以使用整个网络的吞吐量提高越 20%</li>\n</ul>\n<p><strong>快恢复</strong></p>\n<p>发送方一旦收到 3 个重复确认，就知道现在只丢失了个别的报文段，于是不启动慢开始算法，而执行快恢复算法</p>\n<ul>\n<li>发送方将慢开始门限 ssthresh 值和拥塞窗口 cwnd 值调整为当前窗口的一半；开始执行拥塞避免算法</li>\n<li>也有的快恢复实现是把快恢复开始时的拥塞窗口 cwnd 值再增大一些，即等于新的 ssthresh+3\n<ul>\n<li>既然发送方收到 3 个重复的确认，就表明由 3 个数据报文段已经离开了网络</li>\n<li>这 3 个报文段不再消耗网络资源而是停留子在接收方的接收缓存中</li>\n<li>可见现在网络中不是堆积了报文段而是减少了 3 个报文段。因此可以适当把拥塞窗口扩大些</li>\n</ul>\n</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、一个 TCP 连接总是以 1KB 的最大段发送 TCP 段，发送方有足够多的数据要发送。当拥塞窗口为 16KB 时发生了超时，如果接下来 4 个 RTT（往返时间）内的 TCP 段的传输都是成功的，那么当第 4 个 RTT 的时间内发送的所有 TCP 段都得到了肯定应答时，拥塞窗口大小是（C）</p>\n<p>A.7KB     B.8KB       C.9KB        D.16KB</p>\n<p>解析：当拥塞窗口为 16KB 时发生了超时，则拥塞窗口值改为 1，慢开始门限变为当前拥塞窗口值的一半，即 8KB，再过了 4 个往返时间后，拥塞窗口值变为了 8KB，此时由于所有 TCP 段都得到了肯定应答，因此采用拥塞避免算法，拥塞窗口线性增大 1，因此拥塞窗口大小为 9KB</p>\n<h3 id=\"tcp超时重传时间的选择\"><a class=\"anchor\" href=\"#tcp超时重传时间的选择\">#</a> TCP 超时重传时间的选择</h3>\n<p>超时重传时间的选择是 TCP 最复杂的问题之一</p>\n<ul>\n<li>超时重传时间 RTO 的值应略大于往返时间 RTT 的值</li>\n</ul>\n<p>不能直接使用某次测量得到的 RTT 样本来计算超时重传时间 RTO</p>\n<p>利用每次测量的 RTT 样本，计算加权平均往返时间 RTTs（又称为平滑的往返时间）</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>R</mi><mi>T</mi><msub><mi>T</mi><mrow><mi>S</mi><mn>1</mn></mrow></msub><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mn>1</mn></msub><mspace linebreak=\"newline\"></mspace><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mi>e</mi><mi>w</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>S</mi></msub><mo stretchy=\"false\">(</mo><mi>o</mi><mi>l</mi><mi>d</mi><mo stretchy=\"false\">)</mo><mo>×</mo><mo stretchy=\"false\">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy=\"false\">)</mo><mo>+</mo><mi>α</mi><mo>×</mo><mi>R</mi><mi>T</mi><msub><mi>T</mi><mi>n</mi></msub><mo stretchy=\"false\">(</mo><mi>n</mi><mi>e</mi><mi>w</mi><mtext> </mtext><mi>s</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mo stretchy=\"false\">)</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>≤</mo><mi>α</mi><mo>≤</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">RTT_{S1}=RTT_1\\\\RTT_{S}(new)=RTT_{S}(old)\\times(1-\\alpha)+\\alpha\\times RTT_n(new\\ sample)(0\\le\\alpha\\le1)\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span><span class=\"mord mtight\">1</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">d</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.66666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.151392em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.02691em;\">w</span><span class=\"mspace\"> </span><span class=\"mord mathnormal\">s</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mclose\">)</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.7719400000000001em;vertical-align:-0.13597em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.0037em;\">α</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span></p>\n<p>若 α 很接近于 0，则新的 RTT 样本对 RTTs 的影响不大</p>\n<p>若 α 很接近于 1，则新的 RTT 样本对 RTTs 的影响较大</p>\n<p>已成为建议标准的 RFC6298 推荐的 α 值为 0.125</p>\n<p>用这种方法得出的加权平均往返时间 RTTs 就比测量出的 RTT 的值更加平滑</p>\n<p>显然，超时重传时间 RTO 应略大于加权平均往返时间 RTTs</p>\n<p>RFC6298 建议使用下式计算超时重传时间 RTO：</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/LWuoXCeRw4q9gxm.png\" alt=\"超时重传时间\" /></p>\n<p><strong>往返时间 RTT 的测量</strong></p>\n<ul>\n<li>\n<p>源主机若误将确认当作是对原报文段的确认</p>\n<ul>\n<li>所计算出的 RTTs 和 RTO 就会偏大，降低了传输效率</li>\n</ul>\n</li>\n<li>\n<p>源主机若误将确认当作是对重传报文段的确认：</p>\n<ul>\n<li>所计算出的 RTTs 和 RTO 就会偏小，导致报文段没必要的重传，增大网络符合</li>\n</ul>\n</li>\n</ul>\n<p>针对出现超时重传时无法测准往返时间 RTT 的问题，Karn 提出一个算法：</p>\n<ul>\n<li>在计算加权平均往返时间 RTTs 时，只要报文段重传了，就不采用其往返时间 RTT 样本。也就是出现重传时，不重新计算 RTTs，进而超时重传时间 RTO 也不会重新计算\n<ul>\n<li>这又引起了新的问题。报文段的时延突然增大了很多，并且之后很长一段时间都会保持这种时延。因此在原来得出的重传时间内，不会收到确认报文段。于是就重传报文段。但根据 Karn 算法，不考虑重传的报文段的往返时间样本。这样，超时重传时间就无法更新。这会导致报文段反复被重传</li>\n</ul>\n</li>\n<li>因此，要对 Karn 算法进行修正。方法是：报文段每重传一次，就把超时重传时间 RTO 增大一些。典型的做法是将新 RTO 值取为旧 RTO 值的 2 倍</li>\n</ul>\n<h3 id=\"tcp可靠传输的实现\"><a class=\"anchor\" href=\"#tcp可靠传输的实现\">#</a> TCP 可靠传输的实现</h3>\n<p>TCP 基于以字节为单位的滑动窗口来实现可靠传输</p>\n<p>发送窗口后沿的移动情况有两种可能：</p>\n<ul>\n<li>不动（没有收到新的确认）</li>\n<li>前移（收到了新的确认）</li>\n</ul>\n<p>发送窗口前沿的移动情况有三种可能：</p>\n<ul>\n<li>通常是不断向前移动</li>\n<li>不动\n<ul>\n<li>没有收到新的确认，对方通知的窗口大小也不变</li>\n<li>收到了新的确认但对方通知的窗口缩小，使发送窗口前沿正好不动</li>\n</ul>\n</li>\n<li>后移（对方通知的窗口缩小了）（TCP 标准不建议这样做）</li>\n</ul>\n<p>如何描述发送窗口的状态：</p>\n<ul>\n<li>使用三个指针 P1，P2，P3 分别指向相应的字节序号\n<ul>\n<li>小于 P1 的是已发送并已收到确认的部分</li>\n<li>大于等于 P3 的是不允许发送的部分</li>\n<li>P3-P1 = 发送窗口的尺寸</li>\n<li>P2-P1 = 已发送但尚未收到确认的字节数</li>\n<li>P3-P2 = 允许发送但当前尚未发送的字节数（又称为可用窗口或有效窗口）</li>\n</ul>\n</li>\n</ul>\n<p>虽然发送方的发送窗口是根据接收方的接收窗口设置的，但在同一时刻，发送方的发送窗口并不总是和接收方的接受窗口一样大</p>\n<ul>\n<li>网络传送窗口值需要经历一定的时间滞后，并且这个时间还是不确定的</li>\n<li>发送方还可能根据网络当时的拥塞情况适当减小自己的发送窗口尺寸</li>\n</ul>\n<p>对于不按序到达的数据应如何处理，TCP 并无明确规定</p>\n<ul>\n<li>如果接收方把不按序到达的数据一律丢弃，那么接收端口的管理将会比较简单，但这样做对网络资源的利用不利，因为发送方会重复传送较多的数据</li>\n<li>TCP 通常对不按序到达的数据是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li>\n</ul>\n<p>TCP 要求接收方必须有累积确认和捎带确认机制，这样可以减小传输开销。接收方可以在合适的事后发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</p>\n<ul>\n<li>接受方不应过分推迟发送确认，否则会导致发送方不必要的超时重传，这反而浪费了网络的资源。TCP 标准规定，确认推迟的时间不应超过 0.5 秒。若收到一连串具有最大长度的报文段，则必须要每隔一个报文段就发送一个确认 [RFC 1122]</li>\n<li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据</li>\n</ul>\n<p>TCP 的通信是全双工通信。通信中每一方都在发送和接收报文段。因此，每一方都有自己的发送窗口和接受窗口。在谈到这些窗口时，一定要弄清楚是哪一方的窗口</p>\n<p><strong>习题</strong></p>\n<p>1、主机甲与主机乙之间已建立一个 TCP 连接，主机甲向主机乙发送了两个连续的 TCP 段，分别包含 300 字节和 500 字节的有效载荷，第一个段的序号为 200，主机乙正确接收到两个段后，发送给主机甲的确认序号是（D）</p>\n<p>A.500    B.700      C.800    D.1000</p>\n<p>解析：第一个段的序号为 200，第一个段包含 300 字节有效载荷，则第一个段最后一个字节的序号为 499，而两个 TCP 段是连续的，则第二个段的序号开头为 500，结尾为 999，因此主机乙收到之后，表明下一个需要的序号为 1000，将 1000 这个确认序号发送给主机甲，表明 1000 序号前的段正确接收，下一个期望接收的序号段是 1000</p>\n<p>2、主机甲与主机乙之间已建立一个 TCP 连接，主机甲向主机乙发送了 3 个连续的 TCP 段，分别包含 300 字节，400 字节和 500 字节的有效载荷，第三个段的序号为 900，若主机乙仅正确接收了第 1 个段和第 3 个段，则主机乙发送给主机甲的确认序号是（B）</p>\n<p>A.300     B.500      C.1200      D.1400</p>\n<p>解析：主机乙仅正确接收第一个段和第三个段，因此需要发送第二个段的确认序号，表明第二个段缺失，需要重新传送，第三个段的序号为 900，第 2 个段包含 400 字节，因此，第二个段的序号为 500，因此选 B</p>\n<h3 id=\"tcp的运输连接管理\"><a class=\"anchor\" href=\"#tcp的运输连接管理\">#</a> TCP 的运输连接管理</h3>\n<p>TCP 是面向连接的协议，它基于运输连接来传送 TCP 报文段</p>\n<p>TCP 运输连接的建立和释放是每一次面向连接的通信中必不可少的过程</p>\n<p>TCP 运输连接的建立有以下三个阶段：</p>\n<ul>\n<li>建立 TCP 连接</li>\n<li>数据传送</li>\n<li>释放 TCP 连接</li>\n</ul>\n<p>TCP 的运输连接管理就是使运输连接的建立和释放都能正常地进行</p>\n<h4 id=\"tcp的连接建立\"><a class=\"anchor\" href=\"#tcp的连接建立\">#</a> TCP 的连接建立</h4>\n<p>TCP 的连接建立需要解决以下三个问题：</p>\n<ul>\n<li>使 TCP 双方能够确知对方的存在</li>\n<li>使 TCP 双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）</li>\n<li>使 TCP 双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配</li>\n</ul>\n<p><strong>TCP 使用三报文握手建立连接</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/3ueFd5YWQNTvUVz.png\" alt=\"三次握手\" /></p>\n<p>第三次握手是否多余：</p>\n<ul>\n<li>不多余，为了防止已失效的连接请求报文段突然又传送到了 TCP 服务器，因而导致错误</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>主机甲向主机乙发送一个（SYN=1，seq=11220）的 TCP 段，期望与主机乙建立 TCP 连接，若主机乙接受该连接请求，则主机乙向主机甲发送的正确的 TCP 段可能是（C）</p>\n<p>A.(SYN=0,ACK=0,seq=11221,ack=11221)        B.(SYN=1,ACK=1,seq=11220,ack=11220)</p>\n<p>C.(SYN=1,ACK=1,seq=11221,ack=11221)        D.(SYN=0,ACK=0,seq=11220,ack=11220)</p>\n<p>解析：主机乙向主机甲发送的是针对 TCP 连接请求的确认报文，此时同步位 SYN 和确认位 ACK 都为 1，表明这是一个 TCP 连接请求确认报文，确认号字段 ack 的值是对主机甲中 TCP 客户进程所选择的初始序号 11220 的确认，因此 ack 字段为 11221，序号部分 seq 的值是主机乙中 TCP 服务器进程所选择的初始序号，可由 TCP 服务器进程随意指定，与其他报文的值无关</p>\n<h4 id=\"tcp的连接释放\"><a class=\"anchor\" href=\"#tcp的连接释放\">#</a> TCP 的连接释放</h4>\n<p>TCP 通过四报文挥手来释放连接</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/SQs1HP74EkBw5qL.png\" alt=\"TCP连接释放\" /></p>\n<p>最后等待的 2MSL 是为了保证 TCP 服务器进程可以收到最后一个 TCP 确认报文而进入关闭状态。</p>\n<p>TCP 服务器进程每收到一次 TCP 客户进程的数据，就重新设置并启动保活计时器（2 小时定时）</p>\n<p>若保活计时器定时周期内未收到 TCP 客户进程发来的数据，则当保活计时器到时候后，TCP 服务器进程就向 TCP 客户进程发送一个探测报文段，以后则每隔 75 秒钟发送一次，若一连发送 10 个探测报文段后仍无 TCP 客户进程的响应，TCP 服务器进程就认为 TCP 客户进程所在主机出了故障，接着就关闭了这个连接</p>\n<h3 id=\"tcp报文段的首部格式\"><a class=\"anchor\" href=\"#tcp报文段的首部格式\">#</a> TCP 报文段的首部格式</h3>\n<p>为了实现可靠传输，TCP 采用了面向字节流的方式</p>\n<p>但 TCP 在发送数据时，是从发送缓存取出一部分或全部字节并给其添加一个首部使之成为 TCP 报文段后进行发送</p>\n<ul>\n<li>一个 TCP 报文段由首部和数据载荷两部分构成</li>\n<li>TCP 的全部功能都体现在它首部中各字段的作用</li>\n</ul>\n<p><img data-src=\"https://s2.loli.net/2024/08/13/akm1UbXQNfeMvHV.png\" alt=\"TCP报文首部格式\" /></p>\n<p>固定首部</p>\n<ul>\n<li>\n<p>源端口：占 16 比特，写入源端口号，用来标识发送该 TCP 报文段的应用进程</p>\n</li>\n<li>\n<p>目的端口：占 16 比特，写入目的端口号，用来标识接收该 TCP 报文段的应用进程</p>\n</li>\n<li>\n<p>序号：占 32 比特，取值范围为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,2^{32}-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，序号增加到最后一个后，下一个序号就又回到 0</p>\n<ul>\n<li>指出本 TCP 报文段数据载荷的第一个字节的序号</li>\n</ul>\n</li>\n<li>\n<p>确认号：占 32 比特，取值范围为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>0</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mn>32</mn></msup><mo>−</mo><mn>1</mn><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[0,2^{32}-1]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">]</span></span></span></span>，序号增加到最后一个后，下一个序号就又回到 0</p>\n<ul>\n<li>指出期望收到对方下一个 TCP 报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认</li>\n<li>若确认号 = n，则表明到序号 n-1 为止的所有数据都已正确接收，期望接收序号为 n 的数据</li>\n</ul>\n</li>\n<li>\n<p>确认标志位 ACK：取值为 1 时确认号字段才有效；取值为 0 时确认号字段无效</p>\n<ul>\n<li>TCP 规定，在连接建立后所有传送的 TCP 报文段都必须把 ACK 置 1</li>\n</ul>\n</li>\n<li>\n<p>数据偏移：占 4 比特，并以 4 字节为单位</p>\n<ul>\n<li>用来指出 TCP 报文段的数据载荷部分的起始处距离 TCP 报文段的起始处有多远</li>\n<li>这个字段实际上是指出了 TCP 报文段的首部长度\n<ul>\n<li>首部固定长度为 20 字节，因此数据偏移字段的最小值为 (0101)</li>\n<li>首部最大长度为 60 字节，因此数据偏移字段的最大值为 (1111)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>保留：占 6 比特，保留为今后使用，但目前应置为 0</p>\n</li>\n<li>\n<p>窗口：占 16 比特，以字节为单位，指出发送本报文段的一方的接收窗口</p>\n<ul>\n<li>窗口值作为接收方让发送方设置其发送窗口的依据</li>\n<li>这是以接收方的接受能力来控制发送方的发送能力，称为流量控制</li>\n</ul>\n</li>\n<li>\n<p>校验和：占 16 比特，检查范围包括 TCP 报文段的首部和数据载荷两部分</p>\n<ul>\n<li>在计算校验和时，要在 TCP 报文段的前面加上 12 字节的伪首部</li>\n</ul>\n</li>\n<li>\n<p>同步标志位 SYN：在 TCP 连接建立时用来同步序号。</p>\n</li>\n<li>\n<p>终止标志位 FIN：用来释放 TCP 连接</p>\n</li>\n<li>\n<p>复位标志位 RST：用来复位 TCP 连接</p>\n<ul>\n<li>当 RST=1 时，表明 TCP 连接出现了异常，必须释放连接，然后再重新建立连接</li>\n<li>RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个 TCP 连接</li>\n</ul>\n</li>\n<li>\n<p>推送标志位 PSH：接收方收到该标志位为 1 的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付</p>\n</li>\n<li>\n<p>紧急标志位 URG：取值为 1 时紧急指针字段有效；取值为 0 时紧急指针字段无效</p>\n</li>\n<li>\n<p>紧急指针：占 16 比特，以字节为单位，用来指明紧急数据的长度</p>\n<ul>\n<li>当发送方有紧急数据时，可将紧急数据插队到发送缓存的最前面，并立刻封装到一个 TCP 报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，紧急数据之后是普通数据</li>\n</ul>\n</li>\n</ul>\n<p>扩展首部：</p>\n<ul>\n<li>最大报文段长度 MSS 选项：TCP 报文段数据载荷部分的最大长度</li>\n<li>窗口扩大选项：为了扩大窗口（提高吞吐率）</li>\n<li>时间戳选项：\n<ul>\n<li>用来计算往返时间 RTT</li>\n<li>用来处理序号超范围的情况，又称为防止序号绕回 PAWS</li>\n</ul>\n</li>\n<li>选择确认选项：用来实现选择确认功能</li>\n<li>填充：由于选项的长度可变，因此使用填充来确保报文段首部能被 4 整除（因为数据偏移字段，也就是首部长度字段，是以 4 字节为单位的）</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-4-3/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-4-3/",
            "title": "操作系统408-4-3",
            "date_published": "2024-08-09T14:00:01.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"文件系统的层次结构\"><a class=\"anchor\" href=\"#文件系统的层次结构\">#</a> 文件系统的层次结构</h3>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/hyxkem5iW7qfXa8.png\" alt=\"文件系统层次结构\" /></p>\n<p>用户需要通过操作系统提供的接口发出请求 —— 用户接口</p>\n<p>由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项 —— 文件目录系统</p>\n<p>不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限 —— 存取控制模块（存取控制验证层）</p>\n<p>验证了用户的访问权限之后，需要把用户提供的 &quot;记录号&quot; 转变为对应的逻辑地址 —— 逻辑文件系统与文件信息缓冲区</p>\n<p>知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址 —— 物理文件系统</p>\n<p>要删除这条记录，必定要对磁盘设备发出请求 —— 设备管理程序模块</p>\n<p>删除这些记录后，会有一些盘块空闲，因此要将这些空间盘块回收 —— 辅助分配模块</p>\n<h3 id=\"文件系统的全局结构布局\"><a class=\"anchor\" href=\"#文件系统的全局结构布局\">#</a> 文件系统的全局结构（布局）</h3>\n<p>原始磁盘 -&gt; 物理格式化：</p>\n<ul>\n<li>低级格式化 —— 划分扇区，检测坏扇区，并用备用扇区替换坏扇区</li>\n</ul>\n<p>物理格式化 -&gt; 逻辑格式化：</p>\n<ul>\n<li>磁盘分区（分卷），完成各分区的文件系统初始化</li>\n<li>注：逻辑格式化后，主引导记录（MBR）（包含了磁盘引导程序和分区表）就已经在磁盘里了</li>\n</ul>\n<h3 id=\"虚拟文件系统\"><a class=\"anchor\" href=\"#虚拟文件系统\">#</a> 虚拟文件系统</h3>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/iUJ5jbTkGWOZhEo.png\" alt=\"虚拟文件系统\" /></p>\n<p>虚拟文件系统的特点：</p>\n<ul>\n<li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异</li>\n<li>VFS 要求下层的文件系统必须实现某些规定的函数功能，如：open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统 VFS 的要求</li>\n<li>每打开一个文件，VFS 就在主存中新建一个 vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统</li>\n</ul>\n<p>存在的问题：</p>\n<p>不同的文件系统，表示文件数据结构各不相同。打开文件后，其在内存的表示就不同</p>\n<h3 id=\"文件系统的挂载\"><a class=\"anchor\" href=\"#文件系统的挂载\">#</a> 文件系统的挂载</h3>\n<p>文件系统挂载，即文件系统安装 / 装载 —— 如何将一个文件系统挂载到操作系统中</p>\n<p>文件系统过载要做的事：</p>\n<ul>\n<li>在 VFS 中注册新挂载的文件系统。内存中的挂载表包含每个文件系统相关信息，包括文件系统类型、容量大小等</li>\n<li>新挂载的文件系统，要向 VFS 提供一个函数地址列表</li>\n<li>将新文件系统加到挂载点，也就是将新文件系统挂载在某个父目录下</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-4-2/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-4-2/",
            "title": "计网408-4-2",
            "date_published": "2024-08-09T06:53:09.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"路由选择协议概述\"><a class=\"anchor\" href=\"#路由选择协议概述\">#</a> 路由选择协议概述</h3>\n<h4 id=\"静态路由选择\"><a class=\"anchor\" href=\"#静态路由选择\">#</a> 静态路由选择</h4>\n<ul>\n<li>由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由</li>\n<li>这种人工配置方式简单、开销小。但不能及时适应网络（流量、拓扑等）的变化</li>\n<li>一般只在小规模网络中采用</li>\n</ul>\n<h4 id=\"动态路由选择\"><a class=\"anchor\" href=\"#动态路由选择\">#</a> 动态路由选择</h4>\n<ul>\n<li>\n<p>路由器通过路由选择协议自动获取路由信息</p>\n</li>\n<li>\n<p>比较复杂、开销比较大。能较好地适应网络状态的变化</p>\n</li>\n<li>\n<p>适用于大规模网络</p>\n</li>\n</ul>\n<p><strong>因特网所采用的路由选择协议的主要特点</strong></p>\n<p>适应性：动态路由选择，能较好地适应网络状态的变化</p>\n<p>分布式：路由器之间交换路由信息</p>\n<p>分层次：将整个因特网划分为许多较小的自治系统 AS</p>\n<p><strong>因特网采用分层次的路由选择协议</strong></p>\n<p>自治系统 AS 直接通过路由器相连，使用外部网关协议 FGP</p>\n<p>自治系统 AS 内部使用内部网关协议 IGP，不同的自治系统 AS 可使用不同的内部网关协议</p>\n<p><strong>常见的路由选择协议</strong></p>\n<ul>\n<li>内部网关协议 IGP\n<ul>\n<li>路由信息协议 RIP\n<ul>\n<li>基于距离向量</li>\n<li>RIP 在因特网上最早使用</li>\n</ul>\n</li>\n<li>内部网关路由协议 IGRP\n<ul>\n<li>基于距离向量</li>\n<li>IGRP 是思科早期私有的协议，现在已被 EIGRP 取代</li>\n</ul>\n</li>\n<li>增强型内部网关路由协议 EIGRP\n<ul>\n<li>思科私有的，用来取代 IGRP 的混合型路由协议（结合距离向量和链路状态）</li>\n</ul>\n</li>\n<li>开放式最短路径优先 OSPF\n<ul>\n<li>基于链路状态的</li>\n<li>OSPF 在各种网络中广泛使用</li>\n</ul>\n</li>\n<li>中间系统到中间系统 IS-IS\n<ul>\n<li>局域链路状态的</li>\n<li>集成化的 IS-IS 是 ISP 骨干网上最常使用的 IGP 协议</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>外部网关协议 FGP\n<ul>\n<li>边界网关协议 BGP</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"路由器的基本结构\"><a class=\"anchor\" href=\"#路由器的基本结构\">#</a> 路由器的基本结构</h4>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/t8wZhbPqaFjr3lT.png\" alt=\"路由器基本结构\" /></p>\n<ul>\n<li>\n<p>路由表一般仅包含从目的网络到下一跳的映射</p>\n</li>\n<li>\n<p>路由表需要对网络拓扑变化的计算最优化</p>\n</li>\n<li>\n<p>转发表是从路由表得出的</p>\n</li>\n<li>\n<p>转发表的结构应当使查找过程最优化</p>\n</li>\n<li>\n<p>路由器的各端口还应该具有输入缓冲区和输出缓冲区</p>\n<ul>\n<li>端口一般都具有输入和输出的功能</li>\n<li>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</li>\n<li>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"路由协议rip的工作原理\"><a class=\"anchor\" href=\"#路由协议rip的工作原理\">#</a> 路由协议 RIP 的工作原理</h3>\n<p>路由信息协议 RIP 是内部网关协议 IGP 中最先得到广泛使用的协议之一，其相关标准文档为 RFC 1058</p>\n<p>RIP 要求自治系统 AS 内的每一个路由器都要维护从它自己到 AS 内其他每一个网络的距离记录。这是一组距离，称为 &quot;距离向量 D-V&quot;</p>\n<p>RIP 使用跳数作为度量来衡量到达目的网络的距离</p>\n<ul>\n<li>路由器到直连网络的距离定义为 1</li>\n<li>路由器到非直连网络的距离定义为所经过的路由器数加 1</li>\n<li>允许一条路径最多只能包含 15 个路由器。&quot;距离&quot; 等于 16 时相当于不可达。因此 RIP 只适用于小型互联网</li>\n</ul>\n<p>RIP 认为好的路由就是 &quot;距离短&quot; 的路由，也就是所通过路由器数量最少得路由</p>\n<p>当到达同一目的网络有多条 &quot;距离相等&quot; 的路由时，可以进行等价负载均衡</p>\n<p>RIP 包含以下三个要点：</p>\n<ul>\n<li>和谁交换信息：仅和相邻路由器交换信息</li>\n<li>交换什么信息：自己的路由表</li>\n<li>何时交换信息：周期性交换（例如每 30 秒）</li>\n</ul>\n<p><strong>RIP 的基本工作过程</strong></p>\n<ul>\n<li>路由器刚开始工作时，只知道自己到直接网络的距离为 1</li>\n<li>每个路由器仅和相邻路由器周期性地交换并更新路由信息</li>\n<li>若干次交换和更新后，每个路由器都知道到达本 AS 内各网络的最短距离和下一跳地址，称为收敛</li>\n</ul>\n<p><strong>RIP 的路由条目的更新规则</strong></p>\n<p>到达目的网络，相同下一跳，最新消息，更新</p>\n<p>发现了新的网络，添加</p>\n<p>到达目的网络，不同下一跳，新路由优势，更新</p>\n<p>到达目的网络，不同下一跳，等价负载均衡，更新</p>\n<p>到达目的网络，不同下一跳，新路由劣势，不更新</p>\n<p><strong>坏消息传播得慢问题</strong></p>\n<p>RIP 存在 &quot;坏消息传播得慢&quot; 的问题</p>\n<p>&quot;坏消息传播得慢&quot; 又称为路由环路问题或距离无穷计数问题，这是距离向量算法的一个固有问题。可以采取多种措施减少出现该问题的概率或减小该问题带来的危害</p>\n<ul>\n<li>限制最大路径距离为 15（16 表示不可达）</li>\n<li>当路由表发生变化时就立即发送更新报文（即 &quot;触发更新&quot;），而不仅是周期性发送</li>\n<li>让路由器记录收到某特定路由信息的接口，而不让同一路由信息再通过此接口向反方向传送（即 &quot;水平分割&quot;）</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、某自治系统内采用 RIP 协议，若该自治系统内的路由器 R1 收到其邻居路由器 R2 的距离矢量，距离矢量中包含信息 &lt;net1,16&gt;，则能得出的结论是（D）</p>\n<p>A.R2 可以经过 R1 到达 net1，跳数为 17</p>\n<p>B.R2 可以到达 net1，跳数为 16</p>\n<p>C.R2 可以经过 R2 到达 net1，跳数为 17</p>\n<p>D.R1 不能经过 R2 到达 net1</p>\n<p>解析：在 RIP 协议中，距离 16 表明目的网络不可达。因此 R2 无法到达 net1，R1 也无法通过 R2 到达 net1</p>\n<p>2、</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/VuaBkvMjK1QZWro.png\" alt=\"习题\" /></p>\n<p>解析：答案选 B，由 R3 检测网络 201.1.2.0/25 可知，R3 与该网络是直连的，向 R2 通告后，R2 到 201.1.2.0/25 修改为 16。但 R2 更新后，R1 会向 R2 发送更新报文，因此 R2 会由 R1 的信息 &quot;通过 R3 到 201.1.2.0/25 的距离为 2&quot;，因此 R2 就会更新成 &quot;通过 R1 到 201.1.2.0/25 的距离为 3&quot;</p>\n<h3 id=\"开放最短路径优先ospf的基本工作原理\"><a class=\"anchor\" href=\"#开放最短路径优先ospf的基本工作原理\">#</a> 开放最短路径优先 OSPF 的基本工作原理</h3>\n<p>开放最短路径优先 OSPF 是为克服 RIP 的缺点在 1989 年开发出来的</p>\n<ul>\n<li>&quot;开放&quot; 表明 OSPF 协议不是受某一家厂商控制，而是公开发表的</li>\n<li>&quot;最短路径优先&quot; 是因为使用了迪杰斯特拉提出的最短路径算法 SPF</li>\n</ul>\n<p>OSPF 是基于链路状态的，而不像 RIP 那样是基于距离向量的</p>\n<p>OSPF 采用 SPF 算法计算路由，从算法上保证了不会产生路由环路</p>\n<p>OSPF 不限制网络规模，更新效率高，收敛速度快</p>\n<p>链路状态是指本路由器在和哪些路由器相邻，以及相应链路的 &quot;代价&quot;</p>\n<ul>\n<li>&quot;代价&quot; 用来表示费用、距离、时延、带宽等等，这些都由网络管理人员来决定</li>\n</ul>\n<p>OSPF 相邻路由之间通过交互问候（Hello）分组，建立和维护邻居关系</p>\n<ul>\n<li>Hello 分组封装在 IP 数据报中，发往组播地址 224.0.0.5</li>\n<li>发送周期为 10 秒</li>\n<li>40 秒未收到来自邻居路由器的 Hello 分组，则认为该邻居路由器不可达</li>\n</ul>\n<p>使用 OSPF 的每个路由器都会产生链路状态通告 LSA，LSA 包含以下内容：</p>\n<ul>\n<li>直连网络的链路状态信息</li>\n<li>邻居路由器的链路状态信息</li>\n</ul>\n<p>LSA 被封装在链路状态更新分组 LSU 中，采用洪泛法发送</p>\n<p>使用 OSPF 的每个路由器都有一个链路状态数据库 LSDB，用于存储 LSA</p>\n<p>通过各路由器洪范发送封装有自己 LSA 的 LSU 分组，各路由器的 LSDB 最终将达到一致</p>\n<p>使用 OSPF 的各路由器基于 LSDB 进行最短路径优先 SPF 计算，构建出各自到达其他各路由器的最短路径，即构建各自的路由表</p>\n<p><strong>OSPF 分组类型</strong></p>\n<p>OSPF 有以下五种分组类型：</p>\n<ul>\n<li>类型 1：问候分组\n<ul>\n<li>用来发现和维护邻居路由器的可达性</li>\n</ul>\n</li>\n<li>类型 2：数据库描述分组\n<ul>\n<li>向邻居路由器给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li>\n</ul>\n</li>\n<li>类型 3：链路状态请求分组\n<ul>\n<li>向邻居路由器请求发送某些链路状态项目的详细信息</li>\n</ul>\n</li>\n<li>类型 4：链路状态更新分组\n<ul>\n<li>路由器使用这种分组将其链路状态进行洪范发送，即用洪泛法对全网更新链路状态</li>\n</ul>\n</li>\n<li>类型 5：链路状态确认分组\n<ul>\n<li>这是对链路状态更新分组的确认分组</li>\n</ul>\n</li>\n</ul>\n<p><strong>OSPF 的基本工作过程</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/ZumeT7yx8liRjEP.png\" alt=\"OSPF的基本工作过程\" /></p>\n<p><strong>OSPF 在多点接入网络中路由器邻居关系的建立</strong></p>\n<ul>\n<li>选举指定路由器 DR 和备用的指定路由器 BDR</li>\n<li>所有的非 DR/BDR 只与 DR/BDR 建立邻居关系</li>\n<li>非 DR/BDR 之间通过 DR/BDR 交换信息</li>\n</ul>\n<p>为了使 OSPF 能够用于规模很大的网络，OSPF 把一个自治系统再划分为若干个更小的范围，即做区域</p>\n<p>划分区域的好处就是把利用洪范方法交换链路体信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信信息</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/xCya8JBprtDRvMU.png\" alt=\"区域划分\" /></p>\n<h3 id=\"边界网关协议bgp的基本工作原理\"><a class=\"anchor\" href=\"#边界网关协议bgp的基本工作原理\">#</a> 边界网关协议 BGP 的基本工作原理</h3>\n<p>外部网关协议 EGP（例如边界网关协议 BGP）</p>\n<ul>\n<li>\n<p>在不同自治系统内，度量路由的 &quot;代价&quot;（距离，带宽，费用等）可能不同。因此，对于自治系统之间的路由选择，使用 &quot;代价&quot; 作为度量来寻找最佳路由是不行的</p>\n</li>\n<li>\n<p>自治系统之间的路由选择必须考虑相关策略（政治、经济、安全等）</p>\n</li>\n<li>\n<p>BGP 只能是力求寻找一条能够到达目的网络且比较好的路由（不能兜圈子），而并非要寻找一条最佳路由</p>\n</li>\n</ul>\n<p>在配置 BGP 时，每个自治系统的管理员要选择至少一个路由器作为该自治系统的 &quot;BGP 发言人&quot;</p>\n<p>不同自治系统的 BGP 代言人要交换路由信息，首先必须建立 TCP 连接，端口号为 179</p>\n<ul>\n<li>\n<p>在此 TCP 连接上交换 BGP 报文以建立 BGP 会话</p>\n</li>\n<li>\n<p>利用 BGP 会话交换路由信息（例如，增加新的路由，或撤销过时的路由，以及报告出错的情况等）</p>\n</li>\n<li>\n<p>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此称为对方的邻站或对等站</p>\n</li>\n</ul>\n<p>BGP 发言人除了运行 BGP 外，还必须运行自己所在自治系统所使用的内部网关协议 IGP，例如 OSPF 或 RIP</p>\n<p>BGP 发言人交换网络可达性的信息（要到达某个网络所要经过的一系列自治系统）</p>\n<p>当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出各自治系统的较好路由。也就是构造出树形结构，不存在回路的自治系统连通图</p>\n<p>BGP 适用于多级结构的因特网</p>\n<p>BGP-4 有以下 4 种报文：</p>\n<ul>\n<li>OPEN（打开）报文：用来与相邻的另一个 BGP 发言人建立关系，使通信初始化</li>\n<li>UPDATE（更新）报文：用来通告某一路由的信息，以及列出要撤销的多条路由</li>\n<li>KEEPALIVE（保活）报文：用来周期性地证实邻站的连通性</li>\n<li>NOTIFICATION（通知）报文：用来发送检测到的差错</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/ABavK6HnDwheiUR.png\" alt=\"习题\" /></p>\n<p>解析：R1 和 R2 之间是两个不同的自治系统 AS，且 R1 和 R2 为两个自治系统边缘连接路由器，因此采用外部网关协议 EGP 协议，具体为 BGP 协议进行路由信息交换，BGP 路由协议报文被封装到 TCP 报文中进行传输</p>\n<p>2、直接封装 RIP、OSPF、BGP 报文的协议分别是（D）</p>\n<p>A.TCP、UDP、IP      B.TCP、IP、UDP        C.UDP、TCP、IP       D、UDP、IP、TCP</p>\n<p>解析：记住下面的封装关系即可</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/mK8d97yrhzxbfUI.png\" alt=\"习题2解析\" /></p>\n<h3 id=\"ipv4数据报的首部格式\"><a class=\"anchor\" href=\"#ipv4数据报的首部格式\">#</a> IPv4 数据报的首部格式</h3>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/l65EC8W1mVnkuvL.png\" alt=\"IPv4数据报首部格式\" /></p>\n<ul>\n<li>\n<p>版本</p>\n<ul>\n<li>占 4 比特，表示 IP 协议的版本</li>\n<li>通信双方使用的版本必须一致，目前广泛使用的 IP 协议版本号为 4（即 IPv4）</li>\n</ul>\n</li>\n<li>\n<p>首部长度</p>\n<ul>\n<li>占 4 比特，表示 IP 数据报首部的长度，该字段的取值以 4 字节为单位</li>\n<li>最小十进制取值为 5，表示 IP 数据报首部只有 20 字节固定部分</li>\n<li>最大十进制取值为 15，表示 IP 数据报首部只包含 20 字节固定部分和最大 40 字节可变部分</li>\n</ul>\n</li>\n<li>\n<p>可选字段</p>\n<ul>\n<li>长度从 1 个字节到 40 个字节不等。用来支持排错、测量和安全措施</li>\n<li>可选字段增加了 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理 IP 数据报的开销。实际上可选字段很少被使用</li>\n</ul>\n</li>\n<li>\n<p>填充字段：用于确保首部长度为 4 字节的整数倍，使用全 0 进行填充</p>\n</li>\n<li>\n<p>区分服务</p>\n<ul>\n<li>占 8 比特，用来获得更好的服务</li>\n<li>该字段在旧标准中叫工作服务类型，但实际上一直没有被使用过</li>\n<li>利用该字段的不同数值可提供不同等级的服务质量</li>\n<li>只有在使用区分服务时，该字段才起作用。一般情况下都不使用该字段</li>\n</ul>\n</li>\n<li>\n<p>总长度</p>\n<ul>\n<li>占 16 比特，表示 IP 数据报的总长度（首部 + 数据载荷）</li>\n<li>最大取值为十进制的 65535，以字节为单位</li>\n</ul>\n</li>\n<li>\n<p>标识、标志、片偏移</p>\n<ul>\n<li>三个字段共同用于 IP 数据报分片</li>\n<li>标识\n<ul>\n<li>占 16 比特，属于同一个数据报的各分片数据报应该有相同标识</li>\n<li>IP 软件维持一个计数器，每产生一个数据报，计数器增加 1，并将此赋给标识字段</li>\n</ul>\n</li>\n<li>标志\n<ul>\n<li>占 3 比特，各比特含义如下：</li>\n<li>DF 位：1 表示不允许分片，0 表示允许分片</li>\n<li>MF 位：1 表示后面还有分片，0 表示这是最后一个分片</li>\n<li>保留位：必须设置为 0</li>\n</ul>\n</li>\n<li>片偏移：\n<ul>\n<li>占 13 比特，指出分片数据报的数据载荷部分偏移其在原数据报的位置有多少个单位</li>\n<li>片偏移以 8 个字节为单位</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>生存时间字段 TTL</p>\n<ul>\n<li>占 8 比特，最初以秒为单位，最大生存周期为 255 秒；路由器转发 IP 数据报时，将 IP 数据报首部中的该字段的值减去 IP 数据报在本地路由器上所耗费的时间，若不为 0 就转发，否则就丢弃</li>\n<li>现在以 &quot;跳数&quot; 为单位，路由器转发 IP 数据报时，将 IP 数据报首部中的该字段减 1，若不为 0 就转发，否则就丢弃</li>\n<li>作用：防止 IP 数据报在网络中永久兜圈</li>\n</ul>\n</li>\n<li>\n<p>协议</p>\n<ul>\n<li>占 8 比特，指明 IPv4 数据报的数据部分是何种协议数据单元。常用的一些协议和相关协议字段如下：</li>\n<li>ICMP：1；IGMP：2；TCP：6；UDP：17；IPv6：41；OSPF：89；</li>\n</ul>\n</li>\n<li>\n<p>首部检验和</p>\n<ul>\n<li>占 16 比特，用来检测首部在传输过程中是否出现差错。比 CRC 检验码简单，称为因特网检验和</li>\n<li>IP 数据报每经过一个路由器，路由器都要重新计算首部检验和，因为某些字段（生存时间、标志、片偏移等）的取值可能发生变化</li>\n<li>由于 IP 层本身并不提供可靠传输服务，并且计算首部校验和是一项耗时的操作，因此在 IPv6 中，路由器不再计算首部校验和，从而更快转发 IP 数据报</li>\n</ul>\n</li>\n<li>\n<p>源 IP 地址和目的 IP 地址</p>\n<ul>\n<li>各占 32 比特，用来填写发送该 IP 数据报的源主机 IP 地址和接受该 IP 数据报的目的主机的 IP 地址</li>\n</ul>\n</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/mG1ve4b3zYkXjWS.png\" alt=\"习题\" /></p>\n<p>解析：</p>\n<p>由于每个分片需要分最大的分片，因此封装数据的字节数为 800-20=780B，一共有 1480B 数据传输至少需要 2 个分片，第一个分片的片偏移量为 0/8=0，第二个分片的片偏移量为 780/8=97.5，由于片偏移量必须是整数，因此，这种方案不行。</p>\n<p>将分片长度改为小于 780 且能整除 8 的最大整数，因此，第一个分片装 776 字节，第二个分片装 704 个字节，分片二的片偏移量为 776/8=97</p>\n<p>2、</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/12/UQq2TeZkEgGRLKI.png\" alt=\"习题\" /></p>\n<p>解析：</p>\n<p>Web 请求在网际层被封装在 IP 分组的数据部分，IP 分组头部目的 IP 地址前有 16 个字节，在以太网帧中，数据部分前面还有 14 个字节，因此，从第 30 个字节开始后的 4 个字节数据即是目的 IP 地址。因此目的 IP 地址为：40aa6220-&gt;64.170.98.32。由图可知，主机的默认网关就是路由器 R，以太网帧中封装的目的 MAC 地址就是默认网关的地址：00-21-27-21-51-ee</p>\n<p>IP 分组经过 R 时，IP 分组头中的生存时间字段需要减 1，首部检验和会被重新计算。若 IP 分组总长度大于 MTU，则需要进行分片，此时总长度字段、标志字段、片偏移字段都需要修改</p>\n<h3 id=\"网际控制报文协议icmp\"><a class=\"anchor\" href=\"#网际控制报文协议icmp\">#</a> 网际控制报文协议 ICMP</h3>\n<p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网络控制报文协议 ICMP</p>\n<p>主机或路由器使用 ICMP 来发送差错报告报文和询问报文</p>\n<p>ICMP 报文被封装在 IP 数据报中发送</p>\n<p>ICMP 差错报告报文共有以下五种：</p>\n<ul>\n<li>\n<p>终点不可达</p>\n<ul>\n<li>当路由器或主机不能交付数据时，就向源点发送终点不可达报文，具体可再根据 ICMP 的代码字段细分为目的网络不可达、目的主机不可达、目的协议不可达、目的端口不可达、目的网络未知、目的主机未知等 13 中错误</li>\n</ul>\n</li>\n<li>\n<p>源点抑制</p>\n<ul>\n<li>当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢</li>\n</ul>\n</li>\n<li>\n<p>时间超过</p>\n<ul>\n<li>当路由器收到一个目的 IP 地址不是自己的 IP 数据报，会将其生存时间 TTL 字段的值减 1。若结果不为 0，则将该 IP 数据报转发出去；若结果为 0，除丢弃该 IP 数据报外，还要向源点发送时间超过报文</li>\n</ul>\n</li>\n<li>\n<p>参数问题</p>\n<ul>\n<li>当路由器或目的主机收到 IP 数据报后，根据其首部中的检验和字段发现首部在传输过程中出现了误码，就丢弃该数据报，并向源点发送参数问题报文</li>\n</ul>\n</li>\n<li>\n<p>改变路由（重定向）</p>\n<ul>\n<li>路由器把改变路由报文发送给主机，让主机知道下次应将数据发送给另外的路由器（可通过更好的路由）</li>\n</ul>\n</li>\n</ul>\n<p>以下情况不应发送 ICMP 差错报文：</p>\n<ul>\n<li>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文</li>\n<li>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文</li>\n<li>对具有多播地址的数据报都不发送 ICMP 差错报告报文</li>\n<li>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文</li>\n</ul>\n<p>常用的 ICMP 询问报文由以下两种：</p>\n<ul>\n<li>回送请求和回答\n<ul>\n<li>ICMP 回送请求报文是由主机或路由器向一个特定的主机发送的询问</li>\n<li>收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文</li>\n<li>这种询问报文用来测试目的站是否可达及了解其有关状态</li>\n</ul>\n</li>\n<li>时间戳清奇和回答\n<ul>\n<li>ICMP 时间戳请求报文是请某个主机或路由器回答当前的日期和时间</li>\n<li>在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表 1900 年 1 月 1 日起到当前时刻一共有多少秒</li>\n<li>这种时钟报文用来时钟同步和测量时间</li>\n</ul>\n</li>\n</ul>\n<p><strong>ICMP 应用举例</strong></p>\n<p>分组网络探测 PING</p>\n<ul>\n<li>用来测试主机或路由器间的连通性</li>\n<li>应用层直接使用网际层的 ICMP（没有通过运输层的 TCP 或 UDP）</li>\n<li>使用 ICMP 回送请求和回答报文</li>\n</ul>\n<p>跟踪路由：</p>\n<ul>\n<li>用来测试 IP 数据报从源主机到达目的主机要经过哪些路由器</li>\n<li>Windows 版本\n<ul>\n<li>tracert 命令</li>\n<li>应用层直接使用网际层 ICMP</li>\n<li>使用了 ICMP 回送请求和回答报文以及差错报告报文</li>\n</ul>\n</li>\n<li>Unix 版本\n<ul>\n<li>traceroute 指令</li>\n<li>在运输层使用 UDP 协议</li>\n<li>仅使用 ICMP 差错报告报文</li>\n</ul>\n</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、若路由器 R 因为拥塞丢弃 IP 分组，则此时 R 可向发送出该 IP 分组的源主机发送的 ICMP 报文类型是（C）</p>\n<p>A. 路由重定向      B. 目的不可达           C. 源点抑制           D. 超时</p>\n<p>解析：因拥塞丢弃分组需要发送源点抑制 ICMP 差错报文，使源点知道应把数据报的发送速率放慢</p>\n<h3 id=\"虚拟专用网vpn和网络地址转发nat\"><a class=\"anchor\" href=\"#虚拟专用网vpn和网络地址转发nat\">#</a> 虚拟专用网 VPN 和网络地址转发 NAT</h3>\n<p><strong>虚拟专用网 VPN</strong></p>\n<p>利用公用的因特网作为本机构各专用网络之间的通信网络，这样的专用网又称为虚拟专用网</p>\n<p>由于 IPv4 地址的紧缺，一个机构能够申请到的 IPv4 地址数量往往远小于本机所拥有的主机数量。因此，虚拟专用网中的各主机所分配的地址应该是本机构可自由分配的专用地址，而不是需要申请的、在因特网上使用的公有地址</p>\n<p>同一机构内不同的部门的内部网络所构成的虚拟专用网络 VPN 又称为内联网 VPN</p>\n<p>有时一个机构的 VPN 需要有某些外部机构（通常就是合作伙伴）参与进来，这样的 VPN 就称为外联网 VPN</p>\n<p>在外地工作的员工需要访问公司内部的专用网络时，只要在任何地点接入到因特网，运行驻留在员工 PC 中的 VPN 软件，在员工的 PC 和公司的主机之间建立 VPN 隧道，即可访问专用网络中的资源。这种 VPN 称为远程接入 VPN</p>\n<p><strong>网络地址转换 NAT</strong></p>\n<p>虽然因特网采用了无分类编址方式来减缓 IPv4 地址空间耗尽的速度，但由于因特网用户数目的激增，特别是大量小型办公室网络和家庭网络接入因特网的需求不断增加，IPv4 地址空间即将面临耗尽的危险仍没有被解除</p>\n<p>本质上是公司内网的主机怎么和全球因特网主机进行信息交流</p>\n<p>该转换方法有一个问题：如果 NAT 路由器具有 N 个全球 IP 地址，那么至多能有 N 个内网主机能够和因特网上的主机通信</p>\n<p>由于绝大多数的网络应用都是使用运输层 TCP 或 UDP 来传送数据，因此可以利用运输层的端口号和 IP 地址一起进行转换。</p>\n<p>这样，用一个全球 IP 地址就可以使多个拥有本地地址的主机同时和因特网上的主机进行通信。这种将端口号和 IP 地址一起进行转换的技术叫做网络地址与端口号转换 NAPT</p>\n<p>对于一些 P2P 网络应用，需要外网主机主动与内网主机进行通信，在通过 NAT 时会遇到问题，需要网络应用自己使用一些特殊的 NAT 穿越技术来解决问题</p>\n<p>另外，由于 NAT 对外网屏蔽了内网主机的网络地址，能为内网的主机提供一定的安全保护</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-4-1/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-4-1/",
            "title": "操作系统408-4-1",
            "date_published": "2024-08-08T11:43:38.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"文件管理\"><a class=\"anchor\" href=\"#文件管理\">#</a> 文件管理</h3>\n<p><strong>文件的属性</strong></p>\n<p>文件名：由创建文件的用户决定文件名，主要是为了方便用户找到文件，同一目录下不允许有重名文件</p>\n<p>标识符：一个系统内的各文件标识符唯一，对用户来说毫无可读性，因此标识符只是操作系统用于区分各个文件的一种内部名称</p>\n<p>类型：指明文件的类型</p>\n<p>位置：文件存放的路径（让用户使用）、在外存中的地址（操作系统使用，对用户不可见）</p>\n<p>大小：指明文件大小</p>\n<p>创建时间、上次修改时间、文件所有者信息</p>\n<p>保护信息：对文件进行保护的访问控制信息</p>\n<p><strong>文件内部数据组织方式</strong></p>\n<p>无结构文件（如文本文件）—— 由一些二进制或字符流组成，又称 &quot;流式文件&quot;</p>\n<p>有结构文件（如数据库表）—— 由一组相似的记录组成，又称 &quot;记录式文件&quot;</p>\n<p>记录是一组相关数据项的集合，数据项是文件系统中最基本的数据单位</p>\n<p>其对应文件的逻辑结构</p>\n<p><strong>文件之间如何被组织起来</strong></p>\n<p>目录结构</p>\n<p><strong>操作系统向上提供的功能</strong></p>\n<ul>\n<li>创建文件（create 系统调用）</li>\n<li>删除文件（delete 系统调用）</li>\n<li>读文件（read 系统调用）</li>\n<li>写文件（write 系统调用）</li>\n<li>打开文件（open 系统调用）</li>\n<li>关闭文件（close 系统调用）</li>\n</ul>\n<p><strong>文件如何放在外存</strong></p>\n<p>文件的物理结构</p>\n<p><strong>操作系统如何管理外存中的空闲块</strong></p>\n<p>存储空间的管理</p>\n<p><strong>操作系统需要提供的其他文件管理功能</strong></p>\n<p>文件共享：使多个用户可以共享使用一个文件</p>\n<p>文件保护：如何保证不同的用户对文件有不同的操作权限</p>\n<h3 id=\"文件的逻辑结构\"><a class=\"anchor\" href=\"#文件的逻辑结构\">#</a> 文件的逻辑结构</h3>\n<p>逻辑结构：在用户看来，文件内部的数据应该是如何组织起来的</p>\n<p>物理结构：在操作系统看来，文件的数据是如何存放在外存的</p>\n<h4 id=\"无结构文件\"><a class=\"anchor\" href=\"#无结构文件\">#</a> 无结构文件</h4>\n<p>按文件是否有结构分类，可以分为无结构文件、有结构文件</p>\n<p>无结构文件：文件内部的数据就是一系列二进制流或字符流组成，又称 &quot;流式文件&quot;，如.txt 文件</p>\n<h4 id=\"有结构文件\"><a class=\"anchor\" href=\"#有结构文件\">#</a> 有结构文件</h4>\n<p>有结构文件：由一组相似的记录组成，又称 &quot;记录式文件&quot;。每条记录由若干个数据项组成，一般来说每条记录有一个数据项可作为关键字。根据各条记录的长度（占用的存储空间）是否相等，又可分为定长记录和可变长记录两种</p>\n<p><strong>有结构文件的逻辑结构</strong></p>\n<ul>\n<li>顺序文件：文件中的记录一个接一个地顺序排列（逻辑上）。记录可以是定长的或可变长的。各个记录在物理上可以顺序存储或链式存储\n<ul>\n<li>顺序存储 —— 逻辑上相邻的记录物理上也相邻（类似于顺序表）\n<ul>\n<li>可变长记录：无法实现随机存取，每次只能从第一个记录开始依次往后查找</li>\n<li>定长记录：\n<ul>\n<li>可实现随机存取。记录长度为 L，则第 i 个记录存放的相对位置是 i*L</li>\n<li>若采用串结构，无法快速找到某关键字对应的记录</li>\n<li>若采用顺序结构，可以快速找到某关键字对应的记录（如折半查找）</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>链式存储 —— 逻辑上相邻的记录物理上不一定相邻（类似于链表）\n<ul>\n<li>无论是定长 / 可变长记录，都无法实现随机存取，每次只能从第一个记录开始依次往后查找</li>\n</ul>\n</li>\n<li>串结构：记录之间的顺序与关键字无关（通常按照记录存入的时间决定记录的顺序）</li>\n<li>顺序结构：记录之间的顺序按关键字顺序排列</li>\n<li>缺点：增加 / 删除一个记录比较困难（如果是串结构则相对简单）</li>\n</ul>\n</li>\n</ul>\n<p>结论：定长记录的顺序文件，若物理上采用顺序存储，则可实现随机存取；若能再保证记录的顺序结构，则可实现快速检索（即根据关键字快速找到对应记录）。</p>\n<ul>\n<li>索引文件\n<ul>\n<li>建立一张索引表以加快文件检索速度。每条记录对应一个索引项</li>\n<li>文件中的这些记录在物理上可以离散地存放</li>\n<li>索引表本身是定长记录的顺序文件，因此可以快速找到第 i 个记录对应的索引项</li>\n<li>可将关键字作为索引号内容，若按关键字顺序排列，还可以支持按关键字折半查找</li>\n<li>每当要增加 / 删除一个记录时，需要对索引表进行修改。由于索引文件有很快的检索速度，因此主要用于对信息处理的及时性要求比较高的场合</li>\n<li>另外可以用不同的数据项建立多个索引表</li>\n<li>解决了顺序文件不方便增 / 删记录的问题，同时让不定长记录的文件实现了随机存取，但索引表可能占用很多空间</li>\n</ul>\n</li>\n<li>索引顺序文件\n<ul>\n<li>索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是；并不是每个记录对应一个索引表项，而是一组记录对应一个索引表项</li>\n<li>索引顺序文件的索引项不需要按关键字顺序排列，这样可以极大地方便新表项的插入</li>\n</ul>\n</li>\n<li>多级索引顺序文件\n<ul>\n<li>为了进一步提高检索效率，可以为顺序文件建立多级索引表</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"文件目录\"><a class=\"anchor\" href=\"#文件目录\">#</a> 文件目录</h3>\n<p><strong>文件控制块</strong></p>\n<p>目录文件中的一条记录就是一个 &quot;文件控制块（FCB）&quot;</p>\n<p>FCB 的有序集合称为 &quot;文件目录&quot;，一个 FCB 就是一个文件目录项。</p>\n<p>FCB 中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读 / 可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）</p>\n<p>最重要的，最基本的还是文件名、文件存放的物理地址</p>\n<p>FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现 &quot;按名存取&quot;</p>\n<p>对目录进行的操作：</p>\n<ul>\n<li>搜索：当用户需要使用一个文件时，系统要根据文件名搜索目录，找到各文件对应的目录项</li>\n<li>创建文件：创建一个新文件时，需要在其所属的目录中增加一个目录项</li>\n<li>删除文件：当删除一个文件时，需要在目录中删除相应的目录项</li>\n<li>显示目录：用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性</li>\n<li>修改目录：某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项</li>\n</ul>\n<h4 id=\"目录结构\"><a class=\"anchor\" href=\"#目录结构\">#</a> 目录结构</h4>\n<p><strong>单级目录结构</strong></p>\n<p>整个系统中只建立一张目录表，每个文件占一个目录项</p>\n<p>单级目录实现了 &quot;按名存取&quot;，但是不允许文件重名</p>\n<p>在创建一个文件时，需要先检查目录表中有没有重名文件，确定不重名后才能允许建立文件，并将新文件对应的目录项插入目录表中。</p>\n<p>单级目录结构不适用于多用户操作系统</p>\n<p><strong>两级目录结构</strong></p>\n<p>两级目录结构分为主文件目录和用户文件目录</p>\n<p>允许不同用户的文件重名。文件名相同但对应了不同的文件</p>\n<p>两级目录结构允许用户的文件重名，也可以在目录上实现访问限制（检查此时登录用户是否匹配），但是两级目录结构依然缺乏灵活性，用户不能对自己的文件进行分类</p>\n<p><strong>多级目录</strong></p>\n<p>又称树形目录结构</p>\n<p>不同目录下的文件可以重名</p>\n<p>用户（或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径是个字符串。各级目录之间用 / 隔开。从根目录出发的路径称为绝对路径。</p>\n<p>很多时候，用户会连续访问同一目录内的多个文件，每次都从根目录开始查找，是很低效的，因此可以设置一个 &quot;当前目录&quot;</p>\n<p>当用户想要访问某个文件时，可以用从当前目录出发的相对路径</p>\n<p>引入当前目录和相对路径后，磁盘的 I/O 次数减少了，这就提升了访问文件的效率</p>\n<p>树形目录结构可以很方便的对文件进行分类，层次结构清晰，也能够有效地进行文件的管理和保护。但是，树形结构不便于实现文件的共享。为此，提出了 &quot;无环图目录结构&quot;</p>\n<p><strong>无环图目录结构</strong></p>\n<p>在树形结构的基础上，增加了一些指向同一节点的有向边，使整个目录成为一个有向无环图。可以更方便地实现多个用户间的文件共享</p>\n<p>可以用不同的文件名指向同一个文件，甚至可以指向同一个目录（共享同一目录下的所有内容）。</p>\n<p>需要为每个共享结点设置一个共享计数器，用于记录此时有多少个地方在共享该结点，用户提出删除结点的请求时，只是删除该用户的 FCB、并使共享计数器减 1，并不会直接删除共享结点</p>\n<p>注意：共享文件不同于复制文件。在共享文件中，由于各用户指向的是同一个文件，因此只要其中一个用户修改了文件数据，那么所有用户都可以看到文件数据的变化</p>\n<p><strong>索引结点（FCB 的改进）</strong></p>\n<p>除了文件名之外的所有信息都放到索引结点中，每个文件对应一个索引节点</p>\n<p>目录项中只包含文件名，索引节点指针，因此每个目录项的长度大幅减小</p>\n<p>存放在外存中的索引结点称为 &quot;磁盘索引结点&quot;，当索引结点放入内存后称为 &quot;内存索引结点&quot;。相比之下内存索引结点中需要增加一些信息，比如：文件是否被修改，此时有几个进程正在访问该文件等</p>\n<p>由于目录项长度减小，因此每个磁盘块可以存放更多个目录项，因此检索文件时磁盘 I/O 的次数就少了很多</p>\n<h3 id=\"文件的物理结构\"><a class=\"anchor\" href=\"#文件的物理结构\">#</a> 文件的物理结构</h3>\n<p>类似于内存分页，磁盘中的存储单元也会被分为一个个 &quot;块 / 磁盘块 / 物理块&quot;。很多操作系统中，磁盘块的大小与内存块、页面的大小相同</p>\n<p>内存与磁盘之间的数据交换（即读 / 写操作、磁盘 I/O）都是以 &quot;块&quot; 为单位进行的，即每次读入一块，或每次写出一块</p>\n<h4 id=\"文件块-磁盘块\"><a class=\"anchor\" href=\"#文件块-磁盘块\">#</a> 文件块、磁盘块</h4>\n<p>在内存管理中，进程的逻辑地址空间被分为一个一个页面</p>\n<p>同样的，在外存管理中，为了方便对文件数据的管理，文件的逻辑地址空间也被分为一个一个的文件的 &quot;块&quot;</p>\n<p>于是文件的逻辑地址也可以表示为 (逻辑块号，块内地址) 的形式</p>\n<p>操作系统为文件分配存储空间都是以块为单位的</p>\n<p>用户通过逻辑地址来操作自己的文件，操作系统要负责实现从逻辑地址到物理地址的映射</p>\n<h4 id=\"文件分配方式连续分配\"><a class=\"anchor\" href=\"#文件分配方式连续分配\">#</a> 文件分配方式 —— 连续分配</h4>\n<p>目录项中记录了起始块号，文件长度</p>\n<p>连续分配方式要求每个文件在磁盘上占有一组连续的块</p>\n<p>优点：支持顺序访问和直接访问（即随机访问）；连续分配的文件在顺序访问时速度最快</p>\n<p>缺点：不方便文件扩展；存储空间利用率低，会产生磁盘碎片</p>\n<h4 id=\"文件分配方式链接分配\"><a class=\"anchor\" href=\"#文件分配方式链接分配\">#</a> 文件分配方式 —— 链接分配</h4>\n<p>链接分配采取离散分配的方式，可以为文件分配离散的磁盘块，分为隐式链接和显示链接两种</p>\n<p><strong>隐式链接</strong></p>\n<p>目录中记录了文件存放的起始块号和结束块号。除了文件的最后一个磁盘块之外，每个磁盘块中都会保存指向下一个盘块的指针，这些指针对用户时透明的</p>\n<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高</p>\n<p>缺点：只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间</p>\n<p><strong>显示链接</strong></p>\n<p>把用于链接文件各物理块的指针显式地存放在一张表里，即文件分配表（FAT）。一个磁盘只会建立一张文件分配表。开机时文件分配表放入内存，并常驻内存</p>\n<p>目录项中记录了起始块号</p>\n<p>优点：很方便文件拓展，不会有碎片问题，外存利用率高，并且支持随机访问。相比于隐式链接来说，地址转换时不需要访问磁盘，因此文件的访问效率更高</p>\n<p>缺点：文件分配表的需要占用一定的存储空间</p>\n<p>考试时默认的是隐式链接的链接分配</p>\n<h4 id=\"文件分配方式索引分配\"><a class=\"anchor\" href=\"#文件分配方式索引分配\">#</a> 文件分配方式 —— 索引分配</h4>\n<p>索引分配允许文件离散地分配在各个磁盘块中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块（索引表的功能类似于内存管理的页表 —— 建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为索引块。文件数据存放的磁盘块称为数据块</p>\n<p>索引分配方式可以支持随机访问。文件拓展也很容易实现（只需要给文件分配一个空闲块，并增加一个索引表项即可），但索引表需要占用一定的存储空间</p>\n<p><strong>链接方案</strong></p>\n<p>如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p>\n<p>缺点：若文件很大，索引表很长，就需要将很多个索引链接起来。想要找到 i 号索引块，必须先依次读入 0~i-1 号索引块，这就导致磁盘 I/O 次数过多，查找效率低下</p>\n<p><strong>多层索引</strong></p>\n<p>建立多层索引（原理类似于多级页表）。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块</p>\n<p>若采用多层索引，则各层索引表大小不能超过一个磁盘块</p>\n<p>采用 K 层索引结构，且顶级索引表未调入内存，则访问一个数据块只需要 K+1 次读磁盘操作</p>\n<p>缺点：即使是小文件，访问一个数据块仍然需要 K+1 次读磁盘</p>\n<p><strong>混合索引</strong></p>\n<p>多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表）、还包含两级简介索引（指向两层索引表）。</p>\n<p>优点：对于小文件来说，访问一个数据块所需的读磁盘次数更少</p>\n<p><strong>重点</strong></p>\n<ul>\n<li>要根据多层索引、混合索引的结构计算文件的最大长度（Key：各级索引表最大不能超过一个块）</li>\n<li>要能分析访问某个数据块需要的读磁盘次数（Key：FCB 中会存有指向顶级索引块的指针，因此可以根据 FCB 读入顶级索引块，每次读入下一级的索引块都需要一次读磁盘操作。另外，要注意题目条件 —— 顶级索引快是否已经读入内存）</li>\n</ul>\n<h3 id=\"文件存储空间管理\"><a class=\"anchor\" href=\"#文件存储空间管理\">#</a> 文件存储空间管理</h3>\n<h4 id=\"存储空间的划分与初始化\"><a class=\"anchor\" href=\"#存储空间的划分与初始化\">#</a> 存储空间的划分与初始化</h4>\n<p>存储空间的划分：将物理空间划分为一个个文件卷（逻辑卷、逻辑盘）</p>\n<p>存储空间的初始化：将各个文件卷划分为目录区、文件区</p>\n<p>目录区主要存放文件目录信息（FCB）、用于磁盘存储空间管理信息</p>\n<p>文件区用于存放文件数据</p>\n<h4 id=\"存储空间管理空闲表法\"><a class=\"anchor\" href=\"#存储空间管理空闲表法\">#</a> 存储空间管理 —— 空闲表法</h4>\n<p>如何分配磁盘块：为一个文件分配连续的存储空间。同样可采用首次适应、最佳适应、最坏适应等算法决定要为文件分配哪个区间</p>\n<p>如何回收磁盘块：当回收某个存储区时需要有四种情况</p>\n<ul>\n<li>回收区前后都没有相邻空闲区</li>\n<li>回收区的前后都是空闲区</li>\n<li>回收区前面是空闲区</li>\n<li>回收区后面时空闲区</li>\n</ul>\n<p>总之，回收时需要注意表项的合并问题</p>\n<h4 id=\"存储空间管理空闲链表法\"><a class=\"anchor\" href=\"#存储空间管理空闲链表法\">#</a> 存储空间管理 —— 空闲链表法</h4>\n<p><strong>空闲盘块链</strong></p>\n<p>以盘块为单位组成一条空闲链，空闲盘块中存储着下一个空闲盘块的指针</p>\n<p>操作系统保存着链头、链尾指针</p>\n<p>如何分配：若某文件申请 K 个盘块，则从链头开始依次摘下 K 个盘块分配，并修改空闲链的链头指针</p>\n<p>如何回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针</p>\n<p>适用于离散分配的物理结构。为文件分配多个盘块时可能要重复操作多次</p>\n<p><strong>空闲盘区链</strong></p>\n<p>以盘区为单位组成一条空闲链，连续的空闲盘块组成一个空闲盘区，空闲盘区中的第一个盘块内记录了盘区的长度、下一个盘区的指针</p>\n<p>操作系统保存着链头、链尾指针</p>\n<p>如何分配：若某文件申请 K 个盘块，则可以采用首次适应、最佳适应等算法，从链头开始检索，按照算法规则找到一个大小符合要求的空闲盘区，分配给文件。若没有合适的连续空闲块，也可以将不同盘区的盘块同时分配给一个文件，注意分配后可能要修改相应的链指针、盘区大小等数据</p>\n<p>如何回收：若回收区和某个空闲盘区相邻，则需要将回收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾</p>\n<p>离散分配、连续分配都适用。为一个文件分配多个盘块时效率更高</p>\n<h4 id=\"存储空间管理位示图法\"><a class=\"anchor\" href=\"#存储空间管理位示图法\">#</a> 存储空间管理 —— 位示图法</h4>\n<p>位示图：每个二进制位对应一个盘块。位示图一般用连续的字表示，字中每一位对应一个盘块，因此可以用（字号，位号）对应一个盘块号。</p>\n<p>（字号，位号）=（i,j）的二进制位对应的盘块号 b=ni+j，b 号盘块对应的字号 i=b/n，位号 j=b% n</p>\n<p>如何分配：若文件需要 K 个块</p>\n<ul>\n<li>顺序扫描位示图，找到 K 个相邻或不相邻的 0</li>\n<li>根据字号、位号算出相应的盘块号，将相应盘块分配给文件</li>\n<li>将相应位设置为 1</li>\n</ul>\n<p>如何回收：</p>\n<ul>\n<li>根据回收的盘块号计算出相应的字号、位号</li>\n<li>将相应二进制位设为 0</li>\n</ul>\n<p>连续分配、离散分配都适用</p>\n<h4 id=\"存储空间管理成组链接法\"><a class=\"anchor\" href=\"#存储空间管理成组链接法\">#</a> 存储空间管理 —— 成组链接法</h4>\n<p>空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX 系统中采用了成组链接法对磁盘空闲块进行管理</p>\n<p>文件卷的目录区中专门用一个磁盘块作为 &quot;超级块&quot;，当系统启动时需要将超级块读入内存。并且要保证内存与外存中的 &quot;超级块&quot; 数据一致</p>\n<p>超级块中每一组保存了下一组空闲盘块数以及该组所有的空闲盘块号，每一组最后一个空闲磁盘块保存了再下一组空闲磁盘块的信息</p>\n<p>注意：</p>\n<ul>\n<li>若已经没有下一组空闲块，则设置为特殊值 - 1</li>\n<li>一个分组中的块号不需要连续，此处只是为了让大家更方便看出各个分组的数量</li>\n</ul>\n<p>如何分配：</p>\n<ul>\n<li>检查第一个分组的块数是否足够</li>\n<li>如果足够，分配第一个分组中的空闲块，并修改相应数据</li>\n<li>如果刚好足够，则将最后一个磁盘块中的下一分组的最后一个磁盘块信息（也就是链接信息）复制到超级块中，保证链接不中断</li>\n</ul>\n<p>如何回收：</p>\n<ul>\n<li>\n<p>以回收单个块为例</p>\n</li>\n<li>\n<p>如果第一个分组还没有满，就把这个空闲块放到第一个分组当中</p>\n</li>\n<li>\n<p>如果第一个分组已经满了，需要将超级块的数据复制到新回收的块中，并修改超级块的内容，让新回收的块成为第一个分组</p>\n</li>\n</ul>\n<h3 id=\"文件的基本操作\"><a class=\"anchor\" href=\"#文件的基本操作\">#</a> 文件的基本操作</h3>\n<h4 id=\"创建文件\"><a class=\"anchor\" href=\"#创建文件\">#</a> 创建文件</h4>\n<p>进行 Create 系统调用时，需要提供几个主要参数：</p>\n<ul>\n<li>所需的外存空间大小（如：一个盘块，即 1KB）</li>\n<li>文件存放路径</li>\n<li>文件名</li>\n</ul>\n<p>操作系统在处理 Create 系统调用时，主要做了两件事情：</p>\n<ul>\n<li>在外存中找到文件所需的控件（使用查找空闲空间的算法，找到空闲空间）</li>\n<li>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息</li>\n</ul>\n<h4 id=\"删除文件\"><a class=\"anchor\" href=\"#删除文件\">#</a> 删除文件</h4>\n<p>进行 Delete 系统调用时，需要提供几个主要参数：</p>\n<ul>\n<li>文件存放路径</li>\n<li>文件名</li>\n</ul>\n<p>操作系统在处理 Create 系统调用时，主要做了几件事情：</p>\n<ul>\n<li>\n<p>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。</p>\n</li>\n<li>\n<p>根据目录项记录的文件在外存中的存放位置、文件大小等信息，回收文件占用的磁盘块。（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p>\n</li>\n<li>\n<p>从目录表中删除文件对应的目录项</p>\n</li>\n</ul>\n<h4 id=\"打开文件\"><a class=\"anchor\" href=\"#打开文件\">#</a> 打开文件</h4>\n<p>进行 open 系统调用时，需要提供几个主要参数：</p>\n<ul>\n<li>文件存放路径</li>\n<li>文件名</li>\n<li>要对文件的操作类型（如：r 只读；rw 读写等）</li>\n</ul>\n<p>操作系统在处理 open 调用时，主要做了几件事：</p>\n<ul>\n<li>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项，并检查该用户是否有指定的操作权限</li>\n<li>将目录项复制到内存中的 &quot;打开文件表&quot; 中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明操作的文件</li>\n</ul>\n<h4 id=\"关闭文件\"><a class=\"anchor\" href=\"#关闭文件\">#</a> 关闭文件</h4>\n<p>进程使用完文件后，要 &quot;关闭文件&quot;：</p>\n<p>操作系统在处理 Close 系统调用时，主要做了几件事：</p>\n<ul>\n<li>将进程的打开文件表相应表项删除</li>\n<li>回收分配给该文件的内存空间等资源</li>\n<li>系统打开文件表的打开计数器 count 减 1，若 count=0，则删除对应表项</li>\n</ul>\n<h4 id=\"读文件\"><a class=\"anchor\" href=\"#读文件\">#</a> 读文件</h4>\n<p>进程使用 read 系统调用完成读操作。需要指明是哪个文件，还需要指明读入多少数据、指明读入数据要放在内存中的什么位置</p>\n<p>操作系统在处理 read 系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中</p>\n<h4 id=\"写文件\"><a class=\"anchor\" href=\"#写文件\">#</a> 写文件</h4>\n<p>进程使用 write 系统调用完成写操作。需要指明是哪个文件，还需要指明写出多少数据、指明写回外存的数据要放在内存中的什么位置</p>\n<p>操作系统在处理 write 系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</p>\n<h3 id=\"文件共享\"><a class=\"anchor\" href=\"#文件共享\">#</a> 文件共享</h3>\n<p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一文件</p>\n<p>注意：多个用户共享同一个文件，意味着系统中只有一份文件数据。并且只要某个用户修改了文件数据，其他用户也可以看到文件数据的变化。如果是多个用户都复制了同一个文件，那么系统中会有好几份文件数据。其中一个用户修改了自己的那份文件数据，对其他的用户的文件数据并没有影响</p>\n<h4 id=\"基于索引结点的共享方式硬链接\"><a class=\"anchor\" href=\"#基于索引结点的共享方式硬链接\">#</a> 基于索引结点的共享方式（硬链接）</h4>\n<p>索引节点中设置一个链接计数变量 count，用于表示链接到本索引结点上的用户目录项数。</p>\n<p>各用户的目录项指向同一个索引节点</p>\n<p>某用户想删除文件时，只是删除该用户的目录项，count--</p>\n<p>只有 count==0 时才能真正删除文件数据和索引节点，否则会导致指针悬空</p>\n<h4 id=\"基于符号链的共享方式软链接\"><a class=\"anchor\" href=\"#基于符号链的共享方式软链接\">#</a> 基于符号链的共享方式（软链接）</h4>\n<p>用 link 型文件，记录共享文件的存放路径，类似于快捷方式</p>\n<p>当访问 Link 文件时，操作系统会根据其中记录的路径层层查找目录，最终找到 link 文件路径记录的共享文件</p>\n<p>即使软链接指向的共享文件已被删除，Link 型文件依然存在，只是通过 Link 型文件的路径去查找共享文件会失败（找不到对应目录项）</p>\n<p>用于软链接的方式访问共享文件时要查询多级目录，会有多次磁盘 I/O，因此用软连接访问</p>\n<h3 id=\"文件保护\"><a class=\"anchor\" href=\"#文件保护\">#</a> 文件保护</h3>\n<h4 id=\"口令保护\"><a class=\"anchor\" href=\"#口令保护\">#</a> 口令保护</h4>\n<p>为文件设置一个口令，用户请求访问时必须提供口令</p>\n<p>口令一般存放在文件对应的 FCB 或索引结点中。用户访问文件前需要先输入口令，操作系统会将用户提供的口令与 FCB 中存储的口令进行对比，如果正确，则允许该用户访问文件</p>\n<p>优点：保存口令的空间开销不多，验证口令的时间开销也很小</p>\n<p>缺点：正确的口令存放在系统内部，不够安全</p>\n<h4 id=\"加密保护\"><a class=\"anchor\" href=\"#加密保护\">#</a> 加密保护</h4>\n<p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密</p>\n<p>例如：异或加密</p>\n<p>优点：保密性强，不需要在系统中存储密码</p>\n<p>缺点：编码 / 译码，或者说加密 / 解密要花费一定时间</p>\n<h4 id=\"访问控制\"><a class=\"anchor\" href=\"#访问控制\">#</a> 访问控制</h4>\n<p>在每个文件的 FCB（或索引节点）中增加一个访问控制表，该表中记录了各个用户可以对该文件执行哪些操作</p>\n<p>对文件的访问类型可分为：读 / 写 / 执行 / 删除等</p>\n<p>实现灵活，可以实现复杂的文件保护功能</p>\n<p>精简的访问列表：以 &quot;组&quot; 为单位，标记各组用户可以对文件执行哪些操作</p>\n<p>当某用户想要访问文件时，系统会检查该用户所属的分组是否有相应的访问权限（系统需要管理分组的信息）</p>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-4-1/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-4-1/",
            "title": "计网408-4-1",
            "date_published": "2024-08-08T07:50:12.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"网络层概述\"><a class=\"anchor\" href=\"#网络层概述\">#</a> 网络层概述</h3>\n<p>网络层的主要任务是实现网络互连，进而实现数据包在各网络之间的传输</p>\n<p>要实现网络层任务，需要解决以下主要问题：</p>\n<ul>\n<li>\n<p>网络层向运输层提供怎样的服务（&quot;可靠传输服务&quot; 还是 &quot;不可靠传输服务&quot;）</p>\n</li>\n<li>\n<p>网络层寻址问题</p>\n</li>\n<li>\n<p>路由选择问题</p>\n</li>\n</ul>\n<p>因特网是目前全世界用户数量最多的互联网，它使用 TCP/IP 协议线</p>\n<p>由于 TCP/IP 协议线的网络层使用网际协议 IP 它是整个协议栈的核心协议，因此在 TCP/IP 协议栈中网络层常称为网际层</p>\n<h4 id=\"网络层提供的两种服务\"><a class=\"anchor\" href=\"#网络层提供的两种服务\">#</a> 网络层提供的两种服务</h4>\n<p><strong>面向连接的虚电路服务</strong></p>\n<p>可靠通信应由网络来保证</p>\n<p>必须建立网络层的连接 —— 虚电路 VC</p>\n<p>通信双方沿着已建立的虚电路发送分组</p>\n<p>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条虚电路的编号（构成虚电路的每一段链路都有一个虚电路编号）</p>\n<p>这种通信方式如果再使用可靠传输的网络协议，就可使所发送的分组最终正确到达接收方（无差错按序到达、不丢失、不重复）</p>\n<p>通信结束后，需要释放之间所建立的虚电路</p>\n<p>很多广域分组交换网都是用面向连接的虚电路服务</p>\n<p><strong>无连接的数据报服务</strong></p>\n<p>可靠通信应当由用户主机来保证</p>\n<p>不需要建立网络层连接</p>\n<p>每个分组可走不同的道路</p>\n<p>这种通信方式所传送的分组可能误码、丢失、重复和失序</p>\n<p>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）</p>\n<p>因特网采用这种设计思想，也就是将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心</p>\n<table>\n<thead>\n<tr>\n<th>对比方面</th>\n<th>虚电路服务</th>\n<th>数据报服务</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>思路</td>\n<td>可靠通信应当由网络来保证</td>\n<td>可靠通信应当由用户主机来保证</td>\n</tr>\n<tr>\n<td>连接的建立</td>\n<td>必须建立网络层连接</td>\n<td>不需要建立网络层的连接</td>\n</tr>\n<tr>\n<td>终点地址</td>\n<td>仅在连接建立阶段使用，每个分组使用短的虚电路号</td>\n<td>每个分组都有终点的完整地址</td>\n</tr>\n<tr>\n<td>分组的转发</td>\n<td>属于同一条虚电路的分组均按照同一路由进行转发</td>\n<td>每个分组可走不同的路由</td>\n</tr>\n<tr>\n<td>当结点出故障时</td>\n<td>所有通过出故障的结点的虚电路均不能工作</td>\n<td>出故障的结点可能丢失分组，一些路由可能会发生变化</td>\n</tr>\n<tr>\n<td>分组的顺序</td>\n<td>总是按发送顺序到达终点</td>\n<td>到达终点时不一定按发送顺序</td>\n</tr>\n<tr>\n<td>服务质量的保证</td>\n<td>可以将通信资源提前分配给每一个虚电路，容易实现</td>\n<td>很难实现</td>\n</tr>\n</tbody>\n</table>\n<p>TCP/IP 体系结构的因特网的网际层提供的是简单灵活、无连接的、尽最大努力交付的数据报服务</p>\n<h3 id=\"ipv4地址概述\"><a class=\"anchor\" href=\"#ipv4地址概述\">#</a> IPv4 地址概述</h3>\n<p>IPv4 地址就是给因特网上每一台主机（或路由器）的每一个接口分配一个全世界范围内是唯一的 32 比特的标识符</p>\n<p>IP 地址由因特网名字和数字分配机构 ICANN 进行分配</p>\n<ul>\n<li>我国用户可向亚太网络信息中心 APNIC 申请 IP 地址，需要缴费</li>\n<li>互联网号码分配管理局 IANA（由 ICANN 行使职能）宣布 IPv4 地址已经分配完毕</li>\n<li>我国逐步停止了向新用户和应用分配 IPv4 地址。同时全面开展商用部署 IPv6</li>\n</ul>\n<p>IPv4 地址的编址方法经历三个阶段：</p>\n<ul>\n<li>分类编址</li>\n<li>划分子网</li>\n<li>无分类编址</li>\n</ul>\n<p>32 比特的 IPv4 地址不方便阅读、记录以及输入等，因此 IPv4 地址采用点分十进制表示方法以方便用户使用</p>\n<p><strong>练习</strong></p>\n<p>请将以下这些 32 比特用户的 IPv4 地址转换为点分十进制形式</p>\n<ul>\n<li>00001010 11111110 00001111 11110000-&gt;10.254.15.240</li>\n<li>10101100 00010000 10111111 11110111-&gt;172.16.191.247</li>\n<li>11000000 10101000 10100101 00000111-&gt;192.168.165.7</li>\n</ul>\n<h4 id=\"分类编址的ipv4地址\"><a class=\"anchor\" href=\"#分类编址的ipv4地址\">#</a> 分类编址的 IPv4 地址</h4>\n<ul>\n<li>A 类地址\n<ul>\n<li>网络号（8 比特）+ 主机号（24 比特）</li>\n<li>网络号最高位固定为 0</li>\n<li>最小网络号 0，保留不指派</li>\n<li>第一个可指派的网络号为 1，网络地址为 1.0.0.0</li>\n<li>最大网络号为 127，作为本地环回测试地址，不指派\n<ul>\n<li>最小的本地环回测试地址为 127.0.0.1</li>\n<li>最大的本地环回测试地址为 127.255.255.254</li>\n</ul>\n</li>\n<li>最后一个可指派的网络号为 126，网络地址为 126.0.0.0</li>\n<li>可指派的 A 类网络数量为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mo stretchy=\"false\">(</mo><mn>8</mn><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>126</mn></mrow><annotation encoding=\"application/x-tex\">2^{(8-1)}-2=126</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.9713299999999999em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8879999999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mopen mtight\">(</span><span class=\"mord mtight\">8</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span><span class=\"mclose mtight\">)</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">6</span></span></span></span>，减 2 是除去最小网络号 0 和最大网络号 127</li>\n<li>每个网络可分配的 IP 地址数量为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>24</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>16777214</mn></mrow><annotation encoding=\"application/x-tex\">2^{24}-2=16777214</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">4</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mord\">7</span><span class=\"mord\">7</span><span class=\"mord\">7</span><span class=\"mord\">2</span><span class=\"mord\">1</span><span class=\"mord\">4</span></span></span></span>，减 2 是除去主机号为全 0 的网络地址和全 1 的广播地址</li>\n</ul>\n</li>\n<li>B 类地址\n<ul>\n<li>网络号（16 比特）+ 主机号（16 比特）</li>\n<li>网络号最高两位固定为 10</li>\n<li>最小网络号也是第一个可指派的网络号 128.0，网络地址为 128.0.0.0</li>\n<li>最大网络号也是最后一个可指派的网络号 191.255，网络地址为 191.255.0.0</li>\n<li>可指派的网络数量：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mn>16</mn><mo>−</mo><mn>2</mn></mrow></msup><mo>=</mo><mn>16384</mn></mrow><annotation encoding=\"application/x-tex\">2^{16-2}=16384</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span><span class=\"mord\">3</span><span class=\"mord\">8</span><span class=\"mord\">4</span></span></span></span></li>\n<li>每个网络可分配的 IP 地址数量为：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>65534</mn></mrow><annotation encoding=\"application/x-tex\">2^{16}-2=65534</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span><span class=\"mord\">5</span><span class=\"mord\">5</span><span class=\"mord\">3</span><span class=\"mord\">4</span></span></span></span>，减 2 是除去主机号为全 0 的网络地址和全 1 的广播地址</li>\n</ul>\n</li>\n<li>C 类地址\n<ul>\n<li>网络号（24 比特）+ 主机号（8 比特）</li>\n<li>网络号最高三位固定为 110</li>\n<li>最小网络号也是第一个可指派的网络号 192.0.0，网络地址为 192.0.0.0</li>\n<li>最大网络号也是最后一个可指派的网络号 223.255.255，网络地址为 223.255.255.0</li>\n<li>可指派的网络数量：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mn>24</mn><mo>−</mo><mn>3</mn></mrow></msup><mo>=</mo><mn>2097152</mn></mrow><annotation encoding=\"application/x-tex\">2^{24-3}=2097152</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">4</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord\">9</span><span class=\"mord\">7</span><span class=\"mord\">1</span><span class=\"mord\">5</span><span class=\"mord\">2</span></span></span></span></li>\n<li>每个网络可分配的 IP 地址数量为：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>254</mn></mrow><annotation encoding=\"application/x-tex\">2^{8}-2=254</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">5</span><span class=\"mord\">4</span></span></span></span>，减 2 是除去主机号为全 0 的网络地址和全 1 的广播地址</li>\n</ul>\n</li>\n<li>D 类地址\n<ul>\n<li>多播地址（32 比特）</li>\n<li>最高四位固定为 1110</li>\n</ul>\n</li>\n<li>E 类地址\n<ul>\n<li>保留为今后使用</li>\n<li>最高四位固定为 1111</li>\n</ul>\n</li>\n</ul>\n<p>注意事项：</p>\n<ul>\n<li>只有 A 类、B 类、C 类地址可分配给网络中的主机或路由器的各接口</li>\n<li>主机号为全 0 的地址是网络地址，不能分配给主机或路由器的各接口</li>\n<li>主机号为全 1 的地址是广播地址，不能分配给主机或路由器的各接口</li>\n</ul>\n<p><strong>一般不使用的 IP 地址</strong></p>\n<table>\n<thead>\n<tr>\n<th>网络号</th>\n<th>主机号</th>\n<th>作为源地址</th>\n<th>作为目的地址</th>\n<th>代表的意思</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>可以</td>\n<td>不可</td>\n<td>在本网络上的本主机（DHCP 协议）</td>\n</tr>\n<tr>\n<td>0</td>\n<td>host-id</td>\n<td>可以</td>\n<td>不可</td>\n<td>在本网络上的某台主机 host-id</td>\n</tr>\n<tr>\n<td>全 1</td>\n<td>全 1</td>\n<td>不可</td>\n<td>可以</td>\n<td>只在本网络上进行广播（各路由器均不转发）</td>\n</tr>\n<tr>\n<td>net-id</td>\n<td>全 1</td>\n<td>不可</td>\n<td>可以</td>\n<td>对 net-id 上所有主机进行广播</td>\n</tr>\n<tr>\n<td>127</td>\n<td>非全 0 或全 1</td>\n<td>可以</td>\n<td>可以</td>\n<td>用于本地软件环回测试</td>\n</tr>\n</tbody>\n</table>\n<p><strong>练习</strong></p>\n<p>1、请填写以下两个表格的内容</p>\n<table>\n<thead>\n<tr>\n<th>分类的 IP 地址</th>\n<th>类别</th>\n<th>是否可以指派给主机</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0.1.2.3</td>\n<td>A 类</td>\n<td>否（保留的网络号）</td>\n</tr>\n<tr>\n<td>1.2.3.4</td>\n<td>A 类</td>\n<td>是</td>\n</tr>\n<tr>\n<td>126.255.255.255</td>\n<td>A 类</td>\n<td>否（广播地址）</td>\n</tr>\n<tr>\n<td>127.0.0.1</td>\n<td>A 类</td>\n<td>否（本地环回测试地址）</td>\n</tr>\n<tr>\n<td>128.0.255.255</td>\n<td>B 类</td>\n<td>否（广播地址）</td>\n</tr>\n<tr>\n<td>166.16.18.255</td>\n<td>B 类</td>\n<td>是</td>\n</tr>\n<tr>\n<td>172.18.255.255</td>\n<td>B 类</td>\n<td>否（广播地址）</td>\n</tr>\n<tr>\n<td>191.255.255.252</td>\n<td>B 类</td>\n<td>是</td>\n</tr>\n<tr>\n<td>192.0.0.255</td>\n<td>C 类</td>\n<td>否（广播地址）</td>\n</tr>\n<tr>\n<td>196.2.3.8</td>\n<td>C 类</td>\n<td>是</td>\n</tr>\n<tr>\n<td>218.75.230.30</td>\n<td>C 类</td>\n<td>是</td>\n</tr>\n<tr>\n<td>223.255.255.252</td>\n<td>C 类</td>\n<td>是</td>\n</tr>\n</tbody>\n</table>\n<p>2、下列 IP 地址中，只能作为 IP 分组的源 IP 地址但不能作为目的 IP 地址的是（A）</p>\n<p>A.0.0.0.0     B.127.0.0.1      C.20.10.10.3      D.255.255.255.255</p>\n<p>解析：地址 0.0.0.0 为特殊的 IPv4 地址，只能作为源地址使用，表示 &quot;本网络上的本主机&quot;。封装有 DHCP Discovery 报文的 IP 分组的源地址 0.0.0.0；以 127 开头且后面三个字节非 &quot;全 0&quot; 或 &quot;全 1&quot; 的 IP 地址是一类特殊的 IPv4 地址，即可作为源地址使用，也可作为目的地址使用，用于本地软件环回测试；地址 255.255.255.255 是一个特殊的 IPv4 地址，只能作为目的地址使用，表示 &quot;只在本网络上进行广播（各路由器均不转发）&quot;。综上 A 正确</p>\n<h4 id=\"划分子网的ipv4地址\"><a class=\"anchor\" href=\"#划分子网的ipv4地址\">#</a> 划分子网的 IPv4 地址</h4>\n<p>为新增网络申请新的网络号会带来以下弊端：</p>\n<ul>\n<li>需要等待时间和花费更多的费用</li>\n<li>会增加其他路由器中路由表记录的数量</li>\n<li>浪费原有网络中剩余的大量 IP 地址</li>\n</ul>\n<p>从主机号部分借用一部分作为子网号</p>\n<p>32 比特的子网掩码可以表明分类 IP 地址的主机号部分被借用了几个比特作为子网号</p>\n<ul>\n<li>子网掩码使用连续的比特 1 来对应网络号和子网号</li>\n<li>子网掩码使用连续的比特 0 来对应主机号</li>\n<li>将划分子网的 IPv4 地址与相应的子网掩码进行逻辑与运算就可得到 IPv4 地址所有子网的网络地址</li>\n</ul>\n<p><strong>默认子网掩码</strong></p>\n<p>默认子网掩码是指在未划分子网的情况下使用的子网掩码</p>\n<ul>\n<li>A 类地址：255.0.0.0</li>\n<li>B 类地址：255.255.0.0</li>\n<li>C 类地址：255.255.255.0</li>\n</ul>\n<p><strong>例子</strong></p>\n<p>已知某个网络的地址为 218.75.230.0，使用子网掩码 255.255.255.128 对其进行子网划分，请给出划分细节</p>\n<p>解析：C 类网络地址 218.75.230.0，子网掩码 255.255.255.10000000，子网掩码借用了主机号的 1 位来表示子网号，因此可以划分出 2 个子网，每个子网可以有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>7</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>126</mn></mrow><annotation encoding=\"application/x-tex\">2^{7}-2=126</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">2</span><span class=\"mord\">6</span></span></span></span> 个可分配地址</p>\n<p><strong>习题</strong></p>\n<p>1、已知某个网络的地址为 218.75.230.0，使用子网掩码 255.255.255.192 对其进行子网划分，请给出划分细节</p>\n<p>解析：C 类网络地址 218.75.230.0，子网掩码 255.255.255.11000000</p>\n<p>子网掩码借用了主机号的 2 位来表示子网号，因此可以划分出 4 个子网，每个子网可以有<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>6</mn></msup><mo>−</mo><mn>2</mn><mo>=</mo><mn>62</mn></mrow><annotation encoding=\"application/x-tex\">2^6-2=62</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">6</span><span class=\"mord\">2</span></span></span></span> 个可分配地址</p>\n<p>2、某主机的 IP 地址为 180.80.77.55，子网掩码为 255.255.252.0，如该主机向其所在子网发送广播分组，则目的地址可以是（D）</p>\n<p>A.180.80.76.0          B.180.80.76.255       C.180.80.77.255        D.180.80.79.255</p>\n<p>解析：B 类网络地址：180.80.77.55，子网掩码为 255.255.11111100.0，子网掩码借用了主机号的 6 位来表示子网号，该主机属于 01001100 子网，其余 4 个均属于 01001100 子网，发送广播分组，因此目的地址应该为 180.80.79.255，选 D</p>\n<h4 id=\"无分类编址的ipv4地址\"><a class=\"anchor\" href=\"#无分类编址的ipv4地址\">#</a> 无分类编址的 IPv4 地址</h4>\n<p>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的 C 类网因为其他地址空间太小并没有得到充分使用，而因特网的 IP 地址仍在加速消耗，整个 IPv4 地址面临全部耗尽的威胁</p>\n<p>为此，因特网工程任务组 IETF 又提出了采用无分类编址的方法来解决 IP 地址紧张的问题，同时还专门成立 IPv6 工作组负责研究新版本 IP 以彻底解决 IP 地址耗尽问题</p>\n<p>无分类域间路由选择 CIDR 发布</p>\n<ul>\n<li>CIDR 消除了传统的 A 类、B 类、C 类地址，以及划分子网的概念</li>\n<li>CIDR 可以更加有效地分配 IPv4 的地址空间，并且可以在新的 IPv6 使用之前允许因特网的规模继续增长</li>\n</ul>\n<p>CIDR 使用斜线记法，或称 CIDR 记法，即在 IPv4 地址后面加上斜线 /，在斜线后面写上网络前缀所占的比特数量</p>\n<p>如：128.14.35.7/20 表名网络前缀占用的比特数量为 20，后面 12 位为主机号</p>\n<p>CIDR 实际上是将网络前缀都相同的连续的 IP 地址组成一个 CIDR 地址块</p>\n<p>只要知道 CIDR 地址块中任何一个地址，就可以直到该地址块的全部细节</p>\n<ul>\n<li>地址块的最小地址</li>\n<li>地址块的最大地址</li>\n<li>地址块中的地址数量</li>\n<li>地址块聚合某类网络（A 类、B 类或 C 类）的数量</li>\n<li>地址掩码（也可称为子网掩码）</li>\n</ul>\n<p><strong>例题</strong></p>\n<p>请给出 CIDR 地址块 128.14.35.7/20 的全部细节（最小地址，最大地址，地址数量，聚合 C 类网数量，地址掩码）</p>\n<p>解析：128.14.35.7/20-&gt;128.14.00100011.00000111，其中 128.14.0010 为网络前缀，0011.00000111 为主机号</p>\n<p>地址块最小地址为 128.14.00100000.00000000=128.14.32.0；地址块最大地址 128.14.00101111.11111111=128.14.47.255</p>\n<p>地址数量为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^{12}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span></span>；聚合 C 类网数量：<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi mathvariant=\"normal\">/</mi><msup><mn>2</mn><mn>8</mn></msup><mo>=</mo><mn>16</mn></mrow><annotation encoding=\"application/x-tex\">2^{12}/2^8=16</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">6</span></span></span></span>，一个 C 类网数量为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>8</mn></msup></mrow><annotation encoding=\"application/x-tex\">2^8</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span></span></span></span></p>\n<p>子网掩码：255.255.11110000.00000000=255.255.240.0</p>\n<p><strong>路由聚合（构造超网）</strong></p>\n<p>路由器将路由信息传递给另一个路由器，路由聚合就是将多条路由信息聚合成一条路由信息</p>\n<p>网络前缀越长，地址块越小，路由越具体</p>\n<p>若路由器查表转发分组时发现有多条路由可选，则选择网络前缀最长的那条，这称为最长前缀匹配，因为这样的路由更具体</p>\n<p><strong>习题</strong></p>\n<p>1、在子网 192.168.4.0/30 中，能接收目的的地址为 192.168.4.3 的 IP 分组的最大主机数为（C）</p>\n<p>A.0        B.1      C.2        D.4</p>\n<p>解析：192.168.4.0/30 中，一个子网能够分配 4 个地址，其中 2 个地址为网络地址与广播地址，只有两个地址可分配给主机，因此只有两台可收到。192.168.4.3 为广播地址，子网所有主机都可以收到</p>\n<p>2、某路由表中有转发接口相同的 4 条路由表项，其目的网络地址分别为 35.230.32.0/21、35.230.40.0/21、35.230.48.0/21 和 35.230.56.0/21，将 4 条路由聚合后的目的网络地址为（C）</p>\n<p>A.35.230.0.0/19        B.35.230.0.0/20     C.35.230.32.0/19      D.35.230.32.0/20</p>\n<p>解析：35.230.32.0-&gt;35.23.00100000.0；35.230.40.0-&gt;35.230.00101000.0；35.230.48.0-&gt;35.230.0011000.0；35.230.56.0-&gt;35.230.00111000.0，因此路由聚合后为 35.230.32.0/19</p>\n<h3 id=\"ipv4地址的应用规划\"><a class=\"anchor\" href=\"#ipv4地址的应用规划\">#</a> IPv4 地址的应用规划</h3>\n<p><strong>定长的子网掩码 FLSM</strong></p>\n<p>使用同一个子网掩码来划分子网</p>\n<p>每个子网所分配的 IP 地址数量相同，造成 IP 地址的浪费</p>\n<p>子网划分方式不灵活：只能划分出<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.664392em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span></span></span></span> 个子网（n 是从主机号部分借用的用来作为子网号的比特数量）</p>\n<p>每个子网所分配的 IP 地址数量相同，容易造成 IP 地址浪费</p>\n<p><strong>变长的子网掩码 VLSM</strong></p>\n<p>使用不同的子网掩码来划分子网</p>\n<p>每个子网所分配的 IP 地址数量可以不同，尽可能减少对 IP 地址的浪费</p>\n<p>子网划分方式灵活：可以按需分配</p>\n<p>分配原则：每个子块的起点位置不能随意选取，只能选取块大小整数倍的地址作为起点</p>\n<h3 id=\"ip数据报的发送和转发过程\"><a class=\"anchor\" href=\"#ip数据报的发送和转发过程\">#</a> IP 数据报的发送和转发过程</h3>\n<p>IP 数据报的发送和转发过程包含以下两部分：</p>\n<ul>\n<li>主机发送 IP 数据报\n<ul>\n<li>判断目的主机是否与自己在同一个网络（用子网掩码和 IP 地址相与获得网络地址进行判断）\n<ul>\n<li>若在同一个网络，则属于直接交付</li>\n<li>若不在同一个网络，则属于间接交付，传输给主机所在网络的默认网关（路由器），由默认网关帮忙转发</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>路由器转发 IP 数据报\n<ul>\n<li>检查 IP 数据报首部是否出错\n<ul>\n<li>若出错，则直接丢弃该 IP 数据报并通告主机</li>\n<li>若没有出错，则进行转发</li>\n</ul>\n</li>\n<li>根据 IP 数据报的目的地址在路由表中查找匹配的条目（用目的地址 IP 与路由表中的每个子网掩码相与，得到目的网络地址，比较目的网络地址与网络地址是否相同）\n<ul>\n<li>若找到匹配的条目，则转发给条目中指示的下一跳</li>\n<li>若找不到，则丢弃该 IP 数据报并通告源主机</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>习题</strong></p>\n<p>1、下列网络设备中，能够抑制广播风暴的是（D）</p>\n<p>I. 中继器      II. 集线器      III. 网桥          IV. 路由器</p>\n<p>A. 仅 I 和 II       B. 仅 II       C. 仅 III 和 IV      D. 仅 IV</p>\n<p>解析：中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域。网桥和交换机（多端口网络）工作在数据链路层，可以隔离冲突域不能隔离广播域。路由器工作在网络层，既隔离冲突域，也隔离广播域</p>\n<p>2、下列关于 IP 路由器概念的描述中，正确的是（C）</p>\n<p>I. 运行路由协议，设置路由表</p>\n<p>II. 监测到阻塞时，合理丢弃 IP 分组</p>\n<p>III. 对收到的 IP 分组头进行差错校验，确保传输的 IP 分组不丢失</p>\n<p>IV. 根据收到的 IP 分组的目的 IP 地址，将其转发到合适的输出线路上</p>\n<p>A. 仅 III、IV       B. 仅 I、II、III        C. 仅 I、II、IV      D.I、II、III、IV</p>\n<p>解析：IP 路由器工作在 TCP/IP 体系结构的网际层（或称 IP 层），TCP/IP 体系结构的网际层并不负责可靠传输，也就是不能确保传输的 IP 分组不丢失。IP 路由器对收到的 IP 分组头进行差错校验，当发现错误时会丢弃该 IP 分组并向源主机发送 ICMP 差错报告报文（类型为参数错误）。</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/fqpHFTNAVOK8jMG.png\" alt=\"习题\" /></p>\n<p>解析：主机 1 可以访问 WWW 服务器，从 IP 地址与子网掩码配置以及福利连接方面看，主机 1 和 WWW 服务器在同一网络中。但主机不能访问 Internet，因为主机 1 的网关配置成了 DHCP 服务器，DHCP 服务器不具备路由器的功能，无法将 IP 分组转发到 Internet</p>\n<h3 id=\"静态路由配置及其可能产生的路由环路问题\"><a class=\"anchor\" href=\"#静态路由配置及其可能产生的路由环路问题\">#</a> 静态路由配置及其可能产生的路由环路问题</h3>\n<p>静态路由配置是指用户或网络管理员使用路由器的相关命令给路由器人工配置路由表</p>\n<ul>\n<li>这种人工配置方式简单、开销小。但不能及时适应网络状态（流量、拓扑等）的变化</li>\n<li>一般只在小规模网络中采用</li>\n</ul>\n<p>使用静态路由配置可能出现以下导致产生路由环境的错误</p>\n<ul>\n<li>配置错误</li>\n<li>聚合了不存在的网络</li>\n<li>网络故障</li>\n</ul>\n<p>路由条目的类型：</p>\n<ul>\n<li>直连网路</li>\n<li>静态路由（人工配置）</li>\n<li>动态路由（路由选择协议）</li>\n</ul>\n<p>特殊的静态路由条目</p>\n<ul>\n<li>默认路由（目的网络为 0.0.0.0，地址掩码为 0.0.0.0）</li>\n<li>特定主机路由（目的网络为特定主机的 IP 地址，地址掩码为 255.255.255.255）</li>\n<li>黑洞路由（下一跳为 null0）</li>\n</ul>\n<p>为了防止 IP 数据报在路由环路中永久兜圈，在 IP 数据报首部设有生存时间 TTL 字段</p>\n<p>IP 数据报进入路由器后，TTL 字段值减 1，若 TTL 的值不等于 0，则被路由器转发，否则被丢弃</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-2/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-2/",
            "title": "操作系统408-3-2",
            "date_published": "2024-08-07T13:47:38.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"虚拟内存\"><a class=\"anchor\" href=\"#虚拟内存\">#</a> 虚拟内存</h3>\n<p>传统存储管理方式的特征、缺点：</p>\n<ul>\n<li>一次性：作业必须一次性全部装入内存后才能开始运行。这会造成两个问题：\n<ul>\n<li>作业太大时，不能全部装入内存，导致大作业无法运行</li>\n<li>当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降</li>\n</ul>\n</li>\n<li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源</li>\n</ul>\n<h4 id=\"虚拟内存的定义和特征\"><a class=\"anchor\" href=\"#虚拟内存的定义和特征\">#</a> 虚拟内存的定义和特征</h4>\n<p>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。</p>\n<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。</p>\n<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>\n<p>在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存（操作系统虚拟性的一个体现，实际的物理内存大小没有变，只是在逻辑上进行了扩充）</p>\n<p>虚拟内存的三个主要特征：</p>\n<ul>\n<li>多次性：无需在作业运行时一次性全部装入内存、而是允许被分成多次调入内存</li>\n<li>对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出</li>\n<li>虚拟性：在逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量</li>\n</ul>\n<h4 id=\"如何实现虚拟内存\"><a class=\"anchor\" href=\"#如何实现虚拟内存\">#</a> 如何实现虚拟内存</h4>\n<p>虚拟内存的实现需要建立在离散分配的内容管理方式基础上</p>\n<ul>\n<li>请求分页存储管理</li>\n<li>请求分段存储管理</li>\n<li>请求段页式存储管理</li>\n</ul>\n<p><strong>虚拟内存管理方式与传统的非连续分配存储管理方式区别</strong></p>\n<p>主要区别</p>\n<ul>\n<li>\n<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需的信息从外存调入内存，然后继续执行程序</p>\n</li>\n<li>\n<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>\n</li>\n</ul>\n<p>操作系统需实现功能：</p>\n<ul>\n<li>操作系统要提供请求调页 (或请求调段) 功能</li>\n<li>操作系统要提供页面置换（或段置换）的功能</li>\n</ul>\n<h3 id=\"请求分页管理方式\"><a class=\"anchor\" href=\"#请求分页管理方式\">#</a> 请求分页管理方式</h3>\n<p>请求分页存储管理与基本分页存储管理的主要区别：</p>\n<ul>\n<li>\n<p>在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需的信息从外存调入内存，然后继续执行程序</p>\n</li>\n<li>\n<p>若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存</p>\n</li>\n</ul>\n<h4 id=\"页表机制\"><a class=\"anchor\" href=\"#页表机制\">#</a> 页表机制</h4>\n<p>与基本分页管理相比，请求分页管理中，为了实现请求调页，操作系统需要知道每个页面是否已经调入内存，如果还没调入，那么也需要知道该页面在外存中的存放位置</p>\n<p>当内存空间不够时，要实现 &quot;页面置换&quot;，操作系统需要通过某些指标来决定到底换出哪个页面；有的页面没有被修改，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息</p>\n<p>请求分页存储管理的页表添加了四个字段：</p>\n<ul>\n<li>状态位（是否已调入内存）：0 为没有调入内存，1 为已调入内存</li>\n<li>访问字段（可记录最近被访问过几次，该记录上次访问的时间，供置换算法选择换出页面时参考）</li>\n<li>修改位（页面调入内存后是否被修改过）</li>\n<li>外存地址（页面在外存中的存放位置）</li>\n</ul>\n<h4 id=\"缺页中断机构\"><a class=\"anchor\" href=\"#缺页中断机构\">#</a> 缺页中断机构</h4>\n<p>在请求分页系统中，每当要访问的页面不存在时，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。</p>\n<p>此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列</p>\n<p>如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项</p>\n<p>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰，若该页面在内存期间被修改过，则需要将其写回外存，未修改过的页面不用写回外存</p>\n<p>缺页中断是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于内中断</p>\n<p>一条指令在执行过程当中，可能产生多次缺页中断</p>\n<h4 id=\"地址变换机构\"><a class=\"anchor\" href=\"#地址变换机构\">#</a> 地址变换机构</h4>\n<p>新增步骤：</p>\n<ul>\n<li>请求调页（查到页表项时进行判断）</li>\n<li>页面置换（需要调入页面，但没有空闲内存块时进行）</li>\n<li>需要修改请求页表中新增的表项</li>\n</ul>\n<p>快表中有的页面一定是在内存中的。若某个页面被换出内存，则快表中相应表项也要删除，否则可能访问错误的页面</p>\n<p>细节部分：</p>\n<ul>\n<li>只有 &quot;写指令&quot; 才需要修改 &quot;修改位&quot;。并且，一般来说只需要修改快表中的数据，只有要将快表项删除时才需要写回内存中的慢表。这样可以减少访存次数</li>\n<li>和普通的中断处理一样，缺页中断处理依然需要保留 CPU 现场</li>\n<li>需要用某种 &quot;页面置换算法&quot; 来决定一个换出页面</li>\n<li>换入 / 换出页面都需要启动慢速的 I/O 操作，可见，如果换入 / 换出太频繁，会有很大的开销</li>\n<li>页面调入内存后，需要修改慢表，同时也需要将表项复制到快表中。</li>\n<li>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：\n<ul>\n<li>查快表（未命中）—— 查慢表（发现未调入内存）—— 调页（调入的页面对应的表项会直接加入快表）—— 查快表（命中）—— 访问目标内存单元</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"页面置换算法\"><a class=\"anchor\" href=\"#页面置换算法\">#</a> 页面置换算法</h3>\n<h4 id=\"最佳置换算法opt\"><a class=\"anchor\" href=\"#最佳置换算法opt\">#</a> 最佳置换算法 OPT</h4>\n<p>最佳置换算法：每次选择淘汰的页面将是以后永不使用，或者在最长的时间内不再被访问的页面。这样可以保证最低的缺页率</p>\n<h4 id=\"先进先出置换算法fifo\"><a class=\"anchor\" href=\"#先进先出置换算法fifo\">#</a> 先进先出置换算法 FIFO</h4>\n<p>先进先出置换算法：每次选择淘汰的页面是最早进入内存的页面</p>\n<p>实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面即可。队列的最大长度取决于系统为进程分配了多少个内存块</p>\n<p>Belady 现象：当为进程分配的物理块数增大时，缺页次数不减反增的异常现象</p>\n<p>只有 FIFO 算法会产生 Belady 现象。另外，FIFO 算法虽然实现简单，但是该算法与进程实际运行时规律不适应，因为先进先入的页面也有可能最经常被访问。因此，算法性能差</p>\n<h4 id=\"最近最久未使用置换算法lru\"><a class=\"anchor\" href=\"#最近最久未使用置换算法lru\">#</a> 最近最久未使用置换算法（LRU）</h4>\n<p>最近最久未使用置换算法：每次淘汰的页面时最近最久未使用的页面</p>\n<p>实现方法：赋予每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间 t。当需要淘汰一个页面时，选择现有页面中 t 值最大的，即最近最久未使用的页面</p>\n<p>在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号，在逆向扫描过程中最后一个出现的页号就是要淘汰的页面。</p>\n<p>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大</p>\n<h4 id=\"时钟置换算法clock\"><a class=\"anchor\" href=\"#时钟置换算法clock\">#</a> 时钟置换算法（CLOCK）</h4>\n<p>最佳置换算法性能最好，但无法实现；先进先出置换算法实现简单，但算法性能差；最近最久未使用置换算法性能好，是最接近 OPT 算法性能的，但是实现起来需要专门的硬件支持，算法开销大</p>\n<p>时钟置换算法是一种性能和开销比较均衡的算法，又称 CLOCK 算法，或最近未使用算法（NRU）</p>\n<p>简单的 CLOCK 算法实现方法：为每个页面设置一个访问位，再将内存中的页面都通过链接指针链接成一个循环队列。当某页被访问时，其访问位置为 1。当需要淘汰一个页面时，只需检查页的访问位。如果是 0，就选择该页换出；如果是 1，则将它置成 0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是 1，则将这些页面的访问位依次置为 0 后，再进行第二轮扫描（第二轮扫描一定会有访问位为 0 的页面，因此简单的 CLOCK 算法选择一个淘汰页面最多会经过两轮扫描）</p>\n<h4 id=\"改进的时钟置换算法\"><a class=\"anchor\" href=\"#改进的时钟置换算法\">#</a> 改进的时钟置换算法</h4>\n<p>简单的时钟置换算法仅考虑一个页面最近是否被访问过。事实上，如果被淘汰的页面没有被修改过，就不需要执行 I/O 操作写回外存。只有被淘汰的页面被修改时，才需要写回外存。</p>\n<p>因此，除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免 I/O 操作。这就是改进的时钟置换算法的思想</p>\n<p>修改位 = 0，表示页面没有被修改过，修改位 = 1，表示页面被修改过</p>\n<p>用（访问位，修改位）的形式表示各页面的状态</p>\n<p>算法规则：将所有可能被置换的页面排成一个循环队列</p>\n<p>第一轮：从当前位置开始扫描到第一个 (0,0) 的帧用于替换。本轮扫描不修改任何标志位</p>\n<p>第二轮：若第一轮扫描失败，则重新扫描，查找第一个 (0,1) 的帧用于替换。本轮将所有扫描过的帧访问位设为 0</p>\n<p>第三轮：若第二轮扫描失败，则重新扫描，查找第一个 (0,0) 的帧用于替换。本轮扫描不修改任何标志位</p>\n<p>第四轮：若第三轮扫描失败，则重新扫描，查找第一个 (0,1) 的帧用于替换。</p>\n<p>改进型 CLOCK 置换算法选择一个淘汰页面最多会进行四轮扫描</p>\n<p>第一优先级：最近没访问，且没有修改的页面</p>\n<p>第二优先级：最近没访问，但修改过的页面</p>\n<p>第三优先级：最近访问了，但没有修改的页面</p>\n<p>第四优先级：最近访问了，且有修改的页面</p>\n<h3 id=\"页面分配策略-抖动-工作集\"><a class=\"anchor\" href=\"#页面分配策略-抖动-工作集\">#</a> 页面分配策略、抖动、工作集</h3>\n<h4 id=\"页面分配-置换策略\"><a class=\"anchor\" href=\"#页面分配-置换策略\">#</a> 页面分配、置换策略</h4>\n<p>驻留集：指请求分页存储管理中给进程分配的物理块的集合</p>\n<p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p>\n<p>若驻留集太小，会导致缺页频繁，系统要花大量时间来处理缺页，实际用于进程推进的时间很少；驻留集太大又会导致多道程序并发度下降，资源利用率降低。所以应选择一个合适的驻留集大小</p>\n<p>固定分配：操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变，即：驻留集大小不变</p>\n<p>可变分配：先为每个进程分配一定数目的物理块，在进程运行过程期间，可根据情况做适当的增加或减少，即，驻留集大小可变</p>\n<p>局部置换：发生缺页时只能选进程自己的物理块进行置换</p>\n<p>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程</p>\n<p>注意：全局置换意味着一个进程拥有的物理块数量必然会改变，因此不可能是固定分配</p>\n<p><strong>固定分配局部置换</strong></p>\n<p>系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面，这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。（采用这种策略的系统可以根据进程大小、优先级，或是根据程序员给出的参数来确定为一个进程分配的内存块数）</p>\n<p><strong>可变分配全局置换</strong></p>\n<p>刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出，被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。（系统会锁定一些页面，这些页面中的内容不能置换出外存，如重要的内核数据可以设为锁定）</p>\n<p><strong>可变分配局部置换</strong></p>\n<p>刚开始为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行过程中缺页率特别低，则可适当减少分配给该进程的物理块</p>\n<p>可变分配全局置换：只要缺页就分配新的物理块</p>\n<p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</p>\n<h4 id=\"何时调入页面\"><a class=\"anchor\" href=\"#何时调入页面\">#</a> 何时调入页面</h4>\n<ul>\n<li>\n<p>预调页策略：根据局部性原理（主要指空间局部性），一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有 50% 左右。故这种策略主要用于进程的首次调入（运行前调入），由程序员指出应该先调入哪些部分</p>\n</li>\n<li>\n<p>请求调页策略：进程在运行期间发现缺页时才将所缺页面调入内存。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘 I/O 操作，因此 I/O 开销较大</p>\n</li>\n</ul>\n<h4 id=\"从何处调入页面\"><a class=\"anchor\" href=\"#从何处调入页面\">#</a> 从何处调入页面</h4>\n<p>外存：</p>\n<ul>\n<li>\n<p>对换区：读 / 写速度更快，采用连续分配方式</p>\n</li>\n<li>\n<p>文件区：读 / 写速度更慢，采用离散分配方式</p>\n</li>\n</ul>\n<p>1、系统拥有足够的对换区空间：页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前，需将进程相关的数据从文件区复制到对换区</p>\n<p>2、系统缺少足够的对换区空间：凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入</p>\n<p>3、UNIX 方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可以从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</p>\n<h4 id=\"抖动颠簸现象\"><a class=\"anchor\" href=\"#抖动颠簸现象\">#</a> 抖动（颠簸）现象</h4>\n<p>刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为抖动，或颠簸。产生抖动的主要原因是进程频繁访问的页面数目高于可用的物理块数（分配给进程的物理块不够）</p>\n<p>工作集：指在某段时间间隔里，进程实际访问页面的集合</p>\n<p>操作系统会根据窗口尺寸计算工作集</p>\n<p>工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。</p>\n<p>一般来说，驻留集的大小不能小于工作集大小，否则进程运行过程中将频繁缺页</p>\n<p>拓展：基于局部性原理可知，进程在一段时间内访问的页面与不久之后会访问的页面是由相关性的。因此，可以根据进程近期访问的页面集合（工作集）来设计一种页面置换算法 —— 选择一个不在工作集中的页面进行淘汰</p>\n<h3 id=\"内存映射文件\"><a class=\"anchor\" href=\"#内存映射文件\">#</a> 内存映射文件</h3>\n<p>内存映射文件 —— 操作系统向上层程序员提供的功能（系统调用）</p>\n<ul>\n<li>方便程序员访问文件数据</li>\n<li>方便多个进程共享同一个文件</li>\n</ul>\n<p><strong>传统的文件访问方式</strong></p>\n<ul>\n<li>\n<p>open 系统调用 —— 打开文件</p>\n</li>\n<li>\n<p>seek 系统调用 —— 将读写指针移到某个位置</p>\n</li>\n<li>\n<p>read 系统调用 —— 从读写指针所指位置读入若干数据（从磁盘读入内容）</p>\n</li>\n<li>\n<p>write 系统调用 —— 将内存中的指定数据，写回磁盘（根据读写指针确定要写回什么位置）</p>\n</li>\n</ul>\n<p><strong>内存映射文件</strong></p>\n<ul>\n<li>open 系统调用 —— 打开文件</li>\n<li>mmap 系统调用 —— 将文件映射到进程的虚拟地址空间</li>\n</ul>\n<p>特性：</p>\n<ul>\n<li>\n<p>以访问内存的方式访问文件数据</p>\n</li>\n<li>\n<p>以文件数据的读入、写出由操作系统自动完成</p>\n</li>\n<li>\n<p>进程关闭文件时，操作系统自动将文件被修改的数据写回磁盘</p>\n</li>\n<li>\n<p>多个进程可以映射同一个文件，实现共享</p>\n</li>\n</ul>\n<p>在物理内存中，一个文件对应同一份数据，当一个进程修改文件数据时，另一个进程可以立马 &quot;看到&quot;</p>\n<p>优点：</p>\n<ul>\n<li>程序员编程更简单，已建立映射的文件，只需按访问内存的方式读写即可</li>\n<li>文件数据的读入 / 写出完全由操作系统负责优化</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-2/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-2/",
            "title": "计网408-3-2",
            "date_published": "2024-08-07T07:51:27.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"mac地址-ip地址以及arp协议\"><a class=\"anchor\" href=\"#mac地址-ip地址以及arp协议\">#</a> MAC 地址、IP 地址以及 ARP 协议</h3>\n<p>MAC 地址是以太网的 MAC 子层所使用的地址（数据链路层）</p>\n<p>IP 地址是 TCP/IP 体系结构网际层所使用的地址（网际层）</p>\n<p>ARP 协议属于 TCP/IP 体系结构的网际层，其作用是已知设备所分配到的 IP 地址，使用 ARP 协议可以通过该 IP 地址获取到设备的 MAC 地址（网际层）</p>\n<p>尽管 IP 地址和 ARP 协议属于 TCP/IP 体系结构的网际层 (而不属于数据链路层)，但是它们与 MAC 地址存在一定的关系，并且日常网络应用都离不开 MAC 地址、IP 地址与 ARP 协议</p>\n<h4 id=\"mac地址\"><a class=\"anchor\" href=\"#mac地址\">#</a> MAC 地址</h4>\n<p>使用点对点信道的数据链路层不需要使用地址</p>\n<p>使用广播信道的数据链路层必须使用地址来区分各主机</p>\n<p>当多个主机连接在同一个广播信道上，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址</p>\n<p>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址，由于这类地址是用于媒体接入控制 MAC，因此这类地址被称为 MAC 地址</p>\n<ul>\n<li>MAC 地址一般被固化在网卡 (网卡适配器) 的电可擦可编程只读存储器 EEPROM 中，因此 MAC 地址也被称为硬件地址</li>\n<li>MAC 地址有时也被称为物理地址。请注意：这并不意味着 MAC 地址属于网络体系结构中的物理层</li>\n</ul>\n<p>一般情况下，用户主机会包含两个网络适配器：有线局域网卡（有线网卡）和无线局域网卡（无线网卡），每个网络适配器都有一个全球唯一的 MAC 地址。而交换机和路由器往往拥有更多的网络接口，所以会有更多的 MAC 地址。综上所述，严格来说，MAC 地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识</p>\n<p><strong>IEEE 802 局域网的 MAC 地址格式</strong></p>\n<p>一共 48 个比特</p>\n<p>前三个字节：组织唯一标识符 OUI（由 IEEE 的注册管理结构分配）</p>\n<p>后三个字节：网络接口标识符（由获得 OUI 的厂商自行随意分配）</p>\n<p>扩展的唯一标识符 EUI，对于 48 比特 MAC 地址，可称为 EUI-48</p>\n<p>MAC 地址标准表示方法：将每 4 个比特写成一个十六进制字符，一共 12 个十六进制字符，每两个字符一组，共六组，组之间用短线连接</p>\n<p>其他表示方法：将组之间的短线改为冒号；还可以将四个字符分为一组，组之间用点链接</p>\n<p>例如：00-0C-CF-93-8C-92；00:0C:CF:93:8C:92；000C.CF93.8C92</p>\n<p>第一字节位分布：b7,b6,b5,b4,b3,b2,b1,b0</p>\n<table>\n<thead>\n<tr>\n<th>第一字节 b1 位</th>\n<th>第一字节的 b0 位</th>\n<th>MAC 地址类型</th>\n<th>地址数据占比</th>\n<th>总地址数量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td>0</td>\n<td>全球管理，单播地址，厂商生产网络设备（网卡，交换机，路由器）时固化</td>\n<td>四分之一</td>\n<td>2 的 48 次方</td>\n</tr>\n<tr>\n<td>0</td>\n<td>1</td>\n<td>全球管理，多播地址，标准网络设备所支持的多播地址，用于特定功能</td>\n<td>四分之一</td>\n<td>2 的 48 次方</td>\n</tr>\n<tr>\n<td>1</td>\n<td>0</td>\n<td>本地管理，单播地址，由网络管理员分配，覆盖网络接口的全球管理单播地址</td>\n<td>四分之一</td>\n<td>2 的 48 次方</td>\n</tr>\n<tr>\n<td>1</td>\n<td>1</td>\n<td>本地管理，多播地址，用户对主机的软件配置，以表明主机属于哪些多播组。注意：剩余 46 比特全为 1 时，就是 MAC 地址 48 比特全为 1，就是广播地址</td>\n<td>四分之一</td>\n<td>2 的 48 次方</td>\n</tr>\n</tbody>\n</table>\n<p>对于使用 EUI-48 空间的应用程序，IEEE 的目标寿命为 100 年（直到 2080），但鼓励采用 EUI-64 作为替代</p>\n<p><strong>IEEE 802 局域网的 MAC 地址发送顺序</strong></p>\n<p>字节位分布：b7,b6,b5,b4,b3,b2,b1,b0</p>\n<p>字节发送顺序：第一字节 -&gt; 第六字节</p>\n<p>字节内的比特发送顺序：b0-&gt;b7</p>\n<p><strong>例题</strong></p>\n<p>下列选项中，不属于物理层接口规范定义范畴的是（C）</p>\n<p>A. 接口形状       B. 引脚功能          C. 物理地址            D. 信号电平</p>\n<p>解析：物理地址即 MAC 地址属于数据链路层</p>\n<h4 id=\"ip地址\"><a class=\"anchor\" href=\"#ip地址\">#</a> IP 地址</h4>\n<p>IP 地址是因特网上主机和路由器所使用的地址，用于标识两部分信息：</p>\n<ul>\n<li>网络编号：标识因特网上数以百万计的网络</li>\n<li>主机编号：标识同一网络上不同主机（或各路由各接口）</li>\n</ul>\n<p>MAC 地址不具备区分不同网络的功能</p>\n<ul>\n<li>如果只是一个单独的网络，不接入因特网，可以只使用 MAC 地址（这不是一般用户的应用方式）</li>\n<li>如果主机所在的网络都要接入因特网，则 IP 地址和 MAC 地址都需要使用</li>\n</ul>\n<p><strong>从网络体系结构看 IP 地址与 MAC 地址</strong></p>\n<p>网络层首部应封装了源 IP 地址和目的 IP 地址</p>\n<p>数据链路层首部应封装了源 MAC 地址和目的 MAC 地址</p>\n<p><strong>数据包转发过程中 IP 地址与 MAC 地址的变化</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/08/GlM1vc2Z5TFtu69.png\" alt=\"数据包的转发\" /> -</p>\n<p>数据包转发过程中源 IP 地址和目的 IP 地址保持不变</p>\n<p>数据包转发过程中源 MAC 地址和目的 MAC 地址逐个链路 (或逐个网络) 改变</p>\n<p><strong>习题</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/08/gDaCkRVGlFiOcqE.png\" alt=\"习题\" /></p>\n<p>解析：由于源 MAC 地址和目的 MAC 地址在逐个链路中传输时都需要改变，因此，H1 发出的目的 MAC 地址应该为 00-1a-2b-3c-4d-51，H2 收到的源 MAC 地址应该为 00-a1-b2-c3-d4-61，选 D</p>\n<h4 id=\"arp协议\"><a class=\"anchor\" href=\"#arp协议\">#</a> ARP 协议</h4>\n<ul>\n<li>源主机在自己的 ARP 高速缓存表中查找目的主机的 IP 地址所对应的 MAC 地址，若找到了，则可以封装 MAC 帧进行发送；若找不到，则发送 ARP 请求（封装在广播 MAC 帧中）</li>\n<li>目的主机收到 ARP 请求后，将源主机的 IP 地址与 MAC 地址记录到自己的 ARP 高速缓存中，然后给源主机发送 ARP 响应（封装在单播 MAC 帧中），ARP 响应中包含有目的主机的 IP 地址和 MAC 地址</li>\n<li>源主机收到 ARP 响应后，将目的主机的 IP 地址与 MAC 地址记录到自己的 ARP 高速缓存表中，然后就可以封装之前想发送的 MAC 帧并发送给目的主机</li>\n<li>ARP 的作用范围：逐段链路或逐个网络使用</li>\n<li>除 ARP 请求和响应外，ARP 还有其他类型的报文（例如用于检查 IP 地址冲突的 &quot;无故 ARP、免费 ARP&quot;）</li>\n<li>ARP 没有安全验证机制，存在 ARP 欺骗（攻击）问题</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>ARP 高速缓存的记录分为两种类型\n<ul>\n<li>动态：自动获取，生命周期默认为两分钟</li>\n<li>静态：手工设置，不同操作系统下生命周期不同，例如系统重启后不存在或系统重启后依然有效</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"集线器与交换机区别\"><a class=\"anchor\" href=\"#集线器与交换机区别\">#</a> 集线器与交换机区别</h3>\n<ul>\n<li>早期的总线型以太网（淘汰）</li>\n<li>使用双绞线和集线器 HUB 的星型以太网\n<ul>\n<li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是 CSMA/CD 协议</li>\n<li>集线器只工作在物理层，它的每个接口仅简单地转发比特，不进行碰撞检测（由各站的网卡检测）</li>\n<li>集线器一般都有少量的容错能力和网络管理功能</li>\n</ul>\n</li>\n<li>使用集线器 HUB 在物理层扩展以太网</li>\n</ul>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/YsDPjt8plrbI4oM.png\" alt=\"集线器扩展以太网\" /></p>\n<ul>\n<li>以太网交换机\n<ul>\n<li>以太网交换机通常由多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在全双工方式（发送帧和接受帧可以同时进行）</li>\n<li>以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用 CSMA/CD 协议）</li>\n<li>以太网交换机一般都具有多种速率的接口</li>\n<li>以太网交换机工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找帧的目的 MAC 地址所对应的接口号，然后通过该接口转发帧</li>\n<li>以太网交换机是一种即插即用设备，其内部的帧交换表时通过自学习算法自动地逐渐建立起来的</li>\n<li>帧有两种转发方式\n<ul>\n<li>存储转发</li>\n<li>直通交换：采用基于硬件的交叉矩阵（交换时延非常小，但不检查帧是否有差错）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>对比集线器和交换机</strong></p>\n<ul>\n<li>集线器 HUB\n<ul>\n<li>早期以太网的互连设备</li>\n<li>工作在 OSI 体系结构的物理层</li>\n<li>对接收到的信号进行放大、转发</li>\n<li>使用集线器作为互联网的以太网仍属于共享总线式以太网、集线器互连起来的所有主机共享总线带宽，属于同一个碰撞域和广播域</li>\n</ul>\n</li>\n<li>交换机 SWITCH\n<ul>\n<li>目前以太网使用最广泛的互连设备</li>\n<li>工作在 OSI 体系结构的数据链路层（也包括物理层）</li>\n<li>根据 MAC 地址对帧进行转发</li>\n<li>使用交换机作为互连设备的以太网，称为交换机以太网。交换机可以根据 MAC 地址过滤帧，即隔离碰撞域</li>\n<li>交换机的每个接口是一个独立的碰撞域</li>\n<li>交换机隔离碰撞域但不隔离广播域（VLAN 除外）</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"以太网交换机自学习和转发帧的流程\"><a class=\"anchor\" href=\"#以太网交换机自学习和转发帧的流程\">#</a> 以太网交换机自学习和转发帧的流程</h3>\n<p>以太网工作在数据链路层（也包括物理层）</p>\n<p>以太网交换机收到帧后，在帧交换表中查找帧的目的 MAC 地址所对应的接口号，然后通过该接口转发帧</p>\n<p>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表时空的，随着网络中各主机的通信，以太网交换机通过自学习算法自动逐渐建立起帧交换表</p>\n<p>以太网交换机自学习和转发帧的流程：</p>\n<ul>\n<li>收到帧后进行登记，登记的内容为帧的源 MAC 地址及进入交换机的接口号</li>\n<li>根据帧的目的 MAC 地址和交换机的帧交换表对帧进行转发，有以下三种情况：\n<ul>\n<li>明确转发：交换机知道应当从哪个 (或哪些) 接口转发该帧（单播、多播、广播）</li>\n<li>盲目转发：交换机不知道应当从哪个端口转发帧，只能将其通过除进入交换机的接口外的其他所有接口转发（也称为泛洪）</li>\n<li>明确丢弃：交换机知道不应该转发该帧，将其丢弃</li>\n</ul>\n</li>\n<li>帧交换表的每条记录都有自己的有效时间，到期删除，原因如下：\n<ul>\n<li>交换机的接口改接了另一台主机</li>\n<li>主机更换了网卡</li>\n</ul>\n</li>\n</ul>\n<p><strong>习题</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/qYpafbjT5DK3Fr4.png\" alt=\"习题\" /></p>\n<p>解析：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>交换机 1</th>\n<th>交换机 2</th>\n<th>交换机 3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>B-&gt;C</td>\n<td>登记，盲目转发（B,2）</td>\n<td>登记，盲目转发（B,2）</td>\n<td>登记，盲目转发（B,2）</td>\n</tr>\n<tr>\n<td>D-&gt;A</td>\n<td>登记，盲目转发（D,4）</td>\n<td>登记，盲目转发（D,1）</td>\n<td>登记，盲目转发（D,2）</td>\n</tr>\n<tr>\n<td>G-&gt;D</td>\n<td>收不到</td>\n<td>登记（G,4），明确转发 1</td>\n<td>登记（G,4），明确转发 2</td>\n</tr>\n<tr>\n<td>E-&gt;H</td>\n<td>登记（E,4），盲目转发</td>\n<td>登记（E,3），盲目转发</td>\n<td>登记（E,2），盲目转发</td>\n</tr>\n<tr>\n<td>C-&gt;B</td>\n<td>登记（C,3），明确转发 2</td>\n<td>收不到</td>\n<td>收不到</td>\n</tr>\n<tr>\n<td>F-&gt;G</td>\n<td>收不到</td>\n<td>收不到</td>\n<td>登记（F,1），明确转发 4</td>\n</tr>\n</tbody>\n</table>\n<p>2、以太网交换机进行转发决策时使用的 PDU 地址是（A）</p>\n<p>A. 明确物理地址     B. 目的 IP 地址        C. 源物理地址    D. 源 IP 地址</p>\n<p>解析：PDU 是协议数据单元，它是计算机网络体系结构中对等实体间逻辑通信的对象。以太网交换机工作在数据链路层（也包括物理层），它接收并转发的 PDU 通常称为帧。以太网交换机收到帧后，在帧交换表中查找帧的目的 MAC 地址所对应的接口号，然后通过该接口转发帧</p>\n<p>3、</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/5uYDJMC1qijsrXw.png\" alt=\"习题\" /></p>\n<p>解析：选 B，第一次发送数据帧到达交换机时，交换机中没有目的信息，因此盲目转发，转发给 2 和 3，并进行登记，当发送的确认帧到达交换机时，由于上一次已经登记，因此，交换机知道把确认帧转发给端口 1。</p>\n<h3 id=\"以太网交换机的生成树协议stp\"><a class=\"anchor\" href=\"#以太网交换机的生成树协议stp\">#</a> 以太网交换机的生成树协议 STP</h3>\n<ul>\n<li>\n<p>如何提高以太网的可靠性</p>\n</li>\n<li>\n<p>添加冗余链路可以提高以太网的可靠性</p>\n</li>\n<li>\n<p>但是，冗余链路也会带来负面效应 —— 形成网络环路</p>\n</li>\n<li>\n<p>网络环路会带来以下问题：</p>\n<ul>\n<li>广播风暴\n<ul>\n<li>大量消耗网络资源，使得网络无法正常转发其他数据帧</li>\n</ul>\n</li>\n<li>主机收到重复的广播帧\n<ul>\n<li>大量消耗主机资源</li>\n</ul>\n</li>\n<li>交换机的帧交换表震荡（漂移）</li>\n</ul>\n</li>\n<li>\n<p>以太网交换机使用生成树协议 STP，可以增加冗余链路来提高网络可靠性的同时又避免网络环境带来的各种问题</p>\n<ul>\n<li>不论交换机之间采用怎样的物理连接，交换机能够自动计算并构造一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树形的（无逻辑环路）</li>\n<li>最终生成的树形逻辑拓扑要确保连通整个网络</li>\n<li>当首次连接交换机或网络拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"虚拟局域网vlan概述\"><a class=\"anchor\" href=\"#虚拟局域网vlan概述\">#</a> 虚拟局域网 VLAN 概述</h3>\n<ul>\n<li>\n<p>以太网交换机工作在数据链路层（也包括物理层）</p>\n</li>\n<li>\n<p>使用一个或多个以太网交换机互连起来的交换式以太网，其所有站点都属于同一个广播域</p>\n</li>\n<li>\n<p>随着交换式以太网规模的扩大，广播域相应扩大</p>\n</li>\n<li>\n<p>巨大的广播域会带来很多弊端</p>\n<ul>\n<li>广播风暴：浪费网络资源和各主机的 CPU 资源</li>\n<li>难以管理和维护</li>\n<li>潜在的安全问题</li>\n</ul>\n</li>\n</ul>\n<p>网络中会频繁出现广播信息</p>\n<ul>\n<li>TCP/IP 协议栈中的很多协议都会使用广播\n<ul>\n<li>地址解析协议 ARP（已知 IP 地址，找出其相应的 MAC 地址）</li>\n<li>路由信息协议 RIP（一种小型的内部路由协议）</li>\n<li>动态主机配置协议 DHCP（用于自动配置 IP 地址）</li>\n</ul>\n</li>\n<li>NetBEUI：Windows 下使用的广播型协议</li>\n<li>IPX/SPX：Novell 网络的协议栈</li>\n<li>Apple Talk：Apple 公司的网络协议栈</li>\n</ul>\n<p>分割广播域的方法：</p>\n<ul>\n<li>使用路由器可以隔离广播域\n<ul>\n<li>路由器的成本较高</li>\n<li>虚拟局域网 VLAN 技术应运而生</li>\n</ul>\n</li>\n</ul>\n<p>虚拟局域网 VLAN 是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求</p>\n<h3 id=\"虚拟局域网vlan的实现机制\"><a class=\"anchor\" href=\"#虚拟局域网vlan的实现机制\">#</a> 虚拟局域网 VLAN 的实现机制</h3>\n<h4 id=\"ieee-8021q帧\"><a class=\"anchor\" href=\"#ieee-8021q帧\">#</a> IEEE 802.1Q 帧</h4>\n<p>IEEE 802.1Q 帧对以太网的 MAC 帧格式进行了扩展，插入了 4 字节的 VLAN 标记</p>\n<p>VLAN 标记的最后 12 比特称为 VLAN 标识符 VID，它唯一地标志了以太网帧属于哪一个 VLAN</p>\n<ul>\n<li>VID 的取值范围为 0-4095</li>\n<li>0 和 4095 都不用来表示 VLAN，因此用于表示 VLAN 的 VID 的有效取值范围是 1-4094</li>\n</ul>\n<p>802.1Q 帧是由交换机来处理的，而不是用户主机来处理的</p>\n<ul>\n<li>当交换机收到普通的以太网帧时，会将其插入 4 字节的 VLAN 标记转变为 802.1Q 帧，简称 &quot;打标签&quot;</li>\n<li>当交换机转发 802.1Q 帧时，可能会删除其 4 字节 VLAN 标记转变为普通以太网帧，简称 &quot;去标签&quot;</li>\n</ul>\n<h4 id=\"交换机的端口类型\"><a class=\"anchor\" href=\"#交换机的端口类型\">#</a> 交换机的端口类型</h4>\n<p>交换机的端口类型有以下三种</p>\n<ul>\n<li>\n<p>Access</p>\n<ul>\n<li>Access 端口一般用于连接用户计算机</li>\n<li>Access 端口只能属于一个 VLAN</li>\n<li>Access 端口的 PVID 值与端口所属 VLAN 的 ID 想通（默认为 1）</li>\n<li>Access 端口接收处理方法：\n<ul>\n<li>一般只接受 &quot;未打标签&quot; 的普通以太网 MAC 帧，根据接收的端口 PVID 给帧 &quot;打标签&quot;，即插入 4 字节 VLAN 标记字段，字段中的 VID 取值与端口的 PVID 取值相等</li>\n</ul>\n</li>\n<li>Access 端口发送处理方法：\n<ul>\n<li>若帧中 VID 与端口的 PVID 相等，则 &quot;去标签&quot; 并转发该帧，否则不转发</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Trunk</p>\n<ul>\n<li>\n<p>Trunk 端口一般用于交换机之间或交换机与路由器之间的互连</p>\n</li>\n<li>\n<p>Trunk 端口可以属于多个 VLAN</p>\n</li>\n<li>\n<p>用户可以设置 Trunk 端口的 PVID 值。默认情况下，Trunk 端口的 PVID 值为 1</p>\n</li>\n<li>\n<p>Trunk 端口发送处理方法：</p>\n<ul>\n<li>对 VID 等于 PVID 的帧，&quot;去标签&quot; 再转发</li>\n<li>对 VID 不等于 PVID 的帧，直接转发</li>\n</ul>\n</li>\n<li>\n<p>Trunk 端口接收处理方法：</p>\n<ul>\n<li>接收 &quot;未打标签&quot; 的帧，根据接收帧的端口的 PVID 给帧 &quot;打标签&quot;，即插入 4 字节 VLAN 标记字段，字段中的 VID 取值与端口的 PVID 取值相等</li>\n<li>接收 &quot;已打标签&quot; 的帧</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>Hybrid</p>\n<ul>\n<li>Hybrid 端口即可用于交换机之间或交换机与路由器之间的互连（同 Trunk 端口），也可用于交换机与用户计算机之间的互连（同 Access 端口）</li>\n<li>Hybrid 端口可以属于多个 VLAN（同 Trunk 端口）</li>\n<li>用户可以设置 Hybrid 端口的 PVID 值，默认情况下，Hybrid 端口的 PVID 值为 1（同 Trunk 端口）</li>\n<li>Hybrid 端口发送处理方法（与 Trunk 端口不同）\n<ul>\n<li>查看帧的 VID 是否在端口的 &quot;去标签&quot; 列表中：</li>\n<li>若存在，则 &quot;去标签&quot; 后再转发</li>\n<li>若不存在，则直接转发</li>\n</ul>\n</li>\n<li>Hybrid 端口接收处理方法（同 Trunk 端口）：\n<ul>\n<li>接收 &quot;未打标签&quot; 的帧，根据接收帧的端口的 PVID 给帧 &quot;打标签&quot;，即插入 4 字节 VLAN 标记字段，字段中的 VID 取值与端口的 PVID 取值相等</li>\n<li>接收 &quot;已打标签&quot; 的帧</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>交换机各端口的缺省 VLAN ID</p>\n<ul>\n<li>在思科交换机上称为本征 VLAN</li>\n<li>在华为交换机上称为 Port VLAN ID，即端口 VLAN ID，简记为 PVID</li>\n</ul>\n<p><strong>习题</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/8hsubGow4FHnpaI.png\" alt=\"习题\" /></p>\n<p>解析：</p>\n<p>第一题：</p>\n<ul>\n<li>A 发送广播帧，被 G,H 错误接收，被 B 正确接收</li>\n<li>A 发送广播帧，被 B,E,F 正确接收</li>\n<li>A 发送广播帧，被 B,E,F 正确接收</li>\n<li>A 发送广播帧，被 B,E,F 正确接收</li>\n</ul>\n<p>第二题：</p>\n<ul>\n<li>\n<p>C 发送广播帧，被 D,G,H 正确接收</p>\n</li>\n<li>\n<p>C 发送广播帧，被 E,F 错误接收，被 D 正确接收</p>\n</li>\n<li>\n<p>C 发送广播帧，被 D,G,H 正确接收</p>\n</li>\n<li>\n<p>C 发送广播帧，被 D,G,H 正确接收</p>\n</li>\n</ul>\n<p>结论：互连的 Trunk 端口的 PVID 值不等，可能会造成转发错误</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/",
            "title": "操作系统408-3-1",
            "date_published": "2024-08-05T13:53:38.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"内存的基本知识\"><a class=\"anchor\" href=\"#内存的基本知识\">#</a> 内存的基本知识</h3>\n<p>内存可存放数据。程序执行前需要先放到内存中才能被 CPU 处理 —— 缓和 CPU 和硬盘之间的速度矛盾</p>\n<p>内存被分为了很多存储单元，内存地址从 0 开始，每个地址对应一个存储单元</p>\n<p>如果计算机 &quot;按字节编址&quot;，则每个存储单元大小为 1 字节，即 1B，8 个二进制位</p>\n<p>如果字长为 16 位的计算机 &quot;按字编址&quot;，则每个存储单元大小为 1 个字，每个字的大小为 16 个二进制位</p>\n<p><strong>补充</strong></p>\n<p 30=\"\">1K=2^{10},1M=2^{20},1G=2^</p>\n<p>逻辑地址 -&gt; 物理地址</p>\n<p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</p>\n<p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p>\n<p>装入（装载）：由装入程序将装入模块装入内存运行</p>\n<p><strong>三种装入方法</strong></p>\n<ul>\n<li>绝对装入\n<ul>\n<li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存</li>\n<li>编译、链接后得到的装入模块的指令直接就使用了绝对地址，即在编译时把逻辑地址转为物理地址</li>\n<li>绝对装入只适用于单道程序环境</li>\n</ul>\n</li>\n<li>可重定位装入（静态重定位）\n<ul>\n<li>编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行 &quot;重定位&quot;，将逻辑地址变换为物理地址 (地址变换是装入时一次完成的)</li>\n<li>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业</li>\n<li>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间</li>\n</ul>\n</li>\n<li>动态运行时装入（动态重定位）\n<ul>\n<li>编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持</li>\n<li>重定位寄存器：存放装入模块存放的起始位置</li>\n<li>采用动态重定位时允许程序在内存中发生移动</li>\n<li>可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li>\n</ul>\n</li>\n</ul>\n<p><strong>链接的三种方式</strong></p>\n<ul>\n<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开</li>\n<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li>\n<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享</li>\n</ul>\n<h3 id=\"内存管理\"><a class=\"anchor\" href=\"#内存管理\">#</a> 内存管理</h3>\n<p>内存空间的分配与回收</p>\n<ul>\n<li>操作系统负责内存空间的分配与回收</li>\n</ul>\n<p>内存空间的扩充（实现虚拟性）</p>\n<ul>\n<li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li>\n</ul>\n<p>地址转换</p>\n<ul>\n<li>操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换\n<ul>\n<li>为了让编程人员更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</li>\n</ul>\n</li>\n</ul>\n<p>存储保护：</p>\n<ul>\n<li>\n<p>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</p>\n</li>\n<li>\n<p>内存保护可采取两种方法：</p>\n<ul>\n<li>在 CPU 上设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界</li>\n<li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"覆盖与交换\"><a class=\"anchor\" href=\"#覆盖与交换\">#</a> 覆盖与交换</h3>\n<p><strong>覆盖技术</strong></p>\n<p>覆盖技术：解决程序大小超过物理内存总和的问题</p>\n<p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存</p>\n<p>内存中分为一个 &quot;固定区&quot; 和若干个 &quot;覆盖区&quot;。</p>\n<p>需要常驻内存的段放在 &quot;固定区&quot; 中，调入后就不再调出 (除非运行结束)</p>\n<p>不常用的段放在 &quot;覆盖区&quot;，需要用到时调入内存，用不到时调出内存</p>\n<p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。</p>\n<p>覆盖技术只用于早期的操作系统中，现在已成为历史</p>\n<p><strong>交换技术</strong></p>\n<p>交换 (对换) 技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存 (进程在内存与磁盘间动态调度)</p>\n<p>中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存</p>\n<ul>\n<li>\n<p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分，文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的 I/O 速度比文件区更快</p>\n</li>\n<li>\n<p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。</p>\n</li>\n<li>\n<p>可优先换出阻塞进程，可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间</p>\n</li>\n</ul>\n<p>注意：PCB 会常驻内存，不会被换出外存</p>\n<h3 id=\"连续分配管理方式\"><a class=\"anchor\" href=\"#连续分配管理方式\">#</a> 连续分配管理方式</h3>\n<p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p>\n<h4 id=\"单一连续分配\"><a class=\"anchor\" href=\"#单一连续分配\">#</a> 单一连续分配</h4>\n<p>在单一连续分配方式中，内存被分为系统区和用户区</p>\n<p>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据</p>\n<p>内存中只能有一道用户程序，用户程序独占整个用户区空间</p>\n<p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护</p>\n<p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低</p>\n<ul>\n<li>内部碎片：分配给某进程的内存区域当中，没有被用上的某些部分就是内部碎片</li>\n</ul>\n<h4 id=\"固定分区分配\"><a class=\"anchor\" href=\"#固定分区分配\">#</a> 固定分区分配</h4>\n<p>为了能在内存中装入多道程序，且这些程序又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成最早的、最简单的一种可运行多道程序的内存管理方式</p>\n<ul>\n<li>分区大小相等\n<ul>\n<li>缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合</li>\n</ul>\n</li>\n<li>分区大小不等\n<ul>\n<li>增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区，适量中分区，少量大分区）</li>\n</ul>\n</li>\n</ul>\n<p>操作系统需要建立一个数据结构 —— 分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）</p>\n<p>当某用户程序要装入内存时，由操作系统内核程序根据用户大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为 &quot;已分配&quot;</p>\n<p>优点：实现简单，无外部碎片</p>\n<p>缺点：</p>\n<ul>\n<li>当程序太大时，可能所有的分区都不能满足需求，此时不得不采取覆盖技术来解决，但这又会降低性能；</li>\n<li>会产生内部碎片，内存利用率低</li>\n</ul>\n<h4 id=\"动态分区分配\"><a class=\"anchor\" href=\"#动态分区分配\">#</a> 动态分区分配</h4>\n<p>动态分区分配又称为可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小是可变的。</p>\n<ul>\n<li>\n<p>操作系统用什么数据结构记录内存的使用情况</p>\n<ul>\n<li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li>\n<li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li>\n</ul>\n</li>\n<li>\n<p>当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p>\n<ul>\n<li>按照一定的动态分区分配算法，从空闲分区表或空闲分区链中选一个分区分配给该作业</li>\n</ul>\n</li>\n<li>\n<p>如何进行分区的分配与回收操作</p>\n<ul>\n<li>情况一：回收区的后面有一个相邻的空闲分区：两个相邻的空闲分区合并为一个，修改相应的起始地址</li>\n<li>情况二：回收区的前面有一个相邻的空闲分区：两个相邻的空闲分区合并为一个，修改相应的起始地址</li>\n<li>情况三：回收区的前、后各有一个相邻的空闲分区：三个相邻的空闲分区合并为一个，修改相应的起始地址</li>\n<li>情况四：回收区的前、后都没有相邻的空闲分区：增加一个表项</li>\n</ul>\n</li>\n</ul>\n<p>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</p>\n<p>动态分区分配没有内部碎片，但是有外部碎片</p>\n<p>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。</p>\n<p>外部碎片，是指内存中的某些空闲分区由于太小而难以利用</p>\n<p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些 &quot;碎片&quot; 不能满足进程的需求。可以通过紧凑技术来解决外部碎片</p>\n<h3 id=\"动态分区分配算法\"><a class=\"anchor\" href=\"#动态分区分配算法\">#</a> 动态分区分配算法</h3>\n<p>动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪一个分区进行分配</p>\n<h4 id=\"首次适应算法\"><a class=\"anchor\" href=\"#首次适应算法\">#</a> 首次适应算法</h4>\n<p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p>\n<p>如何实现：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链 (或空闲分区表)，找到大小能满足要求的第一个空闲分区</p>\n<h4 id=\"最佳适应算法\"><a class=\"anchor\" href=\"#最佳适应算法\">#</a> 最佳适应算法</h4>\n<p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当 &quot;大进程&quot; 到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区</p>\n<p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链 (或空闲分区表)，找到大小能满足要求的第一个空闲分区</p>\n<p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，因此这种方式会产生很多的外部碎片。</p>\n<h4 id=\"最坏适应算法\"><a class=\"anchor\" href=\"#最坏适应算法\">#</a> 最坏适应算法</h4>\n<p>又称最大适应算法</p>\n<p>算法思想：为了解决最佳适应算法的问题 —— 即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲分区，这样分配剩余的空间区就不会太小，更方便实用</p>\n<p>如何实现：空闲分区按容量进行递减次序链接。每次分配内存时顺序查找空闲分区链 (空闲分区表)，找到大小能满足要求的第一个空闲分区</p>\n<p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲分区被迅速用完。如果之后有 &quot;大进程&quot; 达到，就没有内存分区可用了</p>\n<h4 id=\"邻近适应算法\"><a class=\"anchor\" href=\"#邻近适应算法\">#</a> 邻近适应算法</h4>\n<p>算法思想：首次适应算法每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p>\n<p>如何实现：空闲分区以地址递增的顺序排列（可排列成一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p>\n<p>首次适应算法每次都要从头查找，每次都要检索低地址的小分区，但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p>\n<p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也会导致高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p>\n<p>综合来看，四种算法中，首次适应算法的效果反而更好</p>\n<h3 id=\"基本分页存储管理\"><a class=\"anchor\" href=\"#基本分页存储管理\">#</a> 基本分页存储管理</h3>\n<p>将内存空间分为一个个大小相等的分区，每个分区就是一个 &quot;页框&quot;（页框 = 页帧 = 内存块 = 物理块 = 物理页面）。每个页面有一个编号，即 &quot;页框号&quot;（页框号 = 页帧号 = 内存块号 = 物理块号 = 物理页号），页框号从 0 开始</p>\n<p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个 &quot;页&quot; 或 &quot;页面&quot;。每个页面也有一个编号，即 &quot;页号&quot;，页号也是从 0 开始</p>\n<p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中</p>\n<h4 id=\"重要的数据结构页表\"><a class=\"anchor\" href=\"#重要的数据结构页表\">#</a> 重要的数据结构 —— 页表</h4>\n<p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表</p>\n<p>注：页表通常存在 PCB (进程控制块) 中</p>\n<ul>\n<li>\n<p>一个进程对应一张页表</p>\n</li>\n<li>\n<p>进程的每个页表对应一个页表项</p>\n</li>\n<li>\n<p>每个页表项由 &quot;页号&quot; 和 &quot;块号&quot; 组成</p>\n</li>\n<li>\n<p>页表记录进程页面和实际存放的内存块之间的映射关系</p>\n</li>\n</ul>\n<p>重要考点：计算机中内存块的数量 -&gt; 页表项中块号至少占多少字节</p>\n<p>例：假设某系统中物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p>\n<ul>\n<li>内存块大小 = 页面大小 = 4KB</li>\n<li>物理内存可以分成 4GB=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup><mi mathvariant=\"normal\">/</mi><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant=\"normal\">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding=\"application/x-tex\">4*2^{30}/4KB=2^{32}/2^{12}=2^{20}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\">4</span><span class=\"mord mathnormal\" style=\"margin-right:0.07153em;\">K</span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">3</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord\">/</span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span></span></span></span> 个块</li>\n<li>内存块号的范围应该是 0~<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{20}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></li>\n<li>内存块至少需要 20 个 bit 表示</li>\n<li>至少需要 3B=3*8bit=24bit&gt;20bit 来表示块号，因此每个页表项至少应该为 3 字节</li>\n</ul>\n<p>页表项连续存放，因此页号可以是隐含的，不占存储空间 (类比数组)</p>\n<ul>\n<li>由于页号是隐含的，因此每个页表项占 3B，储存整个页表至少需要<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo>×</mo><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>3</mn><mo>×</mo><msup><mn>2</mn><mn>21</mn></msup></mrow><annotation encoding=\"application/x-tex\">3\\times2^{20}=3\\times2^{21}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">0</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span> 页</li>\n</ul>\n<p><strong>地址转换</strong></p>\n<p>重定位寄存器：指明了进程在内存中起始位置</p>\n<p>相对于起始位置的 &quot;偏移量&quot;</p>\n<p>特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p>\n<p>如果要访问逻辑地址 A，则：</p>\n<ul>\n<li>\n<p>确定逻辑地址 A 对应的页号 P</p>\n</li>\n<li>\n<p>找到 P 号页面在内存中的起始地址 (需要查页表)</p>\n</li>\n<li>\n<p>确定逻辑地址 A 的 &quot;页内偏移量&quot;W</p>\n</li>\n<li>\n<p>逻辑地址 A 对应的物理地址 = P 号页在内存中的起始地址 + 页内偏移量 W</p>\n</li>\n</ul>\n<p>页号 = 逻辑地址 / 页面长度（取除法的整数部分）</p>\n<p>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）</p>\n<p>逻辑地址可以拆分为（页号，页内偏移量）</p>\n<p>通过页号查询页表，可知页面在内存中的起始地址</p>\n<p>页面在内存中的起始地址 + 页内偏移量 = 实际的物理地址</p>\n<p>结论：如果每个页面大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span></span></span></span></span></span></span>B，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号</p>\n<p>根据页号可以查询页表，而页表中记录的只是内存块号，而不是内存块的起始地址，J 号内存块的起始地址 = J * 内存块大小</p>\n<p>结论：如果页面大小刚好是 2 的整数幂，则只需把页表中记录的物理块号拼接上页内偏移量就能得到对应的物理地址</p>\n<p><strong>页面大小刚好是 2 的整数幂由什么好处</strong></p>\n<ul>\n<li>逻辑地址的拆分更加迅速 —— 如果每个页面大小为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span></span></span></span></span></span></span>B，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面大小为 2 的整数幂计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度</li>\n<li>物理地址的计算更加迅速 —— 根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li>\n</ul>\n<p><strong>逻辑地址结构</strong></p>\n<p>如果有 K 位表示页内偏移量，则说明该系统中一个页面的大小是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^K</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.07153em;\">K</span></span></span></span></span></span></span></span></span></span></span> 个内存单元</p>\n<p>如果有 M 位表示页号，则说明在该系统中，一个进程最多允许由<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>M</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^M</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8413309999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8413309999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">M</span></span></span></span></span></span></span></span></span></span></span> 个页面</p>\n<h3 id=\"基本地址变换机构\"><a class=\"anchor\" href=\"#基本地址变换机构\">#</a> 基本地址变换机构</h3>\n<p>基本地址变换机构可以借助进程的页面将逻辑地址转换为物理地址。</p>\n<p><strong>页表寄存器</strong></p>\n<p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址 F 和页表长度 M。</p>\n<p>进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中</p>\n<p><strong>地址变换过程</strong></p>\n<p>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：</p>\n<ul>\n<li>计算页号 P 和页内偏移量 W（如果用十进制数手算，则 P=A/L，W=A% L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li>\n<li>比较页号 P 和页表长度 M，若 P&gt;=M，则产生越界中断，否则继续执行（注意：页号是从 0 开始的，而页表长度至少是 1，因此 P=M 时也会越界）</li>\n<li>页表中页号 P 对应的页表项地址 = 页表起始地址 F + 页号 * 页表项长度，取出该页表项内容 b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</li>\n<li>计算 E=b*L+W，用得到的物理地址 E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li>\n</ul>\n<p>简洁版：</p>\n<ul>\n<li>根据逻辑地址计算出页号、页内偏移量</li>\n<li>判断页号是否越界</li>\n<li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li>\n<li>用内存块号和页内偏移量得到物理地址</li>\n<li>访问目标内存单元</li>\n</ul>\n<p>例题：若某页面大小 L 为 1K 字节，页号 2 对应的内存块号 b=8，将逻辑地址 A=2500 转换为物理地址 E。</p>\n<p>解析：求页号 = 2500/1024=2，页内偏移量 = 2500%1024=452，对应内存块号为 8，物理地址 E=8*1024+452=8644</p>\n<p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的，即，只要给出了一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</p>\n<p><strong>对页表项大小的进一步探讨</strong></p>\n<p>结论：理论上长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多字节，使得每个页面恰好可以装得下整数个页表项</p>\n<p>进程页表通常是装在连续的内存块中</p>\n<h3 id=\"具有快表的地址变换机构\"><a class=\"anchor\" href=\"#具有快表的地址变换机构\">#</a> 具有快表的地址变换机构</h3>\n<p><strong>快表</strong></p>\n<p>快表：又称联想寄存器，是一种访问速度比内存快很多的高速缓存 (TLB 不是内存)，用来存放最近访问的页表项的副本，可以加速地址变换的速度。于此对应，内存中的页表常称为慢表</p>\n<p><strong>引入快表后，地址的变换过程</strong></p>\n<ul>\n<li>CPU 给出逻辑地址，由某个硬件算得页号。页内偏移量，将页号与快表中的所有页号进行比较</li>\n<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可</li>\n<li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li>\n</ul>\n<p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。</p>\n<p>例题：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构，访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p>\n<p>解析：平均耗时为 0.9x (1+100) us+0.1x (1+100+100) us=111us</p>\n<p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) x0.8+(100+100)*0.1=110.9us</p>\n<p>若未采用快表机制，则访问一个逻辑地址需要 100+100=200us</p>\n<p><strong>局部性原理</strong></p>\n<p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数组已被访问过，不久之后该数据很可能再次被访问。（因为程序中存在着大量的循环）</p>\n<p>空间局部性：一旦程序访问了某个存储单元，在不久后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p>\n<p>TLB 和 Cache 的区别 ——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p>\n<h3 id=\"两级页表\"><a class=\"anchor\" href=\"#两级页表\">#</a> 两级页表</h3>\n<p><strong>单级页表存在的问题</strong></p>\n<p>根据页号的方法：K 号页对应的页表项存放位置 = 页表起始地址 + K*4，要在所有的页表项都连续存放的基础上才能使用这种方法查找页表项。</p>\n<p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存</p>\n<p>问题：</p>\n<ul>\n<li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</li>\n<li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面\n<ul>\n<li>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li>\n<li>若想访问的页面不在内存，则产生缺页中断（内中断），然后将目标页面从外存调入内存</li>\n</ul>\n</li>\n</ul>\n<p>可将长页表进行分组，使每个内存块刚好可以放入一个分组。</p>\n<p>另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表</p>\n<p><strong>两级页表地址变换</strong></p>\n<ul>\n<li>\n<p>按照地址结构将逻辑地址拆分成三部分</p>\n</li>\n<li>\n<p>从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p>\n</li>\n<li>\n<p>根据二级页号查表，找到最终想访问的内存块号</p>\n</li>\n<li>\n<p>结合页内偏移量得到物理地址</p>\n</li>\n</ul>\n<p><strong>细节事项</strong></p>\n<ul>\n<li>若采用多级页表机制，则各级页表的大小不能超过一个页面</li>\n</ul>\n<p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？</p>\n<p>解析：页面大小 = 4KB=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">2^{12}B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，页内偏移量为 12 位，页号为 40-12=28 位，每个页面可以存放 4KB/4B=1024 个页表项，10 位可以表示出 1024 个页表项，因此 28 位最多可以表示三级页表，最终逻辑地址分为一级页号 (8 位)+ 二级页号 (10 位)+ 三级页号 (10 位)+ 页内偏移量 (12 位)</p>\n<ul>\n<li>两级页表的访存次数分析 (假设没有快表机构)\n<ul>\n<li>第一次访存：访问内存中的页目录表</li>\n<li>第二次访存：访问内存中的二级页表</li>\n<li>第三次访存：访问目标内存单元</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基本分段式存储管理方式\"><a class=\"anchor\" href=\"#基本分段式存储管理方式\">#</a> 基本分段式存储管理方式</h3>\n<p>与分页最大的区别就是 —— 离散分配时所分配地址空间的基本单位不同</p>\n<h4 id=\"分段\"><a class=\"anchor\" href=\"#分段\">#</a> 分段</h4>\n<p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从 0 开始编址</p>\n<p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p>\n<p>由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高</p>\n<p>分段系统的逻辑地址结构由段号 (段名) 和段内地址 (段内偏移量) 所组成</p>\n<p>段号的位数决定了每个进程最多可以分几个段</p>\n<p>段内地址位数决定了每个段的最大长度是多少</p>\n<h4 id=\"段表\"><a class=\"anchor\" href=\"#段表\">#</a> 段表</h4>\n<p>程序分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称 &quot;段表&quot;</p>\n<ul>\n<li>每个段对应一个段表项，其中记录了该段在内存中的起始位置 (又称 &quot;基址&quot;) 和段的长度</li>\n<li>各个段表项的长度是相同的。段号可以是隐含的，不占存储空间</li>\n</ul>\n<p><strong>地址变换</strong></p>\n<p>简洁版：</p>\n<ul>\n<li>根据逻辑地址计算出段号、段内偏移量</li>\n<li>判断段号是否越界。若 S (段号)&gt;=M (段表长度)，则产生越界中断，否则继续执行</li>\n<li>查询段表，找到段号对应的段表项，段表项的存放地址为 F (段表始址)+S (段号)* 段表项长度</li>\n<li>检查段内地址是否超过段长。若 W (段内地址)&gt;=C (段长)，则产生越界中断，否则继续执行</li>\n<li>计算得到物理地址</li>\n<li>访问目标内存单元</li>\n</ul>\n<h4 id=\"分段-分页管理对比\"><a class=\"anchor\" href=\"#分段-分页管理对比\">#</a> 分段、分页管理对比</h4>\n<p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的</p>\n<p>段是信息的逻辑单位。分段的主要目的是为了更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名</p>\n<p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</p>\n<p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</p>\n<p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p>\n<p>分段比分页更容易实现信息的共享和保护</p>\n<p>不能被修改的代码称为纯代码或可重入代码 (不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的 (比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)</p>\n<p>分段比分页更容易实现信息的共享和保护</p>\n<p>访问一个逻辑地址需要几次访存：</p>\n<ul>\n<li>分页 (单级页表)：第一次访存 —— 查内存中的页表，第二次访存 —— 访问目标内存单元，总共两次访存</li>\n<li>分段：第一次访存 —— 查内存中的段表，第二次访存 —— 访问目标内存单元，总共两次访存</li>\n</ul>\n<p>与分页系统类似，分段系统中也可以引入快表机构。将近期访问的段表项放到快表中，这样可以少一次访存，加快地址变换速度</p>\n<h3 id=\"段页式管理方式\"><a class=\"anchor\" href=\"#段页式管理方式\">#</a> 段页式管理方式</h3>\n<h4 id=\"分段-分页的优缺点分析\"><a class=\"anchor\" href=\"#分段-分页的优缺点分析\">#</a> 分段、分页的优缺点分析</h4>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>分页管理</td>\n<td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td>\n<td>不方便按逻辑模块实现信息的共享和保护</td>\n</tr>\n<tr>\n<td>分段管理</td>\n<td>很方便按照逻辑模块实现信息的共享和保护</td>\n<td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td>\n</tr>\n</tbody>\n</table>\n<p>分段管理产生的外部碎片也可以用 &quot;紧凑&quot; 来解决，只是需要付出较大的时间代价</p>\n<h4 id=\"分段分页段页式管理\"><a class=\"anchor\" href=\"#分段分页段页式管理\">#</a> 分段 + 分页 = 段页式管理</h4>\n<p>将进程按逻辑模块分段，再将各段分页</p>\n<p>再将内存空间分为大小相同的内存块 / 页面 / 物理块</p>\n<p>进程前将各页面分别装入各内存块中</p>\n<h4 id=\"段页式管理的逻辑地址结构\"><a class=\"anchor\" href=\"#段页式管理的逻辑地址结构\">#</a> 段页式管理的逻辑地址结构</h4>\n<p>段页式系统的逻辑地址结构由段号、页号、页内地址 (页内偏移量) 组成</p>\n<p>段号的位数决定了每个进程最多可以分几个段</p>\n<p>页号的位数决定了每个段最大有多少页</p>\n<p>页内偏移量决定了页面大小，内存块大小是多少</p>\n<p>段页式管理的地址结构和分段式管理一样，是二维的</p>\n<h4 id=\"段表-页表\"><a class=\"anchor\" href=\"#段表-页表\">#</a> 段表、页表</h4>\n<p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号 (页表起始地址) 组成。每个段表项长度相等，段号是隐含的</p>\n<p>每个页面对应一个页表项。每个页表项由页号、页面存放的内存块号组成，每个页表项长度相等，页号是隐含的</p>\n<h4 id=\"地址变换过程\"><a class=\"anchor\" href=\"#地址变换过程\">#</a> 地址变换过程</h4>\n<ul>\n<li>\n<p>根据逻辑地址得到段号、页号、页内偏移地址</p>\n</li>\n<li>\n<p>判断段号是否越界，若 S (段号)&gt;=M (段表长度)，则产生越界中断，否则继续进行</p>\n</li>\n<li>\n<p>查询段表，找到对应的段表项，段表项的存放地址是 F (段表始址)+S (段号)* 段表项长度</p>\n</li>\n<li>\n<p>检查页号是否越界，若页号 &gt;= 页表长度，则发生越界中断，否则继续执行</p>\n</li>\n<li>\n<p>根据页表存放块号、页号查询页表，找到对应页表项</p>\n</li>\n<li>\n<p>根据内存块号、页内偏移量得到最终的物理地址</p>\n</li>\n<li>\n<p>访问目标内存单元</p>\n</li>\n</ul>\n<p>也可引入快表机制，用段号和页号作为查询快表的关键字，若快表命中则仅需一次访存</p>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-1/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-1/",
            "title": "计网408-3-1",
            "date_published": "2024-08-05T09:09:30.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"数据链路层概述\"><a class=\"anchor\" href=\"#数据链路层概述\">#</a> 数据链路层概述</h3>\n<ul>\n<li>链路就是从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换节点</li>\n<li>数据链路是指把通信协议的硬件和软件加到链路上，就构成了数据链路</li>\n<li>数据链路层以帧为单位传输和处理数据</li>\n</ul>\n<p>数据链路层三个重要问题：</p>\n<ul>\n<li>封装成帧\n<ul>\n<li>数据链路层给网络层交付的协议数据单元添加帧头和帧尾的操作称为封装成帧</li>\n<li>添加帧头和帧尾的目的：为了在链路上以帧为单元来传输数据</li>\n</ul>\n</li>\n<li>差错检测\n<ul>\n<li>发送方在发送帧之前，基于待发送的数据和检错算法计算出检错码，并将其封装在帧尾</li>\n<li>接收方主机收到帧后，通过检错码和检错算法，就可以判断出帧在传输过程中是否出现了误码</li>\n</ul>\n</li>\n<li>可靠传输\n<ul>\n<li>接收方在接收到了有误码的帧后，不会接收该帧，将其丢弃</li>\n<li>如果数据链路层为上层提供的是不可靠服务，那么丢弃后不会有更多措施</li>\n<li>如果数据链路层为上层提供的是可靠服务，就需要更多措施来确保接收方收到被丢弃的帧的正确副本</li>\n<li>尽管误码是不可避免的，但若能实现发送发发送什么，接收方就能收到什么，就成为可靠传输</li>\n</ul>\n</li>\n</ul>\n<p>注意：以上是在点对点的数据链路层的情况下讨论的</p>\n<p>使用广播信道的数据链路层（共享局域网）</p>\n<ul>\n<li>共享式以太网的媒体接入控制协议 CSMA/CD</li>\n<li>802.11 局域网的媒体接入控制协议 CSMA/CA</li>\n</ul>\n<p>数据链路层的互连设备</p>\n<ul>\n<li>网桥和交换机的工作原理</li>\n<li>集线器 (物理层互连设备) 与交换机的区别</li>\n</ul>\n<h3 id=\"封装成帧\"><a class=\"anchor\" href=\"#封装成帧\">#</a> 封装成帧</h3>\n<p>封装成帧：指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p>\n<ul>\n<li>帧头和帧尾中包含重要的控制信息</li>\n<li>帧头和帧尾的作用之一就是帧定界</li>\n</ul>\n<p>透明传输：指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样</p>\n<ul>\n<li>面向字节的物理链路使用字节填充 (或称字符填充) 的方法实现透明传输\n<ul>\n<li>对于上层数据部分有帧定界符和转义符的部分，会在前面添加转义符，让帧定界符和转义符被当做数据处理</li>\n</ul>\n</li>\n<li>面向比特的物理链路使用比特填充的方法实现透明传输\n<ul>\n<li>对上层交付的数据进行扫描，如果其中包含帧定界符，可以使用零比特填充法，这样保证了帧定界符的唯一性\n<ul>\n<li>零比特填充法：在每 5 个连续的 1 后面添加 0</li>\n</ul>\n</li>\n<li>接收方在接受时将插入的比特剔除即可</li>\n</ul>\n</li>\n</ul>\n<p>为了提供帧的传输效率，应当使帧的数据部分的长度尽可能大些</p>\n<p>考虑到差错控制等多种因素，每一种数据链路协议都规定了帧的数据部分的长度上限，即最大传送单元 MTU</p>\n<h3 id=\"差错检测\"><a class=\"anchor\" href=\"#差错检测\">#</a> 差错检测</h3>\n<p>实际的通信链路都不是理想的，比特在传输的过程中可能会产生差错：1 可能会变成 0，而 0 可能会变成 1。这称为比特差错</p>\n<p>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER</p>\n<p>使用差错检测码来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一</p>\n<p><strong>奇偶校验</strong></p>\n<ul>\n<li>\n<p>在待发送的数据后面添加 1 位奇偶校验位，使整个数据 (包括添加的校验位在内) 中 1 的个数位奇数（奇校验）或偶数（偶校验）</p>\n</li>\n<li>\n<p>如果有奇数个位发生误码，则奇偶性发生变化，可以检查出误码</p>\n</li>\n<li>\n<p>如果有偶数个位发生误码，则奇偶性不会发生变化，不能检查出误码（漏检）</p>\n</li>\n<li>\n<p>计算机网络的数据链路层一般不会采用奇偶校验</p>\n</li>\n</ul>\n<p><strong>循环冗余校验</strong></p>\n<ul>\n<li>收发双方约定好一个生成多项式</li>\n<li>发送方基于待发送的数据和生成多项式计算出差错检测码（冗余码），将其添加到带传输数据的后面一起传输</li>\n<li>接收方通过生成多项式来计算收到的数据是否产生了误码</li>\n<li>CRC 算法要求生成多项式必须包含最低次项</li>\n</ul>\n<p>例：待发送的信息为 101001，生成多项式为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">G(x)=x^3+x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，计算余数</p>\n<ul>\n<li>构造被除数：待发送信息后再添加多项式最高次数个 0\n<ul>\n<li>本题中，被除数为 101001000</li>\n</ul>\n</li>\n<li>构造除数：生成多项式各项系数构成的比特串\n<ul>\n<li>本题中，除数为 1101</li>\n</ul>\n</li>\n<li>做除法：\n<ul>\n<li>本题中 101001000/1101=110101 余 1</li>\n</ul>\n</li>\n<li>检查余数：余数的位数应与生成多项式最高次数相同，如果位数不够，则在余数前补 0 来凑足位数\n<ul>\n<li>本题中余数变为 001,</li>\n</ul>\n</li>\n<li>将余数添加到待发送信息的后面\n<ul>\n<li>本题中待发送信息变为 101001001 发送出去</li>\n</ul>\n</li>\n</ul>\n<p>例：接收到的信息为 101101001，生成多项式为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>G</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">G(x)=x^3+x^2+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">G</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\">x</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，判断是否产生误码</p>\n<ul>\n<li>计算后为 101101001/1101=110010 余 11</li>\n<li>余数不为 0，表明传输时出现了误码</li>\n</ul>\n<p>检错码只能检测出帧在传输过程中出现了差错但并不能定位错误，因此无法纠正错误</p>\n<p>要想纠正传输中的差错，可以使用冗余信息更多的纠错码进行前向纠错。但纠错码的开销比较大，在计算机网络中较少使用</p>\n<p>循环冗余校验 CRC 有很好的检错能力 (漏检率非常低)，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层</p>\n<p>在计算机网络中通常采用检错重传方式来纠正传输中的差错或者仅仅是丢弃检测到差错的帧，这取决于数据链路层向上层提供的是可靠传输服务还是不可靠传输服务</p>\n<h3 id=\"可靠传输服务\"><a class=\"anchor\" href=\"#可靠传输服务\">#</a> 可靠传输服务</h3>\n<p>使用差错检测技术（例如循环冗余校验 CRC），接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）</p>\n<p>数据链路层向上层提供的服务类型：</p>\n<ul>\n<li>不可靠传输服务：仅仅丢弃有误码的帧，其他什么也不做</li>\n<li>可靠传输服务：想办法实现发送端发送什么，接收端就收到什么</li>\n</ul>\n<p>一般情况下，有线链路的误码率比较低，为了 减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理</p>\n<p>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务</p>\n<p>比特差错只是传输差错的一种</p>\n<p>从整个计算机网络体系结构来看，传输差错还包括分组丢失、分组失序以及分组重复</p>\n<p>分组丢失、分组失序和分组重复这些传输差错，一般不会出现在数据链路层，而会出现在其上层</p>\n<p>可靠传输服务并不仅限于数据链路层，其他各层均可选择实现可靠传输</p>\n<ul>\n<li>TCP 向上层提供面向连接的可靠传输服务</li>\n<li>UDP 向上层提供无连接、不可靠的传输服务</li>\n<li>IP 向上层提供无连接、不可靠传输服务</li>\n<li>802.11 无线局域网要求数据链路层实现可靠传输服务，以太网不要求数据链路层实现可靠传输</li>\n</ul>\n<p>可靠传输的实现比较复杂，开销也比较大，是否使用可靠传输取决于应用需求</p>\n<h3 id=\"可靠传输的实现机制\"><a class=\"anchor\" href=\"#可靠传输的实现机制\">#</a> 可靠传输的实现机制</h3>\n<ul>\n<li>停止 - 等待协议 SW</li>\n<li>回退 N 帧协议 GBN</li>\n<li>选择重传协议 SR</li>\n</ul>\n<p>以上三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p>\n<h4 id=\"停止-等待协议sw\"><a class=\"anchor\" href=\"#停止-等待协议sw\">#</a> 停止 - 等待协议 SW</h4>\n<ul>\n<li>发送方将数据传输给接收方，接收方接收到并确认无误码后，向发送方发送 ACK 表示正确接收到</li>\n<li>若接收方接收到了有误码的数据，则接收方将丢弃数据，并给发送方发送 NAK 表示未正确收到，发送方收到 NAK 后，再次向接收方发送一次数据，直到接收到 ACK 为止</li>\n<li>发送方不能在发送后就将发送数据从缓存中删除，需要在收到接收方发送的 ACK 后才可以将发送数据从缓存中清除</li>\n</ul>\n<p><strong>发送方发送数据丢失</strong></p>\n<p>若发送方发送的数据丢失，接收方收不到数据分组，就不会发送 ACK 或 NAK，如果不采取其他措施，发送方就会一直处于等待接收方 ACK 或 NAK 的状态。</p>\n<p>为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间，而发送方仍收不到接收方的 ACK 或 NTK，则重传原来的数据分组，这就叫超时重传</p>\n<p><strong>接收方发送数据丢失</strong></p>\n<p>同理，接收方发送的 ACK 或 NTK 也有可能丢失，此时发送方又会超时重传一个同样的数据到接收方。</p>\n<p>为了避免重复分组这种传输错误，必须给每个分组带上序号。</p>\n<p>对于停止 - 等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同就可以了，因此用一个比特来编号就足够了</p>\n<p>接收方确认是重复数据分组后，丢弃这个重复数据，并给发送方发送针对该数据分组的确认分组，以免发送方对该组数据分组的再次超时重传</p>\n<p>通过给确认分组编号的方法，解决确认迟到所导致的重复确认问题</p>\n<p><strong>注意事项</strong></p>\n<ul>\n<li>接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重构。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送 NAK 分组</li>\n<li>为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止 - 等待协议的停等特性，只需 1 个比特编号就够了，即编号 0 和 1</li>\n<li>为了让发送方能够判断所收到的 ACK 分组是否是重复的，需要给 ACK 分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层是一般不会出现 ACK 分组迟到的情况，因此在数据链路层实现停止 - 等待协议可以不用给 ACK 分组编号</li>\n<li>超时计时器设定的重传时间应仔细选择，一般可将重传时间略大于 &quot;从发送方到接收方的平均往返时间&quot;。\n<ul>\n<li>在数据链路层点对点的往返时间比较固定，重传时间比较好设定</li>\n<li>然而在运输层，由于端到端往返时间非常不稳定设置合适的重传时间有时并不容易</li>\n</ul>\n</li>\n</ul>\n<p><strong>停止 - 等待协议信道利用率</strong></p>\n<p>信道利用率 U=TD/(TD+RTT+TA)</p>\n<p>TD 为数据分组的发送时延，RTT 为数据的传输往返时间，TA 为确认分组的发送时延</p>\n<p>当往返时间 RTT 远大于数据帧发送时延 TD 时，信道利用率非常低</p>\n<p>若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低</p>\n<p>为了克服停止 - 等待协议信号利用率很低的缺点，就产生了另外两种协议，即后退 N 帧协议 GBN 和选择重传协议 SR</p>\n<p>例题：主机甲采用停止 - 等待协议向主机乙发送数据，数据传输速率为 3kbps，单向传播时延为 200ms，忽略确认帧的传输延时，当信道利用率等于 40% 时，数据帧的长度为（D）</p>\n<p>A.240 比特      B.400 比特         C.480 比特           D.800 比特</p>\n<p>解析：U=TD/(TD+RTT+TA)，TA 忽略不计，则 RTT=2*200ms=400ms，TD=160ms/0.6=800/3ms，传输速率为 3kbps，则数据帧长度为 800/3*3kbps=800 比特</p>\n<p>停止等待协议属于自动请求重传 ARQ，即重传的请求是自动进行的</p>\n<h4 id=\"回退n帧协议gbn\"><a class=\"anchor\" href=\"#回退n帧协议gbn\">#</a> 回退 N 帧协议 GBN</h4>\n<p>采用流水线传输可提高信道利用率</p>\n<p><strong>发送方</strong></p>\n<ul>\n<li>\n<p>发送窗口尺寸<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的取值范围是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>&lt;</mo><msub><mi>W</mi><mi>T</mi></msub><mo>≤</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1&lt;W_T\\le 2^n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.747722em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span></p>\n<ul>\n<li>其中，n 是构成分组序号的比特数量</li>\n<li>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">W_T=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，停止等待协议</li>\n<li>当<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub><mo>&gt;</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">W_T&gt;2^n-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.747722em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.664392em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">n</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，接收方无法分辨新、旧数据分组</li>\n</ul>\n</li>\n<li>\n<p>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去</p>\n</li>\n<li>\n<p>发送方只有收到对已发送数据分组的确认时，发送窗口才能向前相应滑动</p>\n</li>\n<li>\n<p>发送方收到多个重复确认时，可在重传计时器超时前尽早开始重传，由具体实现决定</p>\n</li>\n<li>\n<p>发送方发送窗口内某个已发送的数据分组产生超时重发时，其后续在发送窗口内且已发送的数据分组也必须全部重传，这就是回退 N 帧协议名称的由来</p>\n</li>\n</ul>\n<p><strong>接收方</strong></p>\n<ul>\n<li>接收方的接收窗口 WR 的取值范围是 1，因此接收方只能按序接收数据分组</li>\n<li>接收方只接受序号落在接受窗口内且无误的数据分组，并且将接收窗口向前滑动一个位置，与此同时给发送方发回相应的确认分组，为了减少开销，接收方不一定每收到一个按序到达且无误码的数据分组就给发送方发回一个确认分组\n<ul>\n<li>而是可以在连续收到好几个按序到达且无误码的数据分组后（由具体实现决定），才针对最后一个数据分组发送确认分组，这称为累积确认</li>\n<li>或者可以在自己有数据分组要发送时才对之前按序接收且无误码的数据分组进行捎带确认</li>\n</ul>\n</li>\n<li>接收方收到未按时到达的数据分组，除丢弃外，还要对最近按序接收的数据分组进行确认</li>\n</ul>\n<p>回退 N 帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续 ARQ 协议。在协议的工作过程中，发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</p>\n<p>由于回退 N 帧协议的特性，当通信链路质量不好时，其信道利用率并不比停止 - 等待协议高</p>\n<h4 id=\"选择重传协议sr\"><a class=\"anchor\" href=\"#选择重传协议sr\">#</a> 选择重传协议 SR</h4>\n<p>为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸 WR 不应再等于 1（而应大于 1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议 SR</p>\n<p>注意：选择重传协议为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认</p>\n<p><strong>发送方</strong></p>\n<ul>\n<li>发送窗口尺寸<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的取值范围是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">[</mo><mn>1</mn><mo separator=\"true\">,</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">[1,2^{n-1}]</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mopen\">[</span><span class=\"mord\">1</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span><span class=\"mclose\">]</span></span></span></span>\n<ul>\n<li>其中，n 是构成分组序号的比特数量</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">W_T=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，与停止 - 等待协议想通</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>T</mi></msub><mo>&gt;</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding=\"application/x-tex\">W_T&gt;2^{n-1}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">n</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span></span></span></span></span></span></span></span></span>，接收方无法分辨新、旧数据分组</li>\n</ul>\n</li>\n<li>发送方可在未收到接收方确认分组的情况下，将序号落在发送窗口内的多个数据分组全部发送出去</li>\n<li>发送方只有按序收到对已发送数据分组的确认时，发送窗口才能向前相应滑动；若收到未按序到达的确认分组时，对其进行记录，以防止相应数据分组的超时重发，但发送窗口不能向前滑动</li>\n</ul>\n<p><strong>接收方</strong></p>\n<ul>\n<li>接收窗口<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>R</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_R</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span> 的取值范围是<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><mo>&lt;</mo><msub><mi>W</mi><mi>R</mi></msub><mo>≤</mo><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">1&lt;W_R\\le W_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68354em;vertical-align:-0.0391em;\"></span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&lt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>\n<ul>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>R</mi></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">W_R=1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>，与停止 - 等待协议想通</li>\n<li><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>W</mi><mi>R</mi></msub><mo>&gt;</mo><msub><mi>W</mi><mi>T</mi></msub></mrow><annotation encoding=\"application/x-tex\">W_R&gt;W_T</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.00773em;\">R</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">&gt;</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.83333em;vertical-align:-0.15em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.13889em;\">T</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span></span></span>，无意义</li>\n</ul>\n</li>\n<li>接收方可接收未按序到达但没有误码并且序号落在接收窗口内的数据分组\n<ul>\n<li>为了使发送方仅重传出现差错的分组，接收方不能再采用累积确认，而需要对每个正确接收到的数据分组进行逐一确认</li>\n</ul>\n</li>\n<li>接收方只有在按序接收数据分组后，接收窗口才向前相应滑动</li>\n</ul>\n<h3 id=\"点对点协议ppp\"><a class=\"anchor\" href=\"#点对点协议ppp\">#</a> 点对点协议 PPP</h3>\n<ul>\n<li>\n<p>点对点协议 PPP 是目前使用最广泛的点对点数据链路层协议</p>\n</li>\n<li>\n<p>PPP 协议是因特网工程任务组 IETF 在 1992 年制定的。经过 1993 年和 1994 年的修订，现在的 PPP 协议已成为因特网的正式标准 [RFC1661,RFC1662]</p>\n</li>\n<li>\n<p>PPP 协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</p>\n<ul>\n<li>对各种协议数据报的封装方法（封装成帧）</li>\n<li>链路控制协议 LCP：用于建立、配置以及测试数据链路的连接</li>\n<li>一套网络控制协议 NCPs：其中的每一个协议支持不同的网络层协议</li>\n</ul>\n</li>\n<li>\n<p>PPP 协议能在多种类型的点对点链路上运行，如：面向字节的异步链路，面向比特的同步链路</p>\n</li>\n</ul>\n<p><strong>PPP 协议的帧格式</strong></p>\n<p>帧头部：4 个字段构成</p>\n<ul>\n<li>标志（Flag）字段：PPP 协议的定界符，取值为 0x7E，1 字节</li>\n<li>地址（Address）字段：取值为 0xFF，预留（目前没有什么作用），1 字节</li>\n<li>控制字段（Control）字段：取值为 0x03，预留（目前没有什么作用），1 字节</li>\n<li>协议（Protocol）字段：指明帧的数据部分送交哪个协议处理，2 字节\n<ul>\n<li>取值为 0x0021 表示：帧的数据部分为 IP 数据报</li>\n<li>取值为 0xC021 表示：帧的数据部分为 LCP 分组</li>\n<li>取值为 0x8021 表示：帧的数据部分为 NCP 分组</li>\n</ul>\n</li>\n</ul>\n<p>帧尾部：2 个字段构成</p>\n<ul>\n<li>帧检验序列字段（FCS）：CRC 计算出的校验位，2 字节</li>\n<li>标志（Flag）字段：PPP 协议的定界符，取值为 0x7E，1 字节</li>\n</ul>\n<p>帧的数据部分：不超过 1500 字节</p>\n<p><strong>实现透明传输的方法</strong></p>\n<p>面向字节的异步链路：</p>\n<ul>\n<li>\n<p>字节填充法：在标志字段前插入转义字符</p>\n</li>\n<li>\n<p>发送方的处理：</p>\n<ul>\n<li>出现的每一个 7E（PPP 帧的定界符）字节转变成 2 字节序列（7D,5E）</li>\n<li>出现的每一个 7D（转义字符）字节转变为 2 字节序列（7D,5D）</li>\n<li>出现的每一个 ASCII 码控制字符（数值小于 0x20 的字符），则在该字符前插入一个 7D 字节，同时将该字符的编码加上 0x20</li>\n</ul>\n<p>接收方处理：进行反变换即可恢复出原来的帧的数据部分</p>\n</li>\n</ul>\n<p>面向比特的同步链路：</p>\n<ul>\n<li>\n<p>比特填充法：插入比特 0</p>\n</li>\n<li>\n<p>发送方的处理：</p>\n<ul>\n<li>对帧的数据部分进行扫描（一般由硬件实现）。只要发现 5 个连续的比特 1，则立即填充 1 个比特 0</li>\n</ul>\n</li>\n<li>\n<p>接收方的处理：</p>\n<ul>\n<li>对帧的数据部分进行扫描（一般由硬件实现）。只要发现 5 个连续的比特 1，就把其后的 1 个比特 0 删除</li>\n</ul>\n</li>\n</ul>\n<p><strong>差错检测</strong></p>\n<p>RFC 1662 附录部分给出了 FCS 的计算方法的 C 语言实现（查表法）</p>\n<p>接收方每收到一个 PPP 帧，就进行 CRC 检验。若 CRC 检验正确，就收下这个帧；反之，就丢弃这个帧，使用 PPP 的数据链路层向上不提供可靠传输服务</p>\n<p><strong>PPP 工作状态</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/Tuga2NScoipPvL5.png\" alt=\"PPP工作状态转换\" /></p>\n<h3 id=\"媒体接入控制\"><a class=\"anchor\" href=\"#媒体接入控制\">#</a> 媒体接入控制</h3>\n<p>共享信道要着重考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制 MAC</p>\n<p>媒体介入控制：</p>\n<ul>\n<li>静态划分信道：预先固定分配好信道，这类方法非常不灵活，对于突发性数据传输信道利用率会很低。通常在无线网络的物理层使用，而不是在数据链路层使用\n<ul>\n<li>频分多址</li>\n<li>时分多址</li>\n<li>码分多址</li>\n</ul>\n</li>\n<li>动态接入控制\n<ul>\n<li>受控接入\n<ul>\n<li>集中控制：有一个主干以循环方式轮询每个站点有无数据发送，只有被轮询到的站点才能发送数据，最大缺点是存在单点故障问题</li>\n<li>分散控制：各站点是平等的，并连接一个环形网络，令牌（一个特殊的控制帧）沿环逐站传递，接收到令牌的站点才有权发送数据，并在发送完数据后将令牌传递给下一个站点</li>\n</ul>\n</li>\n<li>随机接入：所有站点通过竞争，随机地在信道上发送数据，如果恰巧有两个或更多的站点在同一时刻发送数据，则信号在共享媒体上就要产生碰撞（即发生了冲突），使得这些站点的发送都失败。因此，这类协议要解决的关键问题是如何尽量避免冲突及在发生冲突后如何尽快恢复通信，著名的共享式以太网采用的就是随机接入</li>\n</ul>\n</li>\n</ul>\n<p>随着技术发展，交换技术的成熟和成本降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有限领域已完全取代了共享式局域网，但由于无线通道的广播天性，无线局域网仍然使用的是共享媒体技术</p>\n<h3 id=\"静态划分信道\"><a class=\"anchor\" href=\"#静态划分信道\">#</a> 静态划分信道</h3>\n<h4 id=\"信道复用\"><a class=\"anchor\" href=\"#信道复用\">#</a> 信道复用</h4>\n<ul>\n<li>复用是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号</li>\n<li>当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时，可利用复用技术在一条物理通道上建立多条通信信道来充分利用传输媒体的带宽</li>\n</ul>\n<p><strong>频分复用 FDM</strong></p>\n<p>将传输线路的频带资源划分称为多个子频带，形成多个子信道，各子信道之间需要留出隔离频带，以免造成信道间的干扰。</p>\n<p>当多路信号输入一个多路复用器时，这个复用器将每一路信号调制到不同频率的载波上。</p>\n<p>接收端由相应的分用器通过滤波将各路信号分开，将合成的复用信号恢复成原始的多路信号</p>\n<p>频分复用的所有用户同时占用不同的频带资源并行通信</p>\n<p><strong>时分复用 TDM</strong></p>\n<p>将时间划分为一个个时隙。</p>\n<p>时分复用技术将传输线路的带宽资源按时隙轮流分配给不同的用户，每对用户只在所分配的时隙里使用线路传输数据。</p>\n<p>时分复用技术将时间划分为了一段段等长的时分复用帧，每一个时分复用的用户在每一个时分复用帧中占用固定序号的时隙</p>\n<p>每一个用户所占的时隙是周期性出现的，周期为时分复用帧的长度。</p>\n<p>时分复用的所有用户在不同的时间占用同样的频带宽度</p>\n<p><strong>波分复用 WDM</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/g5jctVFqKOI8Cm2.png\" alt=\"波分复用\" /></p>\n<p><strong>码分复用 CDM</strong></p>\n<ul>\n<li>\n<p>码分复用 CDM 是另一种共享信道的方法。实际上，由于该技术主要用于多址接入，人们更常用的名词是码分多址 CDMA</p>\n</li>\n<li>\n<p>同理，频分复用 FDM 和时分复用 TDM 同样可用于多址接入，相应的名次是频分多址 FDMA 和时分多址 TDMA</p>\n</li>\n<li>\n<p>与 FDM 和 TDM 不同，CDM 的每一个用户可以在同样的时间使用同样的频带进行通信</p>\n</li>\n<li>\n<p>由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰</p>\n</li>\n<li>\n<p>CDM 最初是用于军事通信的，因为这种系统所发送的信号具有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现</p>\n</li>\n<li>\n<p>随着技术的进步，CDMA 设备的价格和体积都大幅度下降，因而现在已广泛应用于民用设备的通信中</p>\n</li>\n<li>\n<p>在 CDMA 中，每一个比特时间再划分为 m 个短的间隔，称为码片，通常 m 的值为 64 或 128。</p>\n</li>\n<li>\n<p>使用 CDMA 的每一个站被指派一个唯一的 m bit 码片序列（这种方式称为直接序列扩频 DSSS）</p>\n<ul>\n<li>一个站如果要发送比特 1，则发送它自己的 m bit 码片序列</li>\n<li>一个站如果要发送比特 0，则发送它自己的 m bit 码片序列的二进制反码</li>\n</ul>\n</li>\n<li>\n<p>码片序列挑选原则如下：</p>\n<ul>\n<li>分配给每个站的码片序列必须各不相同，实际常采用伪随机码序列</li>\n<li>分配给每个站的码片序列必须相互正价（规格化内积为 0）\n<ul>\n<li>令向量 S 表示站 S 的码片序列，令向量 T 表示其他任何站的码片序列</li>\n<li>两个不同站 S 和 T 的码片序列正交，就是向量 S 和向量 T 的规格化内积为 0（规格化内积就是内积除以序列长度）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>例：假设给站 S 分配的码片序列为 01011101，给站 T 分配的码片序列为 10111000，这样分配正确吗？</p>\n<p>解析：</p>\n<ul>\n<li>\n<p>检查码片序列是否各部相同：满足</p>\n</li>\n<li>\n<p>检查码片序列是否相互正交：不满足</p>\n<ul>\n<li>站 S 码片序列向量为 (-1,1,-1,1,1,1,-1,1)，站 T 的码片序列向量为 (1,-1,1,1,1,-1,-1,-1)，两者求内积为：(3-5)/8=-2/8 不为 0</li>\n</ul>\n</li>\n</ul>\n<p>例：共有 4 个站进行 CDMA 通信，这 4 个站的码片序列分别为：</p>\n<p>A.(-1,-1,-1,+1,+1,-1,+1,+1)     B.(-1,-1,+1,-1,+1,+1,+1,-1)       C.(-1,+1,-1,+1,+1,+1.-1,-1)      D.(-1,+1,-1,-1,-1,-1,+1,-1)</p>\n<p>接收到码片序列 (-1,+1,-3,+1,-1,-3,+1,+1)，问是哪些站发送了数据？发送的是比特 1 还是 0？</p>\n<p>解析：</p>\n<ul>\n<li>接收的码片序列与 A 的码片求内积：1-1+3+1-1+3+1+1=8/8=1</li>\n<li>接收的码片序列与 B 的码片求内积：1-1-3-1-1-3+1-1=-8/8=-1</li>\n<li>接收的码片序列与 C 的码片求内积：1+1+3+1-1-3-1-1=0</li>\n<li>接收的码片序列与 D 的码片求内积：1+1+3-1+1+3+1-1=8/8=1</li>\n<li>因此 A,B,D 发送了数据，A 发送了比特 1，B 发送了比特 0，D 发送了比特 1</li>\n</ul>\n<p>复用与多址区分：</p>\n<ul>\n<li>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源上看，每个子信道只占用该媒体频带资源的一部分</li>\n<li>多址 (更确切地应该称为多点接入) 处理的是动态分配信道给用户。这在用户仅仅暂时性地占用信道的应用中是必须的，而所有的移动通信系统基本上都属于这种情况。相反，在信道永久性地分配给用户的应用中，多址是不需要的（对于无线广播或电视广播站就是这样的）</li>\n<li>某种程度上，FDMA、TDMA、CDMA 可以分别看成是 FDM，TDM，CDM 的应用</li>\n</ul>\n<h3 id=\"随机接入csmacd协议\"><a class=\"anchor\" href=\"#随机接入csmacd协议\">#</a> 随机接入 ——CSMA/CD 协议</h3>\n<p>总线局域网使用的协议：载波监听多址接入 / 碰撞检测  CSMA/CD 协议</p>\n<p><strong>多址接入 MA</strong></p>\n<ul>\n<li>多个站点接在一条总线上，竞争使用总线</li>\n</ul>\n<p><strong>载波监听 CS</strong></p>\n<ul>\n<li>每一个站在发送帧之前先要检测一下总线上是否有其他站点在发送帧 (&quot;先听后说&quot;)\n<ul>\n<li>若检测到总线空闲 96 比特时间，则发送比特帧</li>\n<li>若检测到总线忙，则继续检测并等待总线为空闲 96 比特时间，然后发送这个帧</li>\n</ul>\n</li>\n</ul>\n<p>注：96 比特时间指发送 96 比特所耗费的时间，也称为帧间最小间隔，其作用是使接收方可以检测出一个帧的结束，同时也使得所有其他站点都能有机会平等竞争信道并发送帧</p>\n<p><strong>碰撞检测 CD</strong></p>\n<ul>\n<li>每一个正在发送帧的站边发送边检测碰撞（&quot;边说边听&quot;）\n<ul>\n<li>一旦发现总线上出现碰撞，则立即停止发送，退避一段随机时间后再次发送（&quot;一旦冲突，立即听说，等待时间，重新再说&quot;）</li>\n</ul>\n</li>\n</ul>\n<p>以太网还采取了一种叫强化碰撞的措施。当发送帧的站点一旦检测到碰撞，除了立即停止发送帧外，还要再继续发送 32 比特或 48 比特人为干扰信号，以便有足够多的碰撞信号碰撞信号使所有站点都能检测出碰撞</p>\n<p><strong>争用期（碰撞窗口）</strong></p>\n<p>以太网单程端到端传播时间为 t</p>\n<ul>\n<li>\n<p>主机最多经过 2t 的时长就可检测到本次发送是否遭受了碰撞</p>\n</li>\n<li>\n<p>因此，以太网的端到端往返传播时延 2t 称为争用期或碰撞窗口</p>\n</li>\n<li>\n<p>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞</p>\n</li>\n<li>\n<p>每一个主机在自己发送帧之后的一小段时间内，存在着遭遇碰撞的可能性。这一小段时间是不确定的。它取决于另一个发送帧的主机到本主机的距离，但不会超过总线的端到端往返传播时延，即一个争用期时间</p>\n</li>\n<li>\n<p>显然，在以太网中发送帧的主机太多，端到端往返传播时延越大，发生的碰撞概率就越大。因此，共享式以太网不能连接太多的主机，使用的总线也不能太长</p>\n<ul>\n<li>10Mb/s 以太网把争用周期为 512 比特发送时间，即 51.2μs，因此其总线长度不能超过 5120m，但考虑到其他一些因素，如信号衰减等，以太网规定总线长度不能超过 2500m</li>\n</ul>\n</li>\n</ul>\n<p><strong>最小帧长</strong></p>\n<p>使用 CSMA/CD 协议的以太网的帧长不能太短</p>\n<ul>\n<li>以太网规定最小帧长为 64 字节，即 512 比特（512 比特时间即为争用期）</li>\n</ul>\n<p>以太网的最小帧长确保了主机可在帧发送完成之前就检测到该帧的发送过程中是否遭遇了碰撞</p>\n<ul>\n<li>\n<p>最小帧长 = 争用起 * 数据传输速率</p>\n</li>\n<li>\n<p>如果在争用期（共发送 64 字节）没有检测到碰撞，那么后续发送的数据就一定不会发生碰撞</p>\n</li>\n<li>\n<p>如果在争用期内检测到了碰撞，就立即终止发送，这时已经发送出去的数据一定小于 64 字节，因此凡长度小于 64 字节的帧都是由于碰撞而异常中止的无效帧</p>\n</li>\n</ul>\n<p><strong>最大帧长</strong></p>\n<p>限定最大帧长防止占用总线时间过长，或者由于帧长过长导致接收方缓冲区溢出</p>\n<p><strong>截断二进制指数退避算法</strong></p>\n<p>退避时间 = 基本退避时间（争用期 2t）* 随机数 r（从离散的整数集合 0 到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding=\"application/x-tex\">2^k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.849108em;vertical-align:0em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span></span></span></span> 中随机选出一个数 k=Min (重传次数，10)）</p>\n<p>若连续多次发生碰撞，就表明可能有较多的主机参与竞争信道。但使用上述退避算法可使重传需要推迟的平均时间随重传次数而增大（这也称为动态退避），因而减小发生碰撞的概率，有利于整个系统的稳定</p>\n<p>当重传 16 次仍不能成功时，表明同时打算发送帧的主机太多，以至于连续发生碰撞，则丢弃该帧，并向高层报告</p>\n<p><strong>信道利用率</strong></p>\n<p>考虑以下理想情况：</p>\n<ul>\n<li>\n<p>各主机发送帧都不会产生碰撞</p>\n</li>\n<li>\n<p>总线一旦空闲就有某个主机立即发送帧</p>\n</li>\n<li>\n<p>发送一帧占用总线时间为 T0+t，则帧本身的发送时间为 T0</p>\n<ul>\n<li>极限信道利用率 Smax=1/(1+a),a=t/T0</li>\n</ul>\n</li>\n<li>\n<p>参数 a 的值尽量小，以提高信道利用率，以太网端到端的距离受到限制</p>\n</li>\n<li>\n<p>以太网帧的长度应尽量长些</p>\n</li>\n</ul>\n<p><strong>帧发送流程</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/AkW3blvRNTsjta7.png\" alt=\"帧发送流程\" /></p>\n<p><strong>帧接收流程</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/10/BLEFc76ziy51eXC.png\" alt=\"帧接收流程\" /></p>\n<p>CSMA/CD 协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中</p>\n<p>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用 CSMA/CD 协议</p>\n<p><strong>习题</strong></p>\n<p>1、下列关于 CSMA/CD 协议的叙述中，错误的是 (B)</p>\n<p>A. 边发送数据帧，边检测是否产生冲突</p>\n<p>B. 适用于无线网络，以实现无线链路共享</p>\n<p>C. 需要根据网络跨距和数据传输速率限定最小帧长</p>\n<p>D. 当信号传播延迟趋近于 0 时，信道利用率趋近于 100%</p>\n<p>解析：选项 A 描述的是碰撞检测；选项 B，CSMA/CD 协议不适用于无线网络，对于无线网络，可以使用 CSMA/CA 协议；选项 C，网络跨距相当于给出了端到端传播时延 t，进而得出争用周期 2t，再乘以数据传输速率即为最小帧长，描述正确；选项 D，从极限信道利用率可以看出</p>\n<p>2、在采用一个 CSMA/CD 协议的网络中，传输介质是一根完整的电缆，传输速率为 1Gbps，电缆中信号传播速度是 200000km/s。若最小数据帧长度减少 800 比特，则最远的两个站点之间的距离至少需要（D）</p>\n<p>A. 增加 160m     B. 增加 80m      C. 减少 160m     D. 减少 80m</p>\n<p>解析：设最远两个站点之间的距离为 d (m)，最小帧长为 l (bit)，最小帧长 = 争用期 * 数据传输速率</p>\n<p 10=\"\">l=(\\dfrac{d}{200000\\times10^3}\\times2)\\times10^9,d=\\frac{l}</p>\n<p>若最小帧长减少 800 比特，最远的两个站点的距离至少会减少 80m</p>\n<p>3、某局域网采用 CSMA/CD 协议实现介质访问控制，数据传输速率为 10Mbps，主机甲和主机乙之间的距离为 2km，信号传播速度是 200000km/s，请回答下列问题，要求说明理由或写出计算过程</p>\n<p>（1）如主机甲和主机乙发送数据时发生冲突，则从开始发送数据时刻起，到两台主机均检测到冲突时刻止，最短需经过了多长时间？最长需经过多长时间（假设主机甲和主机乙发送数据过程中，其他主机不发送数据）?</p>\n<p>解析：两主机同时发送数据，两主机检测到冲突时间最短，时间为 2km/200000km/s=0.01ms</p>\n<p>当时间最长时，一台主机发送信息快要到另一台主机时，另一台主机发送信息，造成冲突，最长时间为 4km/200000km/s=0.02ms</p>\n<h3 id=\"随机接入csmaca协议\"><a class=\"anchor\" href=\"#随机接入csmaca协议\">#</a> 随机接入 ——CSMA/CA 协议</h3>\n<p>无线局域网使用的协议：载波监听多址接入 / 碰撞避免 CSMA/CA 协议</p>\n<p>在无线局域网中，仍然可以使用载波监听多址接入 CSMA，即在发送帧之前先对传输媒体进行载波监听，若发现有其他站在发送帧，就推迟发送以免发生碰撞。</p>\n<p>在无线局域网中，不能使用碰撞检测 CD，原因如下：</p>\n<ul>\n<li>由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号强度往往会远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测 CD，对硬件的要求非常高</li>\n<li>即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在隐蔽站问题），进行碰撞检测的意义也不大\n<ul>\n<li>隐蔽站问题：未能检测出信道上其他站点信号的问题</li>\n</ul>\n</li>\n</ul>\n<p>802.11 无线局域网使用 CSMA/CA 协议，在 CSMA 的基础上增加了一个碰撞避免 CA 功能，而不再实现碰撞检测功能</p>\n<p>由于不可能避免所有的碰撞，并且无线信道误码率较高，802.11 标准还使用了数据链路层确认机制 (停止 - 等待协议) 来保证数据被正确接收</p>\n<p>802.11 的 MAC 层标准定义了两种不同的媒体接入控制方式：</p>\n<ul>\n<li>分布式协调功能 DCF。在 DCF 方式下，没有中心控制站点，每个站点使用 CSMA/CA 协议通过争用信道来获取发送权，这是 802.11 定义的默认方式</li>\n<li>点协调功能 PCF。PCF 方式使用集中控制的接入算法（一般在接入点 AP 实现集中控制），是 802.11 定义的可选方式，在实际中较少使用</li>\n</ul>\n<p><strong>帧间间隔 IFS</strong></p>\n<ul>\n<li>802.11 标准规定，所有站点必须在持续检测到信道空闲一段指定时间后才能发送帧，这段时间称为帧间间隔</li>\n<li>帧间间隔的长短取决于该站点要发送的帧的类型：\n<ul>\n<li>高优先级需要等待的时间较短，因此可优先获得发送权</li>\n<li>低优先级帧需要等待的时间较长。若某个站点的低优先级帧还没来得及发送，而其他站的高优先级帧已发送到信道上，则信道变为忙态，因而低优先级帧就只能再推迟发送。这样就减少了发生碰撞的机会</li>\n</ul>\n</li>\n<li>常用的两种帧间间隔如下：\n<ul>\n<li>短帧间间隔 SIFS（28μs），是最短的帧间间隔，用来分隔开属于一次对话的各帧。一个站点应当能够在这段时间内从发送方式切换到接收方式。使用 SIFS 的帧类型有 ACK 帧、CTS 帧、由过长的 MAC 帧分片后的数据帧，以及所有回答 AP 探询的帧和 PCF 方式中介入点 AP 发送出的任何帧</li>\n<li>DCF 帧间间隔 DIFS（128μs），它比短帧间间隔 SIFS 长得多，在 DCF 方式中用来发送数据帧和管理帧</li>\n</ul>\n</li>\n</ul>\n<p><strong>CSMA/CA 协议的工作原理</strong></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/07/NPIpqZ2YLdnsREh.png\" alt=\"工作原理1\" /></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/07/seAwZxKYyPW1cz7.png\" alt=\"工作原理2\" /></p>\n<p><img data-src=\"https://s2.loli.net/2024/08/07/kKfTvE3yOeQn7tz.png\" alt=\"工作原理3\" /></p>\n<ul>\n<li>当站点检测到信道是空闲的，并且发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法</li>\n<li>以下情况必须使用退避算法\n<ul>\n<li>在发送数据帧之前检测到了处于忙状态时</li>\n<li>在每一次重传一个数据帧时</li>\n<li>在每一次成功发送后要连续发送下一个帧时（这是为了避免第一个站点长时间占用信道）</li>\n</ul>\n</li>\n</ul>\n<p><strong>CSMA/CA 的退避算法</strong></p>\n<ul>\n<li>在执行退避算法时，站点为退避计时器设置一个随机地退避时间\n<ul>\n<li>当退避计时器的时间减小到零时，就开始发送数据</li>\n<li>当退避计时器的时间还未减小到零时而信道又转变为忙状态，这时就冻结退避计时器的数值，重新等待信道变为空闲，再经时间 DIFS 后，继续启动退避计时器</li>\n</ul>\n</li>\n<li>在进行第 i 次退避时，退避时间在时隙编号（0,1,...,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mrow><mn>2</mn><mo>+</mo><mi>i</mi></mrow></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{2+i}+1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.907994em;vertical-align:-0.08333em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.824664em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">i</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span></span></span></span>）中随机选择一个，然后乘以基本退避时间（也就是一个时隙的长度）就可以得到随机地退避时间。这样做是为了使不同站点选择相同退避时间的概率减少。当时隙编号达到 255 时（对应第 6 次退避）就不再增加了</li>\n</ul>\n<p><strong>CSMA/CA 协议的信道预约和虚拟载波监听</strong></p>\n<ul>\n<li>\n<p>为了尽可能减少碰撞的概率和降低碰撞的影响，802.11 标准允许要发送数据的站点对值进行预约</p>\n<ul>\n<li>源站在发送数据帧之前先发送一个短的控制帧，称为请求发送 RTS，它包括源地址、目的地址以及这次通信（包括相应的确认帧）所需的控制时间</li>\n<li>若目的站正确收到源站发来的 RTS 帧，且媒体空闲，就发送一个响应控制帧，称为允许发送 CTS，它也包括这次通信所需的持续时间（从 RTS 帧中将此持续时间复制到 CTS 帧中）</li>\n<li>源站收到 CTS 帧后，再等待一段时间 SIFS 后，就可发送其数据帧</li>\n<li>若目的站正确受到了源站发来的数据帧，在等待时间 SIFS 后，就向源站发送确认帧 ACK</li>\n</ul>\n</li>\n<li>\n<p>除源站和目的站以外的其他各站，在收到 CTS 帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通道的通信不会受到其他站的干扰</p>\n</li>\n<li>\n<p>如果 RTS 帧发生了碰撞，源站就收不到 CTS 帧，需执行退避算法重传 RTS 帧</p>\n</li>\n<li>\n<p>由于 RTS 帧和 CTS 帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其发送时延往往大于传播时延（因为是局域网），碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。802.11 标准规定了 3 种情况供用户选择：</p>\n<ul>\n<li>使用 RTS 帧和 CTS 帧</li>\n<li>不使用 RTS 帧和 CTS 帧</li>\n<li>只有当数据帧的长度超过某一数值时才使用 RTS 帧和 CTS 帧</li>\n</ul>\n</li>\n<li>\n<p>除 RTS 帧和 CTS 帧会携带通信需要持续的时间，数据帧也能携带通信需要持续的时间，这称为 802.11 的虚拟载波监听机制</p>\n</li>\n<li>\n<p>由于利用虚拟载波监听机制，站点只要监听 RTS 帧、CTS 帧或数据帧的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题</p>\n</li>\n</ul>\n<p><strong>练习</strong></p>\n<p>1、下列选项中，对正确接收到的数据帧进行确认的 MAC 协议是（D）</p>\n<p>A.CSMA     B.CDMA         C.CSMA/CD        D.CSMA/CA</p>\n<p>解析：CSMA 是指载波监听多址接入，并不使用确认机制；CSMA/CD 是指载波监听多址接入 / 碰撞检测，是对 CSMA 的改进，是早期共享信道以太网使用的信道访问控制协议，并不使用确认机制；CSMA/CA 是指载波监听多址接入 / 碰撞避免，是 802.11 局域网采用的无线信道访问控制协议。802.11 局域网在使用 CSMA/CA 的同时，还使用停止 - 等待协议。这是因为无线信道的通信质量远不如有线信道，因此无线站点每发送完一个数据帧后，要等到收到对方的确认帧后才能继续发送下一帧。CDMA 是指码分多址，属于静态划分信道，是物理层的信道复用技术，而不属于 MAC 协议</p>\n<p>2、下列介质访问控制方式中，可能发生冲突的是（B）</p>\n<p>A.CDMA     B.CSMA     C.TDMA        D.FDMA</p>\n<p>解析：CDMA 是码分多址、TDMA 是时分多址、FDMA 是指频分多址、CSMA 是指载波监听多址接入。TDMA、CDMA、FDMA 是常见的物理层信道复用技术，属于静态划分信息，用于多用户共享信道，不会发生冲突。CSMA 属于争用型的媒体接入控制协议，连接在同一媒体上的多个站点使用该协议以竞争方式发送数据帧，可能出现冲突（也称为碰撞）</p>\n<p>3、IEEE 802.11 无线局域网的 MAC 协议 CSMA/CA 进行信道预约的方法是（D）</p>\n<p>A. 发送确认帧     B. 采用二进制指数退避     C. 使用多个 MAC 地址      D. 交换 RTS 与 CTS 帧</p>\n<p>解析：CSMA/CA 协议使用 RTS 和 CTS 帧来预约信道，它们都携带有通信需要持续的时间。另外，除 RTS 和 CTS 帧外，数据帧也能携带通信需要持续的时间，这是 802.11 的虚拟载波监听。</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-2-2/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-2-2/",
            "title": "计网408-2-2",
            "date_published": "2024-08-05T08:49:30.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<p>1、在物理层接口特性中，用于描述完成每种功能的时间发生顺序的是 (C)</p>\n<p>A. 机械特性      B. 功能特性       C. 过程特性          D. 电气特性</p>\n<p>解析：过程特性指明不同功能的各种可能事件的出现顺序</p>\n<p>2、下列选项中，不属于物理层接口规范定义范畴的是（C）</p>\n<p>A. 接口形状    B. 引脚功能       C. 物理地址      D. 信号电平</p>\n<p>解析：接口形状属于机械特性，引脚功能属于功能特性，信号电平属于电气特性，物理地址属于数据链路层，MAC 地址</p>\n<p>3、在无噪声情况下，若某通道链路的带宽为 3kHz，采用 4 个相位，每个相位具有 4 种调制的 QAM 调制技术，则该通信链路的最大数据传输速率为（B）</p>\n<p>A.12kbps   B.24kbps     C.48kbps     D.96kbps</p>\n<p>解析：一个波特有 16 种信息，需要用 4 个比特来表示，最大数据传输速率为 2W=2*3kHz*4=24kbps</p>\n<p>4、若某通信链路的数据传输速率为 2400bps，采用 4 相位调制，则该链路的波特率是（B）</p>\n<p>A.600 波特     B.1200 波特    C.4800 波特       D.9600 波特</p>\n<p>解析：一个波特有 4 种信息，需要用 2 个比特来表示，波特率 = 2400bps/2=1200 波特</p>\n<p>5、若连接 R2 和 R3 链路的频率带宽为 8kHz，信噪比为 30dB，该链路的实际数据传输速率约为最大理论数据的 50%，则该链路的实际传输速率为（C）</p>\n<p>A.8kbps    B.20kbps       C.40kbps      D.80kbps</p>\n<p>解析：求出 S/N，10lg (S/N)=30dB，因此 S/N=1000，最大传输速率由香农公式计算得到 c=W*log2 (1+S/N)=8kHz*10=80kbps，实际速率为最大理论数据的 50%，因此实际传输速率为 40kbps</p>\n<p>6、下列因素中，不会影响信道数据传输的是（D）</p>\n<p>A. 信噪比      B. 频率带宽           C. 调制速度     D. 信道传播速度</p>\n<p>解析：由香农定理得到 A 和 B 是有关的，由奈氏定理得到 C 是有关的</p>\n<p>7、若信道在无噪声情况下的极限传输速率不小于信噪比为 30dB 条件下的极限传输速率，则信号状态数至少是（D）</p>\n<p>A.4      B.8        C.16         D.32</p>\n<p>解析：信道比为 30dB 时，S/N=1000，最大传输速率为 10W，根据奈氏定理，最大传输速率为 2W，因此一个波特至少要用 5 个比特来表示，因此状态数至少为 2 的五次方为 32</p>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-4/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-4/",
            "title": "操作系统408-2-4",
            "date_published": "2024-08-04T13:32:38.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"死锁的概念\"><a class=\"anchor\" href=\"#死锁的概念\">#</a> 死锁的概念</h3>\n<p>死锁：在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</p>\n<p>发生死锁后若无外力干涉，这些进程都将无法向前推进</p>\n<p><strong>死锁、饥饿和死循环的区别</strong></p>\n<p>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>\n<p>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象。</p>\n<p>死循环：某进程执行过程中一直跳不出某个循环的现象</p>\n<p>共同点：都是进程无法顺利向前推进的现象 (故意设计的死循环除外)</p>\n<p>区别：</p>\n<ul>\n<li>死锁：死锁一定是 &quot;循环等待对方手里的资源&quot; 导致的，因此如果有死锁现象，那至少由两个或两个以上的进程同时发生死锁。另外，发生死锁的进程一定处于阻塞态</li>\n<li>饥饿：可能只有一个进程发生饥饿。发生饥饿的进程既可能是阻塞态 (如长期得不到需要 I/O 的设备)，也可能是就绪态（长期得不到处理机）</li>\n<li>死循环：可能只有一个进程发生死循环。死循环的进程可以上处理机运行 (可以是运行态)，只不过无法像期待的那样顺利推进。死锁和饥饿问题是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑的错误导致的。死锁和饥饿是管理者 (操作系统) 的问题，死循环是被管理者的问题</li>\n</ul>\n<p><strong>产生死锁的必要条件</strong></p>\n<p>产生死锁必须同时满足以下四个条件，只要其中一个不满足就不会发生：</p>\n<ul>\n<li>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。</li>\n<li>不剥夺条件：进程所获得的资源在未使用完之前、不能由其他进程强行夺走，只能主动释放</li>\n<li>请求和保持：进程已经保持了至少一个资源，但是又提出了新的请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放</li>\n<li>循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求</li>\n</ul>\n<p>注意：发生死锁时一定有循环等待，但是发生循环等待时未必死锁</p>\n<p><strong>什么时候会发生死锁</strong></p>\n<ul>\n<li>对系统资源的竞争。各进程对不可剥夺的资源的竞争可能引起死锁</li>\n<li>进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁</li>\n<li>信号量的使用不当也会导致死锁</li>\n</ul>\n<p>总之，对不可剥夺资源的不合理分配可能导致死锁</p>\n<h3 id=\"死锁处理策略预防死锁\"><a class=\"anchor\" href=\"#死锁处理策略预防死锁\">#</a> 死锁处理策略 —— 预防死锁</h3>\n<p>预防死锁：破坏死锁产生的四个必要条件中的一个或几个</p>\n<h4 id=\"破坏互斥条件\"><a class=\"anchor\" href=\"#破坏互斥条件\">#</a> 破坏互斥条件</h4>\n<p>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁</p>\n<p>如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。</p>\n<p>SPOOLing 技术，操作系统采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。</p>\n<p>使用了 SPOOLing 技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待。</p>\n<p>这样策略的缺点：并不是所有的资源都可以改造成可共享使用的资源。并且为了系统安装，很多地方还必须保护这种互斥性，因此很多时候无法破坏互斥条件</p>\n<h4 id=\"破坏不剥夺条件\"><a class=\"anchor\" href=\"#破坏不剥夺条件\">#</a> 破坏不剥夺条件</h4>\n<p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</p>\n<p>破坏不剥夺条件：</p>\n<ul>\n<li>当某个进程请求新的资源得不到满足时，它必须立刻释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件</li>\n<li>当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）</li>\n</ul>\n<p>该策略的缺点：</p>\n<ul>\n<li>实现起来比较复杂</li>\n<li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如 CPU</li>\n<li>反复地申请和释放资源会增加系统开销，降低系统吞吐量</li>\n<li>若采用第一个方案，意味着只要暂时得不到某个资源，之前获得的那些资源都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿</li>\n</ul>\n<h4 id=\"破坏请求和保持条件\"><a class=\"anchor\" href=\"#破坏请求和保持条件\">#</a> 破坏请求和保持条件</h4>\n<p>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求。而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。</p>\n<p>可以采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程不会再请求别的任何资源了</p>\n<p>该策略实现简单，但也有明显缺点：</p>\n<p>有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，资源利用率极低。另外，该策略也有可能导致某些进程饥饿</p>\n<h4 id=\"破坏循环等待条件\"><a class=\"anchor\" href=\"#破坏循环等待条件\">#</a> 破坏循环等待条件</h4>\n<p>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已经获得的资源同时被下一个进程所请求</p>\n<p>可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源 (即编号相同的资源) 一次申请完</p>\n<p>原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而不会产生循环等待现象</p>\n<p>该策略的缺点：</p>\n<ul>\n<li>不方便增加新的设备，因为可能需要重新分配所有的编号</li>\n<li>进程实际使用资源的顺序可能和编号递增顺序不一致会导致资源浪费</li>\n<li>必须按规定次序申请资源，用户编程麻烦</li>\n</ul>\n<h3 id=\"死锁处理策略避免死锁\"><a class=\"anchor\" href=\"#死锁处理策略避免死锁\">#</a> 死锁处理策略 —— 避免死锁</h3>\n<p>避免死锁：用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</p>\n<p>安全序列：指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态，当然，安全序列可能有多个</p>\n<p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了一个不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。</p>\n<p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁 (处于不安全状态未必就是发生了死锁，但发生死锁时，一定是在不安全状态)</p>\n<p><strong>银行家算法</strong></p>\n<p>银行家算法核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待</p>\n<p>假设系统中有 n 个进程，m 种资源</p>\n<p>每个进程在运行前先声明对各种资源的最大需求数，则可用一个 n*m 的矩阵表示所有进程对各种资源的最大需求数，称为最大需求矩阵 Max，Max [i,j]=k 表示进程 Pi 最多需要 k 个资源 Rj。同理，系统可以用一个 n*m 的分配矩阵 Allocation Need 矩阵，表示各进程最多还需要多少各类资源。</p>\n<p>另外，还要用一个长度为 m 的一维数组 Available 表示当前系统中还有多少可用资源</p>\n<p>某进程 Pi 向系统申请资源，可用一个长度为 m 的一维数组 Request 表示本次申请的各种资源量。</p>\n<p>可用银行家算法预判本次分配是否会导致系统进入不安全状态：</p>\n<ul>\n<li>如果<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>≤</mo><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Request_i[j]\\le Need[j](0\\le j\\le m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span> 便转向第二步；否则认为出错</li>\n<li>如果<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>≤</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo stretchy=\"false\">(</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>m</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">Request_i[j]\\le Available[j](0\\le j\\le m)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mopen\">(</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.85396em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">≤</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">m</span><span class=\"mclose\">)</span></span></span></span>，便转向第三步；否则表示尚无足够资源，Pi 必须等待</li>\n<li>系统试探着把资源分配给进程 Pi，并修改相应的数据 (并非真的分配，修改数值只是为了做预判)：</li>\n</ul>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo>=</mo><mi>A</mi><mi>v</mi><mi>a</mi><mi>i</mi><mi>l</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi><mo>−</mo><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub><mspace linebreak=\"newline\"></mspace><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>A</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>+</mo><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mspace linebreak=\"newline\"></mspace><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>=</mo><mi>N</mi><mi>e</mi><mi>e</mi><mi>d</mi><mo stretchy=\"false\">[</mo><mi>i</mi><mo separator=\"true\">,</mo><mi>j</mi><mo stretchy=\"false\">]</mo><mo>−</mo><mi>R</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub><mo stretchy=\"false\">[</mo><mi>j</mi><mo stretchy=\"false\">]</mo></mrow><annotation encoding=\"application/x-tex\">Available=Available-Request_i\\\\Allocation[i,j]=Allocation[i,j]+Request_i[j]\\\\Need[i,j]=Need[i,j]-Request_i[j]\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.77777em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">b</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">A</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">c</span><span class=\"mord mathnormal\">a</span><span class=\"mord mathnormal\">t</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span><span class=\"mspace newline\"></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">d</span><span class=\"mopen\">[</span><span class=\"mord mathnormal\">i</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.00773em;\">R</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">q</span><span class=\"mord mathnormal\">u</span><span class=\"mord mathnormal\">e</span><span class=\"mord mathnormal\">s</span><span class=\"mord\"><span class=\"mord mathnormal\">t</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathnormal mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">[</span><span class=\"mord mathnormal\" style=\"margin-right:0.05724em;\">j</span><span class=\"mclose\">]</span></span></span></span></span></p>\n<ul>\n<li>操作系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待</li>\n</ul>\n<p><strong>银行家算法步骤</strong></p>\n<ul>\n<li>检查此次申请是否超过了之前声明的最大需求数</li>\n<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>\n<li>试探着分配，更改各数据结构</li>\n<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>\n</ul>\n<p><strong>安全性算法步骤</strong></p>\n<p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收。</p>\n<p>不断重复上述过程，看最终是否能让所有进程都加入安全序列</p>\n<p>注意：</p>\n<p>系统处于不安全状态未必死锁，但死锁时一定处于不安全状态，系统处于安全状态一定不会死锁</p>\n<h3 id=\"死锁处理策略检测和解除\"><a class=\"anchor\" href=\"#死锁处理策略检测和解除\">#</a> 死锁处理策略 —— 检测和解除</h3>\n<p>死锁的检测和解除：允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</p>\n<p>如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：</p>\n<ul>\n<li>死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</li>\n<li>死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。</li>\n</ul>\n<p><strong>死锁的检测</strong></p>\n<p>为了能对系统是否已发生了死锁进行检测，必须：</p>\n<ul>\n<li>用某种数据结构来保存资源的请求和分配信息</li>\n<li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态</li>\n</ul>\n<p>数据结构：</p>\n<ul>\n<li>两种节点\n<ul>\n<li>进程节点：对应一个进程</li>\n<li>资源节点：对应一类资源，一类资源可能有多个</li>\n</ul>\n</li>\n<li>两种边\n<ul>\n<li>进程节点 -&gt; 资源节点：表示进程想申请几个资源（每条边代表一个）</li>\n<li>资源节点 -&gt; 进程节点：表示已经为进程分配了几个资源（每条边代表一个）</li>\n</ul>\n</li>\n</ul>\n<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去</p>\n<p>如果这个进程执行结束了把资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去</p>\n<p>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁 (相当于能找到了一个安全序列)</p>\n<p>如果最终不能消除所有边，那么此时就是发生了死锁</p>\n<p>最终还连着边的那些进程就是处于死锁状态的进程</p>\n<p>检测死锁的算法：</p>\n<ul>\n<li>在资源分配图中，找出不阻塞又不是孤点的进程 Pi (即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成。然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之称为孤立的节点。</li>\n<li>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。根据上面的方法进行一系列简化后，若能消去途中所有的边，则称该图是可完全简化的</li>\n</ul>\n<p>死锁定理：如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p>\n<p><strong>死锁的解除</strong></p>\n<p>一旦检测出死锁的发生，就应该立即解除死锁。</p>\n<p>补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着的那些进程就是死锁进程</p>\n<p>解除死锁的方法有：</p>\n<ul>\n<li>资源剥夺法。挂起 (暂时放到外存上) 某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿</li>\n<li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来</li>\n<li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点</li>\n</ul>\n<p>考虑对哪些进程处理：</p>\n<ul>\n<li>进程优先级</li>\n<li>已执行多长时间</li>\n<li>还要多久能够完成</li>\n<li>进程已经使用了多少资源</li>\n<li>进程是交互式的还是批处理式的</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-2-1/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-2-1/",
            "title": "计网408-2-1",
            "date_published": "2024-08-03T09:15:08.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"物理层的基本概念\"><a class=\"anchor\" href=\"#物理层的基本概念\">#</a> 物理层的基本概念</h3>\n<ul>\n<li>物理层考虑的是怎样才能连接各种计算机的传输媒体上传输数据比特流</li>\n<li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</li>\n</ul>\n<p><strong>物理层协议的主要任务</strong></p>\n<ul>\n<li>机械特性：指明接口所用接口器的形状和尺寸、引脚数目和排列、固定和锁定装置</li>\n<li>电气特性：指明在接口电缆的各条线上出现的电压的范围</li>\n<li>功能特性：指明某条线上出现的某一电平的电压表示何种意义</li>\n<li>过程特性：指明对于不同功能的各种可能事件的出现顺序</li>\n</ul>\n<h3 id=\"物理层下面的传输媒体\"><a class=\"anchor\" href=\"#物理层下面的传输媒体\">#</a> 物理层下面的传输媒体</h3>\n<p><strong>导引型传输媒体</strong></p>\n<ul>\n<li>\n<p>同轴电缆：价格较贵且布线不够灵活和方便，随着集线器的出现，在局域网领域基本上都是采用双绞线作为传输媒体</p>\n<ul>\n<li>基带同轴电缆 (50Ω)：数字传输，过去用于局域网</li>\n<li>宽带同轴电缆：模拟传输，目前主要用于有线电缆</li>\n</ul>\n</li>\n<li>\n<p>双绞线</p>\n<ul>\n<li>绞合的作用\n<ul>\n<li>抵御部分来自外界的电磁波干扰</li>\n<li>减少相邻导线的电磁干扰</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>光纤</p>\n<ul>\n<li>光纤的优点：\n<ul>\n<li>通信容量大（25000~30000GHz 的带宽）</li>\n<li>传输损耗小，远距离传输时更加经济</li>\n<li>抗雷和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要</li>\n<li>无串音干扰，保密性好，不易被窃听</li>\n<li>体积小、重量轻</li>\n</ul>\n</li>\n<li>光纤的缺点：\n<ul>\n<li>割接需要专用设备</li>\n<li>光电接口价格较贵</li>\n</ul>\n</li>\n<li>光纤的原理：\n<ul>\n<li>当光从高折射率的媒体射向低折射率的媒体时，其折射角大于入射角</li>\n<li>因此，如果入射角足够大，就会出现全反射，即光碰到包层时，就会反射回纤芯</li>\n<li>光在纤芯的传输方式是不断全反射</li>\n</ul>\n</li>\n<li>多模光纤\n<ul>\n<li>由于色散 (模式、材料、波导色散)，光在多模光纤中传输一定距离后必然产生信号失真 (脉冲展宽)</li>\n<li>因此，多模光纤只适合近距离传输 (建筑物内)</li>\n<li>发送光源：发光二极管；接收检测：光电二极管</li>\n</ul>\n</li>\n<li>单模光纤\n<ul>\n<li>没有模式色散，在 1.31 微米波长附近材料色散和波导色散大小相等符号相反，两者正好抵消</li>\n<li>单模光纤适合长距离传输且衰减小，但其制造成本高，对光源要求高</li>\n<li>发送光源：激光发射器；接收检测：激光检波器</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>电力线</p>\n</li>\n</ul>\n<p><strong>非导引型传输媒体</strong></p>\n<ul>\n<li>无线电波</li>\n<li>微波</li>\n<li>红外线\n<ul>\n<li>点对点传输</li>\n<li>直线传输，中间不能有障碍物，传输距离短</li>\n<li>传输速率低</li>\n</ul>\n</li>\n<li>可见光</li>\n</ul>\n<h4 id=\"传输方式\"><a class=\"anchor\" href=\"#传输方式\">#</a> 传输方式</h4>\n<p><strong>串行、并行传输</strong></p>\n<p>远距离传输：串行传输</p>\n<p>计算机内部传输：并行传输</p>\n<p><strong>同步、异步传输</strong></p>\n<ul>\n<li>同步传输\n<ul>\n<li>数据块以稳定的比特流的形式传输，字节之间没有间隔。</li>\n<li>接收端在每个比特信号的中间时刻进行检测，以判断接收到的是比特 0 还是比特 1。</li>\n<li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同。</li>\n<li>在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位。因此需要采取方法使收发双方的时钟保持同步\n<ul>\n<li>收房双方时钟同步的方法\n<ul>\n<li>外同步：在收发双方之间添加一条单独的时钟信号线</li>\n<li>内同步：发送端将时钟同步信号编码到发送数据中一起传输 (例如曼切斯特编码)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>异步传输\n<ul>\n<li>以字节为独立的传输单位，字节之间的时间间隔不是固定的</li>\n<li>接收端仅在每个字节的起始处对字节内的比特实现同步，为此，通常要在每个字节前后分别加上起始位和结束位</li>\n<li>字节之间异步 (字节之间的时间间隔不固定)</li>\n<li>字节中的每个比特仍然要同步 (各比特的持续时间是相同的)</li>\n</ul>\n</li>\n</ul>\n<p><strong>单工、半双工、全双工</strong></p>\n<ul>\n<li>单向通信（单工）\n<ul>\n<li>通信双方只有一个数据传输方向</li>\n</ul>\n</li>\n<li>双向交替通信（半双工）\n<ul>\n<li>通信双方可以相互传输数据，但不能同时进行</li>\n</ul>\n</li>\n<li>双向同时通信（全双工）\n<ul>\n<li>通信双方可以同时发送和接受信息</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"编码与调制\"><a class=\"anchor\" href=\"#编码与调制\">#</a> 编码与调制</h3>\n<p>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/05/CDdSrg3koi7bFKs.png\" alt=\"编码与调制\" /></p>\n<p><strong>常用编码</strong></p>\n<ul>\n<li>不归零编码：用正电平表示比特 1，用负电平表示比特 0（NRZ）\n<ul>\n<li>需要额外一根传输线来传输时钟信号，使发送方和接收方同步</li>\n<li>对于计算机网络，宁愿利用这根线传输线传输数据信号，而不是传输时钟信号</li>\n<li>由于同步问题，计算机网络不采用这种编码</li>\n</ul>\n</li>\n<li>归零编码（RZ）\n<ul>\n<li>每个码元传输结束后都要归零，所以接收方只要在信号归零后进行采样即可，不需要单独的时钟信号</li>\n<li>实际上，归零编码相当于把时钟信号用 &quot;归零&quot; 方式编码在了数据之内，这称为 &quot;自同步&quot; 信号</li>\n<li>但是，归零编码中大部分的数据带宽都用来传输 &quot;归零&quot; 而浪费掉了</li>\n</ul>\n</li>\n<li>反向不归零编码（NRZI）\n<ul>\n<li>在码元时间内不会出现零电平</li>\n<li>若后一个码元时间内所持续电平与前一个码元时间内所持续的电平不同 (也称为电平反转) 则表示 0，若电平保持不变则表示 1</li>\n</ul>\n</li>\n<li>曼切斯特编码（传统以太网 10Mb/s）\n<ul>\n<li>在每个码元的中间时刻，信号都会发生跳变</li>\n<li>负跳变表示比特 1，正跳变表示比特 0（例子）</li>\n<li>码元中间时刻的跳变即表示时钟，又表示数据</li>\n</ul>\n</li>\n<li>差分曼切斯特编码（比曼切斯特编码变化少，更适合较高的传输速率）\n<ul>\n<li>在每个码元的中间时刻，信号都会发生跳变</li>\n<li>跳变只表示时钟</li>\n<li>码元开始处电平是否发生变化表示数据</li>\n</ul>\n</li>\n</ul>\n<p><strong>基本调制方法</strong></p>\n<ul>\n<li>数字基带信号：原始电信号\n<ul>\n<li>高电平表示 1，低电平表示 0</li>\n</ul>\n</li>\n<li>调幅（AM）：\n<ul>\n<li>无载波输出表示 0，有载波输出表示 1</li>\n</ul>\n</li>\n<li>调频（FM）：\n<ul>\n<li>频率 F1 的波形表示比特 0，频率 F2 的波形表示比特 1</li>\n</ul>\n</li>\n<li>调相（PM）：\n<ul>\n<li>初相位为 0 度的波形表示比特 0，初相位为 180 度的波形为比特 1</li>\n</ul>\n</li>\n</ul>\n<p>使用基本调制方法，一个码元只能包含 1 个比特信息。</p>\n<p><strong>混合调制</strong></p>\n<p>因为频率和相位是相关的，即频率是相位随时间的变化率。所以一次只能调制频率和相位两个中的一个。</p>\n<p>通常情况下，相位和振幅可以结合起来一起调制，称为正交振幅调制 QAM</p>\n<ul>\n<li>举例 —— 正交振幅调制 QAM\n<ul>\n<li>QAM-16\n<ul>\n<li>12 种相位</li>\n<li>每种相位由 1 或 2 中振幅可选</li>\n<li>可以调制出 16 种码元 (波形)，每种码元可对应 4 个比特</li>\n<li>码元与 4 个比特的对应关系采用格雷码\n<ul>\n<li>任意两个相邻码元只有 1 个比特不同</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"信道极限容量\"><a class=\"anchor\" href=\"#信道极限容量\">#</a> 信道极限容量</h3>\n<p>输入信号波形通过通信质量很差的信道时，输出端很难判断什么时候是 1，什么时候是 0。信号之间失去了码元之间的清晰界限，这种现象称为<strong>码间串扰</strong></p>\n<p>失真因素：</p>\n<ul>\n<li>码元传输速率</li>\n<li>信号传输距离</li>\n<li>噪声干扰</li>\n<li>传输媒体质量</li>\n</ul>\n<p>奈氏准则：在假定的理想条件下，为了避免码间串扰，码元传输速率是有上限的</p>\n<ul>\n<li>\n<p>理想低通信道的最高码元传输速率 = 2W Baud</p>\n</li>\n<li>\n<p>理想带通信道的最高码元传输速率 = W Baud</p>\n<ul>\n<li>W：信道带宽（单位为 Hz）</li>\n<li>Baud：波特，即码元 / 秒</li>\n</ul>\n</li>\n<li>\n<p>码元传输速率又称为波特率、调制速率、波形速率或符号速率。它与比特率有一定关系</p>\n<ul>\n<li>当一个码元只携带 1 比特的信息量时，则波特率 (码元 / 秒) 与比特率 (比特 / 秒) 在数值上是相等的</li>\n<li>当一个码元携带 n 比特的信号量时，则波特率转换成比特率时，数值要乘以 n</li>\n</ul>\n</li>\n<li>\n<p>要提高信息传输速率 (比特率)，就必须设法使每一个码元能携带更多个比特的信息量。这需要采用多元制</p>\n</li>\n<li>\n<p>实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值</p>\n</li>\n<li>\n<p>信道的极限信息速率还要受限制于实际的信号在信道中传输的信噪比，因此不能无限制地提高信息的传输速率</p>\n</li>\n</ul>\n<p>香农公式：带宽受限且由高斯白噪声干扰的信道的极限信息传输速率</p>\n<p><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>c</mi><mo>=</mo><mi>W</mi><mo>×</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mo stretchy=\"false\">(</mo><mn>1</mn><mo>+</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">c=W\\times log_2(1+\\frac{S}{N})\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">c</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.76666em;vertical-align:-0.08333em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">W</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.30110799999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:2.04633em;vertical-align:-0.686em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.36033em;\"><span style=\"top:-2.314em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.677em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.05764em;\">S</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.686em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span></span></span></span></p>\n<ul>\n<li>\n<p>c：信道的极限信息传输速率</p>\n</li>\n<li>\n<p>W：信道带宽</p>\n</li>\n<li>\n<p>S：信道内所传信号的平均功率</p>\n</li>\n<li>\n<p>N：信道内的高斯噪声功率</p>\n</li>\n<li>\n<p>S/N：信噪比，使用分贝作为度量单位，信噪比 (dB)=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn><mo>×</mo><mi>l</mi><mi>g</mi><mo stretchy=\"false\">(</mo><mfrac><mi>S</mi><mi>N</mi></mfrac><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">10\\times lg(\\frac{S}{N})</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.217331em;vertical-align:-0.345em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.05764em;\">S</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mclose\">)</span></span></span></span></p>\n</li>\n</ul>\n<p>信道带宽或信道中信噪比越大，信息的极限传输速率越高</p>\n<p>实际信道上能够达到的信息传输速率要比该公式的极限传输速率低不少，由于各种脉冲干扰、信道在传输中衰减和失真等</p>\n<p>综合来看：</p>\n<ul>\n<li>在信道带宽一定的情况下，根据奈氏准则和香农公式，要想提高信息的传输速率就必须采用多元制 (更好的调制方法) 和努力提高信道中的信噪比</li>\n<li>自从香农公式发表后，各种新的信号处理和调制方法就不断出现，其目的都是为了尽可能地接近香农公式给出的传输速率极限</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-1-2/",
            "url": "http://ntmydb/github.io/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-1-2/",
            "title": "计网408-1-2",
            "date_published": "2024-08-02T13:47:29.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<p>1、在 OSI 参考模型中，自下而上第一个提供端到端服务的层次是（B）</p>\n<p>A. 数据链路层       B. 传输层           C. 会话层       D. 应用层</p>\n<p>解析：传输层使用端口号为应用层的应用进程之间提供端到端的逻辑通信，而网络层仅仅为主机之间提供逻辑通信</p>\n<p>2、下列选项中，不属于网络体系结构所描述的内容是（C）</p>\n<p>A. 网络的层次      B. 每一层使用的协议     C. 协议的内容实现细节       D. 每一层必须完成的功能</p>\n<p>解析：计算机网络的体系结构就是计算机网络及其构建所应完成的功能的精确定义。需要强调的是：这些功能的实现细节（例如采用何种软件），则是遵守这种体系结构的具体实现问题，并不属于体系结构本身所描述的内容</p>\n<p>3、TCP/IP 参考模型的网络层提供的是（A）</p>\n<p>A. 无连接不可靠的数据报服务     B. 无连接可靠的数据报服务    C. 有连接不可靠的虚电路服务     D. 有连接可靠的虚电路服务</p>\n<p>解析：这题记住，没有多少解释</p>\n<p>4、在 TCP/IP 结构中，直接为 ICMP 提供服务的协议是（B）</p>\n<p>A.PPP   B.IP    C.UDP     D.TCP</p>\n<p>解析：ICMP 也是 TCP/IP 体系结构网际层中的一个比较重要的协议，使用 ICMP 协议封装的协议数据单元，还需要使用 IP 协议封装成 IP 数据报，之后才能发送。也就是说，IP 协议直接为 ICMP 协议提供服务。而 PPP 协议属于 TCP/IP 体系结构网络接口层，它可以直接为 IP 协议提供服务，而不是直接为 ICMP 协议提供服务。</p>\n<p>5、在 OSI 参考模型中，下列功能需由应用层的相邻层实现的是（B）</p>\n<p>A. 对话管理          B. 数据格式转换             C. 路由选择        D. 可靠数据传输</p>\n<p>解析：应用层的下层是表示层，表示层的任务是实现与数据表示相关的功能，主要包括数据字符集的转换、数据格式转化、文本压缩、数据加密以及解密等工作，对话管理属于会话层功能，路由选择属于网络层，可靠数据传输属于运输层的功能，对于无线链路，还属于数据链路层的功能</p>\n<p>6、在 OSI 参考模型中，直接为会话层提供服务的是（C）</p>\n<p>A. 应用层          B. 表示层         C. 传输层           D. 网络层</p>\n<p>解析：网络体系结构中的某层为其相邻上层提供服务。在 OSI 参考模型中，传输层为其相邻上层会话层直接提供服务</p>\n<p>7、对于 POP3 协议接收邮件时，使用的传输层服务类型是（D）</p>\n<p>A. 无连接不可靠的数据报服务     B. 无连接可靠的数据报服务    C. 有连接不可靠的虚电路服务     D. 有连接可靠的虚电路服务</p>\n<p>解析：POP3 协议需要享用运输层的 TCP 协议所提供的服务，也就是面向连接的可靠的数据传输服务</p>\n<p>8、题目有些抽象，记结论：</p>\n<ul>\n<li>路由器功能层分三层：网络层、数据链路层、物理层</li>\n<li>交换机功能层分两层：数据链路层、物理层</li>\n<li>集线器功能层分一层：物理层</li>\n</ul>\n<p>9、假设 OSI 参考模型的应用层欲发送 400B 的数据 (无拆分)，除物理层和应用层之外，其他各层在封装 PDU 时均引入了 20B 的额外开销，则应用层数据传输效率约为：（A）</p>\n<p>A.80%     B.83%        C.87%      D.91%</p>\n<p>解析：OSI 模型一共 7 层，除去物理层和应用层两层，其他五层都引入了 20B 额外开销，因此效率约为 400B/(5*20+400)=80%</p>\n<p>10、下列 TCP/IP 应用层协议中，可以使用传输层无连接服务的是（B）</p>\n<p>A.FTP   B.DNS      C.SMTP     D.HTTP</p>\n<p>解析：在 TCP/IP 应用层协议中，UDP 服务提供的是无连接服务，本题中只有域名解析协议 DNS 需要享受运输层 UDP 协议所提供的无连接服务</p>\n<p>11、在 OSI 参考模型中，提供分组在一个网络 (或一段链路) 上传输服务的层次是（B）</p>\n<p>A. 应用层    B. 数据链路层     C. 运输层       D. 网络层</p>\n<p>12、TCP/IP 体系结构的网络接口层对应 OSI 体系结构的是（A）</p>\n<p>I. 数据链路层     II. 物理层        III. 网络层        IV. 运输层</p>\n<p>A.I、II        B.I、IV      C.II、III       D.II、IV</p>\n<p>13、TCP/IP 协议族的核心协议是（C）</p>\n<p>A.TCP   B.UDP        C.IP         D.PPP</p>\n<p>14、在 OSI 参考模型中，直接为网络层提供服务的是（D）</p>\n<p>A. 应用层        B. 物理层        C. 运输层           D. 数据链路层</p>\n<p>15、假设 OSI 参考模型的应用层欲发送 600B 的数据 (无拆分)，除应用层外，其他各层在封装 PDU 时均引入 20B 的额外开销，则应用层数据传输效率约为 (C)</p>\n<p>A.68%       B.76.8      C.83.3%      D.96%</p>\n<p>16、两主机的链路长度为 60m，链路带宽为 10Mb/s，信号的传播速率为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2.0</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mi>m</mi><mi mathvariant=\"normal\">/</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">2.0\\times10^8m/s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">m</span><span class=\"mord\">/</span><span class=\"mord mathnormal\">s</span></span></span></span>，其中一台主机给另一台主机发送 1b 信息，当主机接收完该信息共耗费多长时间</p>\n<p>解析：发送时间：1b/10Mb/s=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">10^{-7}s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">s</span></span></span></span>，信号的前端传播了<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup><mo>=</mo><mn>20</mn><mi>m</mi></mrow><annotation encoding=\"application/x-tex\">2\\times10^8\\times10^{-7}=20m</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.897438em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">2</span><span class=\"mord\">0</span><span class=\"mord mathnormal\">m</span></span></span></span></p>\n<p>剩余接收时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>60</mn><mi mathvariant=\"normal\">/</mi><mn>2</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>8</mn></msup><mo>=</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">60/2\\times10^8=3\\times10^{-7}s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">6</span><span class=\"mord\">0</span><span class=\"mord\">/</span><span class=\"mord\">2</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">8</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">3</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">s</span></span></span></span>，总时间为<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>4</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mrow><mo>−</mo><mn>7</mn></mrow></msup><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">4\\times10^{-7}s</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">4</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">×</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mord mtight\">7</span></span></span></span></span></span></span></span></span><span class=\"mord mathnormal\">s</span></span></span></span></p>\n<p>结论：若主机在以一段链路上连续发送分组，则总时延为所有分组的发送时延加上信号在这一段链路上的传播时延</p>\n<p>假设分组等长，各链路长度相同、带宽也相同，忽略路由器的处理时延，若 n 个分组，m 段链路，则总时延为多少：</p>\n<ul>\n<li>n 个分组的发送时延</li>\n<li>1 个分组的发送时延 *（m-1）</li>\n<li>1 段链路的传播时延 * m</li>\n</ul>\n<p>17、试在下列条件下比较电路交换和分组交换</p>\n<p>要传送的报文共 x (bit)，从源点到终点共经过 k 段链路，每段链路的传播时延为 d (s)，带宽为 b (bit/s)，在电路交换时，电路的建立时间为 s (s)。在分组交换时，报文可被划分成若干个长度为 p (bit) 的数据段，添加首部后即可构成分组假设分组首部的长度以及分组在各节点的排队等候时间忽略不计。问再怎样的条件下，电路交换的时延比分组交换的要大？</p>\n<ul>\n<li>\n<p>电路交换总时延为建立时间 s + 发送时延 x/b + 传播时延 kd=s+x/b+kd</p>\n</li>\n<li>\n<p>分组交换时延：发送时延 x/b+1 个分组发送时延 (k-1)*p/b+k 段链路传播时延 kd=x/b+(k-1)*p/b+kd</p>\n</li>\n<li>\n<p>截得 s&gt;(k-1) p/b</p>\n</li>\n</ul>\n<p>设报文长度和分组长度分别为 x 和 (p+h)(bit)，其中 p 为分组的数据部分的长度，而 h 为每个分组的首部，其长度固定，与 p 的大小无关。通信的两端共经过 k 段链路。链路带宽为 b (bit/s)，但传播时延和结点的排队时间均忽略不计。若打算使总的时延为最小，问分组的数据部分长度 p 应取多大？</p>\n<p>解析：总时延<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>D</mi><mo>=</mo><mfrac><mrow><mi>p</mi><mo>+</mo><mi>h</mi></mrow><mi>b</mi></mfrac><mi>p</mi><mo>+</mo><mfrac><mrow><mi>p</mi><mo>+</mo><mi>h</mi></mrow><mi>b</mi></mfrac><mo stretchy=\"false\">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">D=\\frac{p+h}{b}p+\\frac{p+h}{b}(k-1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">D</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.277216em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322159999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.446108em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.277216em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9322159999999999em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">b</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.446108em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">p</span><span class=\"mbin mtight\">+</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03148em;\">k</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>，D 对 p 求导，得到 D 最小时，得到<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>p</mi><mo>=</mo><msqrt><mfrac><mrow><mi>x</mi><mi>h</mi></mrow><mrow><mi>k</mi><mo>−</mo><mn>1</mn></mrow></mfrac></msqrt></mrow><annotation encoding=\"application/x-tex\">p=\\sqrt{\\frac{xh}{k-1}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.625em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\">p</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.8399999999999999em;vertical-align:-0.6166115em;\"></span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2233885em;\"><span class=\"svg-align\" style=\"top:-3.8em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"mord\" style=\"padding-left:1em;\"><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8801079999999999em;\"><span style=\"top:-2.655em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\" style=\"margin-right:0.03148em;\">k</span><span class=\"mbin mtight\">−</span><span class=\"mord mtight\">1</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathnormal mtight\">x</span><span class=\"mord mathnormal mtight\">h</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.403331em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span><span style=\"top:-3.1833885em;\"><span class=\"pstrut\" style=\"height:3.8em;\"></span><span class=\"hide-tail\" style=\"min-width:1.02em;height:1.8800000000000001em;\"><svg width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90\nl0 -0\nc4,-6.7,10,-10,18,-10 H400000v40\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM1001 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.6166115em;\"><span></span></span></span></span></span></span></span></span></p>\n<p>18、主机甲通过 1 个路由器 (存储转发方式) 与主机乙互联，两段链路的数据传输速率均为 10Mbps，主机甲分别采用报文交换和分组大小为 10Kb 的分组交换向主机乙发送 1 个大小为 8Mb (1M=<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn><msup><mn>0</mn><mn>6</mn></msup></mrow><annotation encoding=\"application/x-tex\">10^6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8141079999999999em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\"><span class=\"mord\">0</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">6</span></span></span></span></span></span></span></span></span></span></span>) 的报文。若忽略链路传播延迟、分组开头开销和分组拆装时间，则两种交换方式完成该报文传输所需的总时间为 (D)</p>\n<p>A.800ms,1600ms   B.801ms,1600ms    C.1600ms,800ms         D.1600ms,801ms</p>\n<p>解析：</p>\n<ul>\n<li>报文交换，路由器先接受完整报文：8Mb/10Mbps=800ms，在进行转发，8Mb/10Mbps=800ms，总时间为 1600ms</li>\n<li>分组交换，路由器边接收边转发，总时间为报文的发送时延 + 1 个分组的发送时延 = 8Mb/10Mbps+10Kb/10Mbps=801ms</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "计算机网络",
                "考研408",
                "计算机网络"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-3/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-3/",
            "title": "操作系统408-2-3",
            "date_published": "2024-08-02T13:13:20.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"进程同步-互斥\"><a class=\"anchor\" href=\"#进程同步-互斥\">#</a> 进程同步、互斥</h3>\n<h4 id=\"进程同步\"><a class=\"anchor\" href=\"#进程同步\">#</a> 进程同步</h4>\n<p>同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生制约关系。进程间的直接制约关系就是源自于它们之间的相互合作</p>\n<h4 id=\"进程互斥\"><a class=\"anchor\" href=\"#进程互斥\">#</a> 进程互斥</h4>\n<p>我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备 (比如摄像头、打印机) 都属于临界资源。此外还有许多变量、数据、内存缓冲区都属于临界资源</p>\n<p>对临界资源的访问，必须互斥地进行。互斥，亦称间接制约关系。进程互斥指当一个进程访问某种临界资源时，另一个想要访问临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p>\n<p>对临界资源的访问，可以在逻辑上分为四个部分：</p>\n<ul>\n<li>进入区：负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志 (可理解为上锁)，以阻止其他进程同时进入临界区</li>\n<li>临界区：访问临界资源的那段代码</li>\n<li>退出区：负责解除正在访问临界资源的标志 (可理解为解锁)</li>\n<li>剩余区：做其他处理</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>临界区是进程中访问临界资源的代码段</li>\n<li>进入区和退出区是负责实现互斥的代码段</li>\n<li>临界区也可称为 &quot;临界段&quot;</li>\n</ul>\n<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>\n<ul>\n<li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li>\n<li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li>\n<li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区 (保证不会饥饿)</li>\n<li>让权等待。对进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li>\n</ul>\n<h3 id=\"进程互斥的软件实现方法\"><a class=\"anchor\" href=\"#进程互斥的软件实现方法\">#</a> 进程互斥的软件实现方法</h3>\n<h4 id=\"单标志法\"><a class=\"anchor\" href=\"#单标志法\">#</a> 单标志法</h4>\n<p>算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p>\n<p>例如：</p>\n<pre><code class=\"language-C\">int turn=0;  //turn表示当前允许进入临界区的进程号\nP0进程：\nwhile(turn!=0);    //进入区\ncritical section;   //临界区\nturn=1;            //退出区\nremainder section; //剩余区\nP1进程：\nwhile(turn!=1);    //进入区\ncritical section;   //临界区\nturn=0;            //退出区\nremainder section; //剩余区\n</code></pre>\n<p>该算法可以实现 &quot;同一时刻最多只允许一个进程访问临界区&quot;</p>\n<p>单标志法存在的主要问题是：违背 &quot;空闲让进&quot; 原则</p>\n<h4 id=\"双标志先检查法\"><a class=\"anchor\" href=\"#双标志先检查法\">#</a> 双标志先检查法</h4>\n<p>算法思想：设置一个布尔型数组 flag []，数组中各个元素用来标志各进程想进入临界区的意愿，比如 &quot;flag [0]=true&quot; 意味着 0 号进程 P0 现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把有自身对应的标志 flag [i] 设为 true，之后开始访问临界区。</p>\n<pre><code class=\"language-C\">bool flag[2];  //表示进入临界区意愿的数组\nflag[0]=false;\nflag[1]=false;  //刚开始设置为两个进程都不进入临界区\nP0进程：\nwhile(flag[1]);\nflag[0]=true;\ncritical section;\nflag[0]=false;\nremainder section;\nP1进程：\nwhile(flag[0]);    //如果此时P0进入临界区，P1就循环等待\nflag[1]=true;      //标记为P1进程想要进入临界区\ncritical section;  //访问临界区\nflag[1]=false;     //访问完临界区，修改标记为P1不想使用临界区\nremainder section;\n</code></pre>\n<p>两个进程可能会同时进入临界区</p>\n<p>双标志先检查法的主要问题是：违反 &quot;忙则等待&quot; 原则</p>\n<p>原因在于，进入区的 &quot;检查&quot; 和 &quot;上锁&quot; 两个处理不是一气呵成的。检查后，上锁前可能发生进程切换</p>\n<h4 id=\"双标志后检查法\"><a class=\"anchor\" href=\"#双标志后检查法\">#</a> 双标志后检查法</h4>\n<p>算法思想：双标志先检查法的改版。前一个算法的问题是先 &quot;检查&quot; 后 &quot;上锁&quot;，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先 &quot;上锁&quot; 后检查的方法，来避免上述问题</p>\n<pre><code class=\"language-C\">bool flag[2];  //表示进入临界区意愿的数组\nflag[0]=false;\nflag[1]=false;  //刚开始设置为两个进程都不进入临界区\nP0进程：\nflag[0]=true;\nwhile(flag[1]);\ncritical section;\nflag[0]=false;\nremainder section;\nP1进程：\nflag[1]=true;      //标记为P1进程想要进入临界区\nwhile(flag[0]);    //如果此时P0进入临界区，P1就循环等待\ncritical section;  //访问临界区\nflag[1]=false;     //访问完临界区，修改标记为P1不想使用临界区\nremainder section;\n</code></pre>\n<p>P0 和 P1 将都无法进入临界区</p>\n<p>因此，双标志后检查法虽然解决了 &quot;忙则等待&quot; 的问题，但是又违背了 &quot;空闲让进&quot; 和 &quot;有限等待&quot; 原则，会因各进程都长期无法访问临界资源而产生 &quot;饥饿&quot; 现象</p>\n<h4 id=\"peterson算法\"><a class=\"anchor\" href=\"#peterson算法\">#</a> Peterson 算法</h4>\n<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让</p>\n<pre><code class=\"language-C\">bool flag[2];    //表示进入临界区意愿的数组，初始值都是false\nint turn=0;    //turn 表示优先让哪个进程进入临界区\nP0进程：\nflag[0]=true;\nturn=1;\nwhile(flag[1] &amp;&amp; turn==1);\ncritical section;\nflag[0]=false;\nremainder section;\nP1进程：\nflag[1]=true;    //表示自己想进入临界区\nturn = 0;        //可以优先让对方进入临界区\nwhile(flag[0] &amp;&amp; turn==0); //对方想进，且最后一次是自己&quot;谦让&quot;，那自己就循环等待\ncritical section;\nflag[1]=false;   //访问完临界区，表示自己已经不想访问临界区了\nremainder section;\n</code></pre>\n<p>Peterson 算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循让权等待的原则</p>\n<h3 id=\"进程互斥的硬件实现方法\"><a class=\"anchor\" href=\"#进程互斥的硬件实现方法\">#</a> 进程互斥的硬件实现方法</h3>\n<h4 id=\"中断屏蔽方法\"><a class=\"anchor\" href=\"#中断屏蔽方法\">#</a> 中断屏蔽方法</h4>\n<p>利用 &quot;开 / 关中断指令&quot; 实现 (与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况)</p>\n<p>关中断后即不允许当前进程被中断，也必然不会发生进程切换</p>\n<p>直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机并访问临界区</p>\n<p>优点：简单、高效</p>\n<p>缺点：不适用于多处理机，只适用于操作系统内核进程，不适用于用户进程 (因为开 / 关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险)</p>\n<h4 id=\"testandset指令\"><a class=\"anchor\" href=\"#testandset指令\">#</a> TestAndSet 指令</h4>\n<p>简称 TS 指令，也有地方称为 TestAndSetLock 指令，或 TSL 指令</p>\n<p>TSL 指令是用硬件实现额，执行的过程不允许被中断，只能一气呵成。以下是用 C 语言描述的逻辑</p>\n<pre><code class=\"language-C\">//布尔型共享变量lock表示当前临界区是否被加锁\n//true表示已加锁，false表示未加锁\nbool TestAndSet(bool *lock)&#123;\n    bool old;\n    old = *lock;  //old用来存放lock原来的值\n    *lock = true; //无论之前是否已加锁，都将lock设为true\n    return old;  //返回lock原来的值\n&#125;\n//以下是使用TSL指令实现互斥的算法逻辑\nwhile(TestAndSet(&amp;lock)); //&quot;上锁&quot;并检查\ncritical section;\nlock = false; //解锁\nremainder section;\n</code></pre>\n<p>相比软件实现方法，TSL 指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作。</p>\n<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境</p>\n<p>缺点：不满足 &quot;让权等待&quot; 原则，暂时无法进入临界区的进程会占用 CPU 循环执行 TSL 指令，从而导致忙等</p>\n<h4 id=\"swap指令\"><a class=\"anchor\" href=\"#swap指令\">#</a> Swap 指令</h4>\n<p>Swap 指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是 C 语言描述的逻辑</p>\n<pre><code class=\"language-C\">//Swap指令的作用是交换两个变量的值\nSwap(bool *a,bool *b)&#123;\n    bool temp;\n    temp=*a;\n    *a=*b;\n    *b=temp;\n&#125;\n//以下是Swap指令实现互斥算法的逻辑\n//lock表示当前临界区是否被加锁\nbool old=true;\nwhile(old == true)\n    Swap(&amp;lock,&amp;old);\ncritical section;\nlock = false;\nremainder section;\n</code></pre>\n<p>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞，适用于多处理机环境</p>\n<p>缺点：不满足 &quot;让权等待&quot; 原则，暂时无法进入临界区的进程会占用 CPU 循环执行 TSL 指令，从而导致忙等</p>\n<h3 id=\"互斥锁\"><a class=\"anchor\" href=\"#互斥锁\">#</a> 互斥锁</h3>\n<p><strong>互斥锁</strong></p>\n<p>解决临界区最简单的工具就是互斥锁，一个进程在进入临界区时应获得锁；在退出临界区时释放锁。</p>\n<p>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用获得锁函数。当多个进程共享同一 CPU 时，就浪费了 CPU 周期。因此互斥锁通常用于多处理系统，一个线程可以在一个处理器上等待，不影响其他线程的执行</p>\n<p>需要连续循环忙等的互斥锁，都可称为自旋锁，如 TSL 指令，Swap 指令，单标志法</p>\n<p><strong>锁的特性</strong></p>\n<ul>\n<li>需忙等，进程时间片用完才下处理机，违反 &quot;让权等待&quot;</li>\n<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>\n<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>\n<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>\n</ul>\n<h3 id=\"信号量机制\"><a class=\"anchor\" href=\"#信号量机制\">#</a> 信号量机制</h3>\n<p>用户进程可以通过操作系统提供的一对原语对信号量进行操作，从而很方便的实现了进程互斥、进程同步</p>\n<p>信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数据。</p>\n<p>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断 / 开中断指令实现的。</p>\n<p>一对原语：wait (S) 原语和 signal (S) 原语</p>\n<p>wait，signal 称为 P、V 操作</p>\n<h4 id=\"整形信号量\"><a class=\"anchor\" href=\"#整形信号量\">#</a> 整形信号量</h4>\n<p>用一个整形变量作为信号量，用来表示系统中某种资源的数量</p>\n<ul>\n<li>与普通变量的区别：对信号量的操作只有三种，即初始化，P 操作，V 操作</li>\n</ul>\n<pre><code class=\"language-C\">void wait(int S)&#123;\n    while(S&lt;=0);\n    S=S-1;\n&#125;\nvoid signal(int S)&#123;\n    S=S+1;\n&#125;\n进程Pn\nwait(S);\n使用临界资源\nsignal(S);\n</code></pre>\n<h4 id=\"记录型信号量\"><a class=\"anchor\" href=\"#记录型信号量\">#</a> 记录型信号量</h4>\n<p>整形信号量的缺陷是存在 &quot;忙等&quot; 问题，记录型信号量就是用记录型数据结构表示的信号量</p>\n<pre><code class=\"language-C\">//记录型信号量的定义\ntypedef struct &#123;\n    int value;                //剩余资源数\n    struct process *L;        //等待队列\n&#125; semaphore;\n\n//某进程需要使用资源时，通过wait原语申请\nvoid wait(semaphore S)&#123;\n    S.value--;\n    if(S.value&lt;0)&#123;\n        block(S.L); //如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（即阻塞队列）中\n    &#125;\n&#125;\n//进程使用完成后，通过signal原语释放\nvoid signal(semaphore S)&#123;\n    S.value++;\n    if(S.value&lt;=0)&#123; //释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态\n        wakeup(S.L);\n    &#125;\n&#125;\n</code></pre>\n<p>对信号量 S 的一次 P 操作意味着进程请求一个单位的该类资源，因此需要执行 S.value--，表示资源数减 1，当 S.value&lt;0 表示资源已分配完毕，因此进程应调用 block 原语进行自我阻塞（当前运行的进程从运行态 -&gt; 阻塞态），主动放弃处理机，并插入该类资源的等待队列 S.L 中。可见，该机制遵循了 &quot;让权等待&quot; 的原则，不会出现忙等的现象</p>\n<p>对信号量 S 的一次 V 操作意味着进程释放一个单位的该类资源，因此需要执行 S.value++，表示资源数加 1，若加 1 后仍是 S.value&lt;=0 表示仍有进程在等待该类资源，因此进程应调用 wakeup 原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态 -&gt; 就绪态）。</p>\n<h3 id=\"用信号量机制实现进程互斥-同步-前驱关系\"><a class=\"anchor\" href=\"#用信号量机制实现进程互斥-同步-前驱关系\">#</a> 用信号量机制实现进程互斥、同步、前驱关系</h3>\n<h4 id=\"实现进程互斥\"><a class=\"anchor\" href=\"#实现进程互斥\">#</a> 实现进程互斥</h4>\n<ul>\n<li>分析并发进程的关键活动，划定临界区</li>\n<li>设置互斥信号量 mutex（进入临界区的名额），初始值为 1</li>\n<li>在进入区 P (mutex)—— 申请资源</li>\n<li>在退出区 V (mutex)—— 释放资源</li>\n</ul>\n<p>注意：对不同的临界资源需设置不同的互斥信号量</p>\n<p>P、V 操作必须成对出现。缺少 P (mutex) 就不能保证临界资源的互斥访问，缺少 S (mutex) 会导致资源永不被释放。等待进程永不被唤醒</p>\n<h4 id=\"实现进程同步\"><a class=\"anchor\" href=\"#实现进程同步\">#</a> 实现进程同步</h4>\n<p>进程同步：要让各进程按要求有序地推进</p>\n<p>用信号量实现进程同步：</p>\n<ul>\n<li>分析什么地方需要实现 &quot;同步关系&quot;，即必须保证 &quot;一前一后&quot; 执行的两个操作</li>\n<li>设置同步信号量 S，初始为 0</li>\n<li>在 &quot;前操作&quot; 之后执行 V (S)</li>\n<li>在 &quot;后操作&quot; 之后执行 P (S)</li>\n</ul>\n<h4 id=\"实现前驱关系\"><a class=\"anchor\" href=\"#实现前驱关系\">#</a> 实现前驱关系</h4>\n<p>每一对前驱关系都是一个进程同步问题 (需要保证一前一后操作)</p>\n<ul>\n<li>要为每一对前驱关系各设置一个同步信号量</li>\n<li>在 &quot;前操作&quot; 之后对相应的同步信号量执行 V 操作</li>\n<li>在 &quot;后操作&quot; 之前对相应的同步信号量执行 P 操作</li>\n</ul>\n<p><strong>PV 操作题目分析步骤</strong></p>\n<ul>\n<li>关系分析。找出题目中描述的各个进程。分析它们之间的同步、互斥关系</li>\n<li>整理思路。根据各进程的操作流程确定 P、V 操作的大致顺序</li>\n<li>设置信号量。并根据题目条件确定信号量初值。(互斥信号量初值一般为 0，同步信号量的初始值要看对应资源初始值为多少)</li>\n</ul>\n<h3 id=\"生产者消费者问题\"><a class=\"anchor\" href=\"#生产者消费者问题\">#</a> 生产者消费者问题</h3>\n<p><strong>问题描述</strong></p>\n<p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用 (注：这里的 &quot;产品&quot; 可理解为数据)</p>\n<p>生产者、消费者共享一个初始为空、大小为 n 的缓冲区。</p>\n<p>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待、</p>\n<p><strong>分析解答</strong></p>\n<ul>\n<li>缓冲区没满 -&gt; 生产者生产</li>\n<li>缓冲区没空 -&gt; 消费者消费</li>\n<li>缓冲区满 -&gt; 生产者等待</li>\n<li>缓冲区空 -&gt; 消费者等待</li>\n</ul>\n<pre><code class=\"language-C\">semaphore mutex = 1;  //互斥信号量，实现对缓冲区的互斥访问\nsemaphore empty = n;  //同步信号量，表示空闲缓冲区的数量\nsemaphore full = 0;   //同步信号量，表示产品的数量，也即非空缓冲区的数量\n\nproducer() &#123;\n    while(1)&#123;\n        生产一个产品;\n        P(empty);  //消耗一个空闲缓冲区\n        P(mutex);  //同一进程中的互斥操作\n        把产品放入缓冲区;\n        V(mutex);\n        V(full);  //增加一个产品\n    &#125;\n&#125;\n\nconsumer() &#123;\n    while(1)&#123;\n        P(full); //消耗一个产品(非空缓冲区)\n        P(mutex);\n        从缓冲区中取走一个产品;\n        V(mutex);\n        V(empty); //产生一个空闲缓冲区\n        使用产品\n    &#125;\n&#125;\n</code></pre>\n<p>改变 P、V 顺序可能会导致死锁，因此，实现互斥的 P 操作一定要在实现同步的 P 操作之后，V 操作不会导致进程阻塞，因此两个 V 操作顺序可以交换</p>\n<h3 id=\"多生产者-多消费者问题\"><a class=\"anchor\" href=\"#多生产者-多消费者问题\">#</a> 多生产者 - 多消费者问题</h3>\n<p><strong>问题描述</strong></p>\n<p>桌子上有一只盘子，每次只能向其中放入一个水果，爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果，仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用 PV 操作实现上述过程</p>\n<p><strong>分析解答</strong></p>\n<p>互斥关系：对缓冲区 (盘子) 的访问要互斥地进行</p>\n<p>同步关系：</p>\n<ul>\n<li>父亲将苹果放入盘子后，女儿才能取苹果</li>\n<li>母亲将橘子放入盘子后，儿子才能取橘子</li>\n<li>只有盘子为空时，父亲或母亲才能往盘子里放水果</li>\n</ul>\n<pre><code class=\"language-C\">semaphore mutex = 1; //实现互斥访问盘子(缓冲区)，这一个信号量可以不需要\nsemaphore apple = 0; //盘子里有几个苹果\nsemaphore orange = 0; //盘子里有几个橘子\nsemaphore plate = 1; //盘子中还可以放多少水果\ndad()&#123;\n    while(1)&#123;\n        准备放一个苹果;\n        P(plate);\n        把苹果放入盘子;\n        V(apple);\n    &#125;\n&#125;\n\nmom()&#123;\n    while(1)&#123;\n        准备放一个句子;\n        P(plate);\n        把橘子放入盘子;\n        V(orange);\n    &#125;\n&#125;\n\ndaughter()&#123;\n    while(1)&#123;\n        P(apple);\n        从盘子中取出苹果;\n        V(plate);\n        吃掉苹果;\n    &#125;\n&#125;\n\nson() &#123;\n    while(1)&#123;\n        P(orange);\n        从盘子中取出橘子;\n        V(plate);\n        吃掉橘子;\n    &#125;\n&#125;\n</code></pre>\n<p>结论：在生产者 - 消费者问题中，如果缓冲区大小为 1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体情况具体分析。当缓冲区大小大于 1 是，就必须设置互斥信号量保证互斥访问缓冲区</p>\n<h3 id=\"吸烟者问题\"><a class=\"anchor\" href=\"#吸烟者问题\">#</a> 吸烟者问题</h3>\n<p><strong>问题描述</strong></p>\n<p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽调一支烟，抽烟者需要三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料在桌上，这个过程一直重复 (让三个抽烟者轮流抽烟)</p>\n<p><strong>分析解答</strong></p>\n<p>同步关系：</p>\n<ul>\n<li>桌子上有组合一 -&gt; 第一个抽烟者取走东西</li>\n<li>桌子上有组合二 -&gt; 第二个抽烟者取走东西</li>\n<li>桌子上有组合三 -&gt; 第三个抽烟者取走东西</li>\n<li>发出完成信号 -&gt; 供应者将下一个组合放到桌子上</li>\n</ul>\n<pre><code class=\"language-C\">semaphore offer1 = 0; //桌子上有组合一的数量\nsemaphore offer2 = 0; //桌子上有组合二的数量\nsemaphore offer3 = 0; //桌子上有组合三的数量\nsemaphore finish = 0; //抽烟是否完成\nint i=0; //用于实现三个抽烟者轮流抽烟\nprovider()&#123;\n    while(1)&#123;\n        if(i==0)&#123;\n            将组合一放在桌子上;\n            V(offer1);\n        &#125; else if (i==1)&#123;\n            将组合二放在桌子上;\n            V(offer2);\n        &#125; else if(i==2)&#123;\n            将组合三放在桌子上;\n            V(offer3);\n        &#125;\n        i=(i+1)%3;\n        P(finish);\n    &#125;\n&#125;\nsmoker1()&#123;\n    while(1)&#123;\n        P(offer1);\n        从桌子上拿走组合一，卷烟，抽掉;\n        V(finish);\n    &#125;\n&#125;\nsmoker2()&#123;\n    while(1)&#123;\n        P(offer2);\n        从桌子上拿走组合二，卷烟，抽掉;\n        V(finish);\n    &#125;\n&#125;\nsmoker3()&#123;\n    while(1)&#123;\n        P(offer3);\n        从桌子上拿走组合三，卷烟，抽掉;\n        V(finish);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"读者写者问题\"><a class=\"anchor\" href=\"#读者写者问题\">#</a> 读者写者问题</h3>\n<p><strong>问题描述</strong></p>\n<p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时，不会产生副作用，但若是某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。</p>\n<p><strong>分析解答</strong></p>\n<pre><code class=\"language-C\">semaphore rw = 1;  //用于实现对共享文件的互斥访问\nint count=0;   //记录当前有几个读进程在访问文件\nsemaphore mutex = 1; //用于保证对count变量的互斥访问\nwriter()&#123;\n    while(1)&#123;\n        P(rw);  //写之前加锁\n        写文件;\n        P(rw);\n    &#125;\n&#125;\n\nreader()&#123;\n    while(1)&#123;\n        P(mutex);  //各读进程互斥访问counter\n        if(count==0)  //由第一个读进程负责\n            P(rw);   //读之前加锁\n        count++;\n        V(mutex);\n        读文件;\n        P(mutex);  //各读进程互斥访问count\n        count--;\n        if(count==0)  //由最后一个读进程负责\n            V(rw);  //读完了解锁\n        V(mutex);\n    &#125;\n&#125;\n</code></pre>\n<p>潜在的问题：只要有读进程还在读，写进程就要一直阻塞等待，可能饿死，因此，这种算法中，读进程是优先的</p>\n<p>改为写优先：</p>\n<pre><code class=\"language-C\">semaphore rw = 1;  //用于实现对共享文件的互斥访问\nint count=0;   //记录当前有几个读进程在访问文件\nsemaphore mutex = 1; //用于保证对count变量的互斥访问\nsemaphore w = 1;  //用于实现写优先\nwriter()&#123;\n    while(1)&#123;\n        P(w);\n        P(rw);  //写之前加锁\n        写文件;\n        P(rw);\n        V(w);\n    &#125;\n&#125;\n\nreader()&#123;\n    while(1)&#123;\n        P(w);\n        P(mutex);  //各读进程互斥访问counter\n        if(count==0)  //由第一个读进程负责\n            P(rw);   //读之前加锁\n        count++;\n        V(mutex);\n        V(w);\n        读文件;\n        P(mutex);  //各读进程互斥访问count\n        count--;\n        if(count==0)  //由最后一个读进程负责\n            V(rw);  //读完了解锁\n        V(mutex);\n    &#125;\n&#125;\n</code></pre>\n<p>结论：在这种算法中，连续进入的多个读者可以同时读文件，写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的写优先，而是相对公平的先来先服务原则</p>\n<p>核心思想：设置了一个计数器 count 用来记录当前正在访问共享文件的读进程数。我们可以用 count 的值判断当前进入的进程是否是第一个 / 最后一个读进程，从而做出不同的处理</p>\n<h3 id=\"哲学家进餐问题\"><a class=\"anchor\" href=\"#哲学家进餐问题\">#</a> 哲学家进餐问题</h3>\n<p><strong>问题描述</strong></p>\n<p>一个圆桌上坐着 5 名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当前哲学家饥饿时，才试图拿起左、右两根筷子 (一根一根地拿起)。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>\n<p><strong>分析解答</strong></p>\n<ul>\n<li>关系分析。系统中 5 位哲学家进程，5 位哲学家与左右邻居对其中间的筷子访问是互斥关系的</li>\n<li>信号量设置。定义互斥信号量数组 chopstick [5]={1,1,1,1,1} 用于实现对 5 个筷子的互斥访问。并对哲学家按 0~4 编号，哲学家 i 左边的筷子编号为 i，右边快字的编号为 (i+1)%5</li>\n</ul>\n<pre><code class=\"language-C\">semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;\nPi()&#123;  //第i号哲学家的进程\n    while(1)&#123;\n        P(chopstick[i]);  //拿起左边的筷子\n        P(chopstick[(i+1)%5]);  //拿起右边的筷子\n        吃饭;\n        V(chopstick[i]);      //放左\n        V(chopstick[(i+1)%5]); //放右\n        思考;\n    &#125;\n&#125;\n</code></pre>\n<p>上述方式可能会导致每个哲学家都拿起了左边的筷子，但是都在等待右边的筷子，造成死锁</p>\n<p>解决方式：</p>\n<ul>\n<li>\n<p>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少一个哲学家是可以拿到左右两只筷子的</p>\n</li>\n<li>\n<p>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反，用这种方法可以保证如果两个相邻的奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p>\n</li>\n<li>\n<p>仅当一个哲学家两只筷子都可用时才允许他抓起筷子</p>\n</li>\n</ul>\n<p>改进后的程序：</p>\n<pre><code class=\"language-C\">semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;\nsemaphore mutex = 1;  //互斥地取筷子\nPi()&#123;  //第i号哲学家的进程\n    while(1)&#123;\n        P(mutex);\n        P(chopstick[i]);  //拿起左边的筷子\n        P(chopstick[(i+1)%5]);  //拿起右边的筷子\n        V(mutex);\n        吃饭;\n        V(chopstick[i]);      //放左\n        V(chopstick[(i+1)%5]); //放右\n        思考;\n    &#125;\n&#125;\n</code></pre>\n<p>上面这种办法并不能保证只有两边的筷子都可用时，才允许哲学家拿起筷子。但这种方法不会造成死锁，可以解决问题。</p>\n<h3 id=\"管程\"><a class=\"anchor\" href=\"#管程\">#</a> 管程</h3>\n<p>管程是一种特殊的软件模块，有这些部分组成：</p>\n<ul>\n<li>局部于管程的共享数据结构说明；</li>\n<li>对该数据结构进行操作的一组过程</li>\n<li>对局部于管程的共享数据设置初始值的语句</li>\n<li>管程有一个名字</li>\n</ul>\n<p>管程的基本特征：</p>\n<ul>\n<li>局部于管程的数据只能被局部于管程的过程所访问</li>\n<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>\n<li>每次仅允许一个进程在管程内执行某个内部过程</li>\n</ul>\n<p>拓展 1：用管程解决生产者消费者问题：</p>\n<pre><code class=\"language-C\">monitor ProducerConsumer\n    condition full,empty;   //条件变量用来实现同步(排队)\n\tint count=0;  //缓冲区中的产品数\n\tvoid insert(Item item)&#123;  //把产品item放入缓冲区\n        if(count==N)\n            wait (full);\n        count++;\n        insert_item(item);\n        if(count==1)\n            signal(empty);\n    &#125;\n\tItem remove()&#123;  //从缓冲区中取出一个产品\n        if(count ==0)\n            wait(empty);\n        count--;\n        if(count==N-1)\n            signal(full);\n        return remove_item();\n    &#125;\nend monitor;\n//生产者进程\nproducer()&#123;\n    while(1)&#123;\n        item = 生产一个产品;\n        ProducerConsumer.insert(item);\n    &#125;\n&#125;\n//消费者进程\nconsumer()&#123;\n    while(1)&#123;\n        item = ProducerConsumer.remove();\n        消费产品item;\n    &#125;\n&#125;\n</code></pre>\n<p>引入管程的目的无非就是更方便地实现进程互斥和同步</p>\n<ul>\n<li>需要在管程中定义共享数据（如生产者消费者的缓冲区）</li>\n<li>需要再管程中定义用于访问这些共享数据的 &quot;入口&quot;—— 其实就是一些函数 (如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品)</li>\n<li>只有通过这种特定的入口才能访问共享数据</li>\n<li>管程中有很多入口，但是每次只能开放其中一个入口，并且只能让一个进程或线程进入（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：这种互斥特性是由编译器负责实现的，程序员不用关心）</li>\n<li>可在管程中设置条件变量及等待 / 唤醒操作以解决同步问题。可以让一个进程或线程在条件变量上等待 (此时，该进程应先释放管程的使用权，也就是让出入口)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-2/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-2/",
            "title": "操作系统408-2-2",
            "date_published": "2024-08-02T06:17:20.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"调度\"><a class=\"anchor\" href=\"#调度\">#</a> 调度</h3>\n<p>当有一堆任务要处理，由于资源有限，这些事情没办法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是 &quot;调度&quot; 研究的问题</p>\n<h4 id=\"调度的三个层次\"><a class=\"anchor\" href=\"#调度的三个层次\">#</a> 调度的三个层次</h4>\n<p><strong>高级调度</strong></p>\n<p>作业：一个具体的任务</p>\n<p>高级调度：按一定的原则从外存的作业后备队列挑选一个作业调入内存，并创建进程。每个作业只调入一次，调出一次。作业调入时会建立 PCB，调出时才撤销 PCB</p>\n<p><strong>低级调度（进程调度 / 处理机调度）</strong></p>\n<p>按照某种策略从就绪队列中选取一个进程，将处理机分配给它</p>\n<p>进程调度是操作系统中最基本的一种调度，在一般的操作系统中都是必须配置进程调度</p>\n<p>进程调度的频率很高，一般几十毫秒一次</p>\n<p><strong>中级调度</strong></p>\n<p>内存不够时，可将某些进程的数据调出外存。等内存空间空闲或者进程需要运行时再重新调入内存</p>\n<p>暂时调到外存等待的进程状态为挂起状态，被挂起的进程 PCB 会被组织成挂起队列</p>\n<p>中级调度 (内存调度)：按照某种策略决定将哪个处于挂起状态的进程重新调入内存</p>\n<p>一个进程可能会多次被调出、调入内存，因此中级调度发生的频率要比高级调度更高</p>\n<p><img data-src=\"F:%5CBlog%5Cimages%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-2-1.png\" alt=\"七状态模型\" /></p>\n<p>三层调度联系对比：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>要做什么</th>\n<th>调度发生在</th>\n<th>发生频率</th>\n<th>对进程状态的影响</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>高级调度 (作业调度)</td>\n<td>按照某种规划，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>\n<td>外存 -&gt; 内存 (面向作业)</td>\n<td>最低</td>\n<td>无 -&gt; 创建态 -&gt; 就绪态</td>\n</tr>\n<tr>\n<td>中级调度 (内存调度)</td>\n<td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>\n<td>外存 -&gt; 内存 (面向进程)</td>\n<td>中等</td>\n<td>挂起态 -&gt; 就绪态 (阻塞挂起 -&gt; 阻塞态)</td>\n</tr>\n<tr>\n<td>低级调度 (进程调度)</td>\n<td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>\n<td>内存 -&gt;CPU</td>\n<td>最高</td>\n<td>就绪态 -&gt; 运行态</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"进程调度的时机-切换与过程\"><a class=\"anchor\" href=\"#进程调度的时机-切换与过程\">#</a> 进程调度的时机、切换与过程</h3>\n<h4 id=\"进程调度\"><a class=\"anchor\" href=\"#进程调度\">#</a> 进程调度</h4>\n<p>需要进行进程调度与切换的情况：</p>\n<ul>\n<li>当前运行的进程主动放弃处理机\n<ul>\n<li>进程正常终止</li>\n<li>运行过程中发生异常而终止</li>\n<li>进程主动请求阻塞 (如等待 I/O)</li>\n</ul>\n</li>\n<li>当前运行的进程被动放弃处理机\n<ul>\n<li>分给进程的时间片用完</li>\n<li>有更紧急的事需要处理 (如 I/O 中断)</li>\n<li>有更高优先级的进程进入就绪队列</li>\n</ul>\n</li>\n</ul>\n<p>不能进行进程调度与切换的情况</p>\n<ul>\n<li>在处理中断的过程中，中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换</li>\n<li>进程在操作系统内核程序临界区中</li>\n<li>在原子操作过程中 (原语)。原子操作不可中断，要一气呵成</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>进程在操作系统内核程序临界区中不能进行调度与切换 —— 正确</li>\n<li>进程处于临界区时不能进行处理机调度 —— 错误</li>\n</ul>\n<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源</p>\n<p>临界区：访问临界资源的那段代码</p>\n<p>内核程序临界区一般是用来访问某种内核数据结构的，比如进程就绪队列 (由各就绪进程的 PCB 组成)</p>\n<ul>\n<li>\n<p>如果还没退出临界区 (还没解锁) 就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此无法顺利进行进程调度。</p>\n</li>\n<li>\n<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作，因此在访问内核程序临界区期内不能进行调度与切换</p>\n</li>\n<li>\n<p>在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致 CPU 一直空闲</p>\n</li>\n<li>\n<p>普通临界区访问的临界资源不会影响操作系统内核的管理工作，因此在访问普通临界区时可以进行调度与切换</p>\n</li>\n</ul>\n<h4 id=\"进程调度的方式\"><a class=\"anchor\" href=\"#进程调度的方式\">#</a> 进程调度的方式</h4>\n<p>非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即使有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态</p>\n<ul>\n<li>实现简单，系统开销小但是无法及时处理紧急任务，适用于早期的批处理系统</li>\n</ul>\n<p>剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要的或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配更重要紧迫的那个进程</p>\n<ul>\n<li>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能 (通过时钟中断)。适用于分时操作系统，实时操作系统</li>\n</ul>\n<h4 id=\"进程的切换与过程\"><a class=\"anchor\" href=\"#进程的切换与过程\">#</a> 进程的切换与过程</h4>\n<p><strong>&quot;狭义的进程调度&quot; 与 &quot;进程切换&quot; 的区别</strong></p>\n<p>狭义的进程调度指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可以是另一个进程，后一种情况就需要进程切换）</p>\n<p>进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程</p>\n<p>广义的进程调度包含了选择一个进程和进程切换两个步骤。</p>\n<p><strong>进程切换的过程</strong></p>\n<ul>\n<li>对原来运行进程各种数据的保存</li>\n<li>对新的进程各种数据的恢复</li>\n</ul>\n<p>注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少</p>\n<h3 id=\"调度器和闲逛进程\"><a class=\"anchor\" href=\"#调度器和闲逛进程\">#</a> 调度器和闲逛进程</h3>\n<p><strong>调度器 / 调度程序</strong></p>\n<p>就绪态到运行态的转换中，被调度程序选中和时间用完导致的转换由调度程序引起，调度程序决定：</p>\n<ul>\n<li>让谁运行 —— 调度算法</li>\n<li>运行多长时间 —— 时间片大小</li>\n</ul>\n<p>调度时机 —— 什么事件会触发 &quot;调度程序&quot;</p>\n<ul>\n<li>\n<p>创建新的进程</p>\n</li>\n<li>\n<p>进程退出</p>\n</li>\n<li>\n<p>运行进程阻塞</p>\n</li>\n<li>\n<p>I/O 中断发生 (可能唤醒某些阻塞进程)</p>\n</li>\n<li>\n<p>非抢占式调度策略，只有运行进程阻塞或退出才触发调度程序工作</p>\n</li>\n<li>\n<p>抢占式调度策略，每个时钟中断或 k 个时钟中断会触发调度程序工作</p>\n</li>\n</ul>\n<p>对于不支持内核级线程的操作系统，调度程序的处理对象是进程</p>\n<p>支持内核级线程的操作系统，调度程序的处理对象是内核线程</p>\n<p><strong>闲逛进程</strong></p>\n<p>当没有其他就绪进程是时，运行闲逛进程</p>\n<p>闲逛进程的特性：</p>\n<ul>\n<li>优先级最低</li>\n<li>可以是 0 地址指令，占一个完整的指令周期 (指令周期末尾例行检查中断)</li>\n<li>能耗低</li>\n</ul>\n<h3 id=\"调度算法的评价指标\"><a class=\"anchor\" href=\"#调度算法的评价指标\">#</a> 调度算法的评价指标</h3>\n<p><strong>CPU 利用率</strong></p>\n<p>CPU 利用率：指 CPU 忙碌的时间占总时间的比例</p>\n<p>利用率 = 忙碌的时间 / 总时间</p>\n<p><strong>系统吞吐量</strong></p>\n<p>系统吞吐量：单位时间内完成作业的数量</p>\n<p>系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间</p>\n<p><strong>周转时间</strong></p>\n<p>周转时间：指从作业被提交给系统开始，到作业完成为止的这段时间间隔</p>\n<p>它包括四部分：</p>\n<ul>\n<li>作业在外存后备队列上等待作业调度 (高级调度) 的时间</li>\n<li>进程在就绪队列上等待进程调度 (低级调度) 的时间</li>\n<li>进程在 CPU 上执行的时间</li>\n<li>进程等待 I/O 操作完成的时间</li>\n</ul>\n<p>后三项在一个作业的整个处理中，可能发生多次</p>\n<p>(作业) 周转时间 = 作业完成时间 - 作业提交时间</p>\n<p>平均周转时间 = 各作业周转时间之和 / 作业数</p>\n<p>带权周转时间 = 作业周转时间 / 作业实际运行的时间 =(作业完成时间 - 作业提交时间)/ 作业实际运行的时间</p>\n<p>平均带权周转时间 = 各作业带权周转时间 / 作业数</p>\n<p><strong>等待时间</strong></p>\n<p>等待时间：指进程 / 作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低</p>\n<p>对于进程来说，等待时间就是进程建立之后等待被服务的时间之和，在等待 I/O 完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>\n<p>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</p>\n<p>一个作业总共需要被 CPU 服务多久，被 I/O 设备服务多久一般是确定不变的，因此调度算法其实只会影响作业 / 进程的等待时间。</p>\n<p>同理，也有平均等待时间指标</p>\n<p><strong>响应时间</strong></p>\n<p>响应时间：指从用户提交请求到首次产生响应所用的时间</p>\n<h3 id=\"调度算法\"><a class=\"anchor\" href=\"#调度算法\">#</a> 调度算法</h3>\n<h4 id=\"先来先服务fcfs\"><a class=\"anchor\" href=\"#先来先服务fcfs\">#</a> 先来先服务 (FCFS)</h4>\n<ul>\n<li>算法思想：主要从 &quot;公平&quot; 的角度考虑</li>\n<li>算法规则：按照作业 / 进程到达的先后顺序进行服务</li>\n<li>用于作业 / 进程调度：用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列</li>\n<li>是否可抢占：非抢占式算法</li>\n<li>优缺点\n<ul>\n<li>优点：公平、算法实现简单</li>\n<li>缺点：排在长作业 (进程) 后面的短作业需要等待很长时间，带全周期时间很大，对短作业来说用户体验不好。即 FCFS 算法对长作业有利，对短作业不利</li>\n</ul>\n</li>\n<li>是否会导致饥饿：不会</li>\n</ul>\n<h4 id=\"短作业优先sjf\"><a class=\"anchor\" href=\"#短作业优先sjf\">#</a> 短作业优先 (SJF)</h4>\n<ul>\n<li>算法思想：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间</li>\n<li>算法规则：最短的作业 / 进程优先得到服务 (所谓 &quot;最短&quot;，是要求服务时间最短)</li>\n<li>用于作业 / 进程调度：即可用于作业调度，也可用于进程调度。用于进程调度时称为 &quot;短进程优先算法 (SPF)&quot;</li>\n<li>是否可抢占：SJF 和 SPF 是非抢占式算法，但是也有抢占式算法 —— 最短剩余时间优先算法 (SRTN)\n<ul>\n<li>最短剩余时间优先算法：每当有进程加入就绪队列改变时就需要调整调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时也需要调度</li>\n</ul>\n</li>\n<li>优缺点：\n<ul>\n<li>优点：&quot;最短的（不严谨）&quot; 平均等待时间、平均周转时间</li>\n<li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业 / 进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的最短作业优点</li>\n</ul>\n</li>\n<li>是否会导致饥饿：会。如果源源不断地有短作业 / 进程到来，可能是长作业 / 进程长时间得不到服务，产生饥饿现象</li>\n</ul>\n<h4 id=\"高响应比优先hrrn\"><a class=\"anchor\" href=\"#高响应比优先hrrn\">#</a> 高响应比优先 (HRRN)</h4>\n<ul>\n<li>算法思想：要综合考虑作业 / 进程的等待时间和要求服务的时间</li>\n<li>算法规则：在每次调度时先计算各个作业 / 进程的响应比，选择响应比最高的作业 / 进程为其服务\n<ul>\n<li>响应比：(等待时间 + 要求服务时间)/ 要求服务时间</li>\n</ul>\n</li>\n<li>用于作业 / 进程调度：既可用于作业调度，也可用于进程调度</li>\n<li>是否可以抢占：非抢占式的算法。因此只有当前运行的作业 / 进程主动放弃处理机时，才需要调度，才需要计算响应比</li>\n<li>优缺点：\n<ul>\n<li>综合考虑了等待时间和运行时间 (要求服务时间)</li>\n<li>等待时间相同时，要求服务时间短的有限 (SJF 的优点)</li>\n<li>要求服务时间相同时，等待时间长的有限 (PCS 的优点)</li>\n<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</li>\n<li>是否会导致饥饿：不会</li>\n</ul>\n</li>\n</ul>\n<p>这三种算法一般适合用于早期的批处理系统。</p>\n<h4 id=\"时间片轮转调度算法rr\"><a class=\"anchor\" href=\"#时间片轮转调度算法rr\">#</a> 时间片轮转调度算法 (RR)</h4>\n<ul>\n<li>算法思想：公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li>\n<li>算法规则：按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片。若进程未在一个时间片内执行完，则剥夺处理机。将进程重新放回就绪队列队尾重新排队</li>\n<li>用于作业 / 进程调度：用于进程调度 (只有作业放入内存建立了相应进程后，才能被分配处理机时间片)</li>\n<li>是否可抢占：若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知 CPU 时间片已到\n<ul>\n<li>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</li>\n<li>另一方面，进程调度、切换是有时间代价的 (保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少，可见时间片也不能太小</li>\n<li>一般来说，设计时间片时要让切换进程的开销占比不超过 1%</li>\n</ul>\n</li>\n<li>优缺点：\n<ul>\n<li>优点：公平；响应快，适用于分时操作系统</li>\n<li>缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度</li>\n</ul>\n</li>\n<li>是否会导致饥饿：不会</li>\n</ul>\n<h4 id=\"优先级调度算法\"><a class=\"anchor\" href=\"#优先级调度算法\">#</a> 优先级调度算法</h4>\n<ul>\n<li>算法思想：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</li>\n<li>算法规则：每个作业 / 进程由各自的优先级，调度时选择优先级最高的作业 / 进程</li>\n<li>用于作业 / 进程：既可用于作业调度，也可用于进程调度和 I/O 调度</li>\n<li>是否可抢占：抢占式、非抢占式都有\n<ul>\n<li>非抢占式需要在进程主动放弃处理机时进行调度即可</li>\n<li>抢占式还需在就绪队列变化时，检查是否会发生抢占</li>\n</ul>\n</li>\n<li>优缺点：\n<ul>\n<li>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整各种作业 / 进程的偏好程度。</li>\n<li>缺点：若源源不断地有高优先级进程到达，则可能导致饥饿</li>\n</ul>\n</li>\n<li>是否会导致饥饿：会</li>\n<li>补充：\n<ul>\n<li>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置</li>\n<li>根据优先级是否可以改变，可将优先级分为静态优先级和动态优先级两种</li>\n<li>静态优先级：创建进程时确定，之后一直不变</li>\n<li>动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级\n<ul>\n<li>可以从追求公平、提升资源利用率等角度考虑</li>\n<li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li>\n<li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li>\n</ul>\n</li>\n<li>通常：系统进程优先级高于用户进程；前台进程优先级高于后台进程；操作系统更偏好 I/O 型进程 (或称 I/O 繁忙型进程)\n<ul>\n<li>注：与 I/O 型进程相对的是计算型进程 (或称 CPU 繁忙型进程)</li>\n<li>I/O 设备和 CPU 可以并行工作。如果优先让 I/O 繁忙型进程优先运行的话，则越有可能让 I/O 设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多级反馈队列调度算法\"><a class=\"anchor\" href=\"#多级反馈队列调度算法\">#</a> 多级反馈队列调度算法</h4>\n<ul>\n<li>\n<p>算法思想：对其他调度算法的折中权衡</p>\n</li>\n<li>\n<p>算法规则：</p>\n<ul>\n<li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li>\n<li>新进程到达时先进入第 1 级队列，按 FCFS 原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是最下级的队列，则重新放回该队列队尾</li>\n<li>只有第 k 级队列为空时，才为 k+1 级队头的进程分配时间片</li>\n</ul>\n</li>\n<li>\n<p>用于作业 / 进程调度：用于进程调度</p>\n</li>\n<li>\n<p>是否可抢占：抢占式的算法：在 k 级队列的进程运行过程中，若更上级的队列 (1~k-1 级) 中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来的进程放回 k 级队列队尾</p>\n</li>\n<li>\n<p>优缺点：对各类型进程相对公平 (FCFS 的优点)；每个新到达的进程都可以很快就得到响应 (RR 的优点)；短进程只用较少的时间就可完成 (SPF 的优点)；不必实现估计进程的运行时间 (避免用户作假)；可灵活地调整对各类进程的偏好程度，比如 CPU 密集型进程、I/O 密集型进程（拓展：可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程就可以保持较高优先级）</p>\n</li>\n<li>\n<p>是否会导致饥饿：会</p>\n</li>\n</ul>\n<h4 id=\"多级队列调度算法\"><a class=\"anchor\" href=\"#多级队列调度算法\">#</a> 多级队列调度算法</h4>\n<p>系统中按进程类型设置多个队列，进程创建成功后插入某个队列</p>\n<p>队列之间可采取固定优先级，或时间片</p>\n<ul>\n<li>系统进程：优先级调度</li>\n<li>交互式进程：RR 时间片轮转调度</li>\n<li>批处理进程：FCFS 调度</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        },
        {
            "id": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-1/",
            "url": "http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-1/",
            "title": "操作系统408-2-1",
            "date_published": "2024-07-30T13:42:20.000Z",
            "content_html": "<p><span id=\"more\"></span></p>\n<h3 id=\"进程的概念-组成-特征\"><a class=\"anchor\" href=\"#进程的概念-组成-特征\">#</a> 进程的概念、组成、特征</h3>\n<h4 id=\"概念\"><a class=\"anchor\" href=\"#概念\">#</a> 概念</h4>\n<p>程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列额指令集合</p>\n<p>进程：是动态的，是程序的一次执行过程（同一个程序多次执行会对应多个进程）</p>\n<h4 id=\"组成\"><a class=\"anchor\" href=\"#组成\">#</a> 组成</h4>\n<p><strong>PCB</strong></p>\n<ul>\n<li>进程描述信息：进程标识符 PID、用户标识符 UID</li>\n<li>进程控制和管理信息：\n<ul>\n<li>CPU、磁盘、网络流量使用情况统计...</li>\n<li>进程当前状态：就绪态 / 阻塞态 / 运行态...</li>\n</ul>\n</li>\n<li>资源分配清单：\n<ul>\n<li>正在使用哪些文件</li>\n<li>正在使用哪些内存区域</li>\n<li>正在使用哪些 I/O 设备</li>\n</ul>\n</li>\n<li>处理机相关信息：如 PSW、PC 等等各种寄存器的值 (用于实现进程切换)</li>\n</ul>\n<p>操作系统对进程进行管理工作所需的信息都存在 PCB 中</p>\n<p>PCB 是进程存在的唯一标志，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB</p>\n<p><strong>进程的组成</strong></p>\n<ul>\n<li>PCB</li>\n<li>程序段：程序的代码 (指令序列)</li>\n<li>数据段：运行过程中产生的各种数据 (如：程序中定义的变量)</li>\n</ul>\n<p>PCB 是给操作系统用的，程序段和数据段是给进程自己用的</p>\n<p>程序段、数据段、PCB 三部分组成了进程实体 (进程映象)</p>\n<p>引入进程的概念后，可把进程定义为：</p>\n<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>\n<p>注意：PCB 是进程存在的唯一标识</p>\n<p>一个进程被 &quot;调度&quot;，就是指操作系统决定让这个进程上 CPU 运行</p>\n<h4 id=\"进程的特征\"><a class=\"anchor\" href=\"#进程的特征\">#</a> 进程的特征</h4>\n<ul>\n<li>动态性（进程最基本特征）\n<ul>\n<li>进程是程序的一次执行过程，是动态产生的、变化和消亡的</li>\n</ul>\n</li>\n<li>并发性\n<ul>\n<li>内存中有多个进程实体，各进程可并发执行</li>\n</ul>\n</li>\n<li>独立性\n<ul>\n<li>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>\n</ul>\n</li>\n<li>异步性\n<ul>\n<li>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供 &quot;进程同步机制&quot; 来解决异步问题</li>\n</ul>\n</li>\n<li>结构性\n<ul>\n<li>每个进程都会配置一个 PCB。结构上看，进程由程序段、数据段、PCB 组成</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程的状态与转换-进程的组织\"><a class=\"anchor\" href=\"#进程的状态与转换-进程的组织\">#</a> 进程的状态与转换、进程的组织</h3>\n<h4 id=\"进程的状态\"><a class=\"anchor\" href=\"#进程的状态\">#</a> 进程的状态</h4>\n<ul>\n<li>进程正在被创建时，它的状态是 &quot;创建态&quot;，在这个阶段操作系统会为进程分配资源、初始化 PCB</li>\n<li>当进程创建完成后，便进入 &quot;就绪态&quot;，处于就绪态的进程已经具备运行条件，但由于没有空闲 CPU，就暂时不能运行</li>\n<li>如果一个进程此时在 CPU 上运行，那么这个进程处于 &quot;运行态&quot;，CPU 会执行该进程对应的程序 (执行指令序列)</li>\n<li>在进程运行的过程中，可能会请求等待某个事件的发生 (如等待某种系统资源的分配，或者等待其他进程的响应)。在这个进程下 CPU，并让它进入 &quot;阻塞态&quot;，当 CPU 空闲时，又会选择另一个 &quot;就绪态&quot; 的进程上 CPU 运行</li>\n<li>一个进程可以执行 exit 系统调用，请求操作系统终止该进程。此时该进程会进入 &quot;终止态&quot;，操作系统会让该进程下 CPU，并回收内存空间等资源，最后还要回收该进程的 PCB</li>\n</ul>\n<p>当终止进程的工作完成后，这个进程就彻底消失了</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/01/1LySRp7ksNqb8l9.png\" alt=\"进程的状态转换\" /></p>\n<p>运行态、就绪态、阻塞态（三种为基本状态）</p>\n<h4 id=\"进程的组织\"><a class=\"anchor\" href=\"#进程的组织\">#</a> 进程的组织</h4>\n<ul>\n<li>链接方式\n<ul>\n<li>按照进程状态将 PCB 分为多个队列</li>\n<li>操作系统持有指向各个队列的指针</li>\n</ul>\n</li>\n<li>索引方式\n<ul>\n<li>根据进程状态的不同，建立几张索引表</li>\n<li>操作系统持有指向各个索引表的指针</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"进程控制\"><a class=\"anchor\" href=\"#进程控制\">#</a> 进程控制</h3>\n<p>进程控制的主要功能是对所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能</p>\n<p>实现进程控制：原语</p>\n<p>原语原子性实现方式：用关中断指令和开中断指令两个特权指令实现原子性</p>\n<h4 id=\"进程的创建\"><a class=\"anchor\" href=\"#进程的创建\">#</a> 进程的创建</h4>\n<ul>\n<li>创建原语（操作系统创建一个进程时使用的原语）\n<ul>\n<li>申请空白 PCB</li>\n<li>为新进程分配所需资源</li>\n<li>初始化 PCB</li>\n<li>将 PCB 插入就绪队列（创建态 -&gt; 就绪态）</li>\n</ul>\n</li>\n<li>引起进程创建的事件\n<ul>\n<li>用户登录：分时系统中，用户登录成功，系统会为其建立一个新进程</li>\n<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>\n<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>\n<li>应用请求：由用户进程主动请求创建一个子进程</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程的终止\"><a class=\"anchor\" href=\"#进程的终止\">#</a> 进程的终止</h4>\n<ul>\n<li>撤销原语（就绪态 / 阻塞态 / 运行态 -&gt; 终止态 -&gt; 无）\n<ul>\n<li>从 PCB 集合中找到终止进程的 PCB</li>\n<li>若进程正在运行，立刻剥夺 CPU，将 CPU 分配给其他进程</li>\n<li>终止其他所有子进程</li>\n<li>将该进程拥有的所有资源归还给父进程或操作系统</li>\n<li>删除 PCB</li>\n</ul>\n</li>\n<li>引起进程终止的事件\n<ul>\n<li>正常结束</li>\n<li>异常结束</li>\n<li>外界干预</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程的阻塞和唤醒\"><a class=\"anchor\" href=\"#进程的阻塞和唤醒\">#</a> 进程的阻塞和唤醒</h4>\n<ul>\n<li>进程的阻塞\n<ul>\n<li>阻塞原语（运行态 -&gt; 阻塞态）\n<ul>\n<li>找到要阻塞的进程对应的 PCB</li>\n<li>保护进程运行现场，将 PCB 状态设置为 &quot;阻塞态&quot;，暂时停止进程运行</li>\n<li>将 PCB 插入相应事件的等待队列</li>\n</ul>\n</li>\n<li>引起进程阻塞的事件\n<ul>\n<li>需要等待系统分配某种资源</li>\n<li>需要等待相互合作的其他进程完成工作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>进程的唤醒\n<ul>\n<li>唤醒原语（阻塞态 -&gt; 就绪态）\n<ul>\n<li>在事件等待队列中找到 PCB</li>\n<li>将 PCB 从等待队列中移除，设置进程为就绪态</li>\n<li>将 PCB 插入就绪队列，等待被调度</li>\n</ul>\n</li>\n<li>引起进程唤醒的事件\n<ul>\n<li>等待的事件发生</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"进程的切换\"><a class=\"anchor\" href=\"#进程的切换\">#</a> 进程的切换</h4>\n<ul>\n<li>切换原语（运行态 -&gt; 就绪态，就绪态 -&gt; 运行态）\n<ul>\n<li>将运行环境信息存入 PCB</li>\n<li>PCB 移入相应队列</li>\n<li>选择另一个进程执行，并更新其 PCB</li>\n<li>根据 PCB 恢复进程所需的运行环境</li>\n</ul>\n</li>\n<li>引起进程切换的事件\n<ul>\n<li>当前进程时间片到</li>\n<li>有更高优先级的进程到达</li>\n<li>当前进程主动阻塞</li>\n<li>当前进程终止</li>\n</ul>\n</li>\n</ul>\n<p>阻塞和唤醒必须成对出现</p>\n<p>无论哪个进程控制原语，要做无非三件事：</p>\n<ul>\n<li>更新 PCB 中的信息 (修改进程 State，保存 / 恢复运行环境)</li>\n<li>将 PCB 插入合适的队列</li>\n<li>分配 / 回收资源</li>\n</ul>\n<h3 id=\"进程通信\"><a class=\"anchor\" href=\"#进程通信\">#</a> 进程通信</h3>\n<p>进程间通信：是指两个进程之间产生数据交互</p>\n<p>进程是分配系统资源的单位 (包括内存地址空间)，因此各进程拥有的内存地址空间相互独立</p>\n<p>为了保证安全，一个进程不能直接访问另一个进程的地址空间</p>\n<p><strong>共享存储</strong></p>\n<p>申请一片共享存储区域，两个进程都可以访问，但需要保证各个进程对共享空间的访问是互斥的</p>\n<p>基于存储区的共享：操作系统会在内存中划出一块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种高级通信方式</p>\n<p>基于数据结构的共享：比如共享空间里只能放一个长度为 10 的数组，这种共享方式速度慢，限制多是一种低级通信方式</p>\n<p><strong>消息传递</strong></p>\n<p>进程的数据交换以格式化的消息为单位，进程通过操作系统提供的发送消息 / 接收消息两个原语进行数据交换</p>\n<p>格式化的消息：</p>\n<ul>\n<li>消息头：消息头包括：发送进程 ID、接收进程 ID、消息长度等格式化的信息</li>\n<li>消息体</li>\n</ul>\n<p>直接通信方式：消息发送进程要指明接收进程 ID</p>\n<ul>\n<li>发送方发送消息至内存中的消息队列中，并指明消息的接收方</li>\n<li>接收方从消息队列中接收消息</li>\n</ul>\n<p>间接通信方式：通过 &quot;信箱&quot; 间接地通信。因此又被称为 &quot;信箱通信方式&quot;</p>\n<ul>\n<li>发送方发送消息至内存中的信箱中，指明要发送至哪一个信箱</li>\n<li>接收放要指明要从哪一个信箱中接收信息</li>\n<li>可以多个进程往同一个信箱 send 消息，也可以多个进程从同一个信箱里接收消息</li>\n</ul>\n<p><strong>管道通信</strong></p>\n<p>管道是一个特殊的共享文件，其实就是在内存开辟一个大小固定的内存缓冲区</p>\n<ul>\n<li>管道只能采用半双工通信，某一时间内只能实现单向的传输。如果要实现双向同时传输，则需要设置两个管道</li>\n<li>各进程要互斥地访问管道 (由操作系统实现)</li>\n<li>当管道写满时，写进程将阻塞，直到读进程将管道中的数据取走，即可唤醒写进程</li>\n<li>当管道读空时，读进程将阻塞，直到写进程往管道中写入数据，即可唤醒读进程</li>\n<li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。对此，通常有两种解决方案\n<ul>\n<li>一个管道允许多个写进程，一个读进程</li>\n<li>允许有多个写进程，多个读进程，但系统会让各个读进程轮流从管道中读取数据</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程\"><a class=\"anchor\" href=\"#线程\">#</a> 线程</h3>\n<p>线程是一个基本的 CPU 执行单元，也是程序执行流的最小单位。</p>\n<p><strong>引入线程后变化</strong></p>\n<ul>\n<li>资源分配、调度\n<ul>\n<li>传统进程机制中，进程是资源分配、调度的基本单位</li>\n<li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位</li>\n</ul>\n</li>\n<li>并发性\n<ul>\n<li>传统进程机制中，只能进程间并发</li>\n<li>引入线程后，各线程间也能并发，提升了并发度</li>\n</ul>\n</li>\n<li>系统开销\n<ul>\n<li>传统的进程间并发，需要切换进程的运行环境，系统开销很大</li>\n<li>线程间并发，如果是同一个进程内的线程切换，则不需要切换进程环境，系统开销小</li>\n<li>引入线程后，并发所带来的系统开销减小</li>\n</ul>\n</li>\n</ul>\n<p><strong>线程的属性</strong></p>\n<ul>\n<li>线程是处理机调度的单位</li>\n<li>多 CPU 计算机中，各个线程可占用不同的 CPU</li>\n<li>每一个线程都有一个线程 ID、线程控制块 (TCB)</li>\n<li>线程也有就绪、阻塞、运行三种基本状态</li>\n<li>线程几乎不拥有系统资源</li>\n<li>同一进程的不同线程间共享进程的资源</li>\n<li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li>\n<li>同一个进程中的线程切换，不会引起进程切换</li>\n<li>不同进程中的线程切换，会引起进程切换</li>\n<li>切换同进程内的线程，系统开销很小</li>\n<li>切换进程，系统开销较大</li>\n</ul>\n<h3 id=\"线程的实现方式和多线程模型\"><a class=\"anchor\" href=\"#线程的实现方式和多线程模型\">#</a> 线程的实现方式和多线程模型</h3>\n<h4 id=\"线程的实现方式\"><a class=\"anchor\" href=\"#线程的实现方式\">#</a> 线程的实现方式</h4>\n<p><strong>用户级线程</strong></p>\n<ul>\n<li>\n<p>用户级线程由应用程序通过线程库实现，所有的线程管理工作都由应用程序负责 (包括线程切换)</p>\n</li>\n<li>\n<p>用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预</p>\n</li>\n<li>\n<p>在用户看来，是有多个线程，但是在操作系统内核看来，并意识不到线程的存在 &quot;用户级线程&quot; 就是 &quot;从用户视角看能看到的线程&quot;</p>\n</li>\n<li>\n<p>优缺点：</p>\n<ul>\n<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>\n<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并发运行</li>\n</ul>\n</li>\n</ul>\n<p><strong>内核级线程</strong></p>\n<ul>\n<li>内核级线程的管理工作由操作系统内核完成</li>\n<li>线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成</li>\n<li>操作系统会为每个内核级线程建立相应的 TCB (线程控制块)，通过 TCB 对线程进行管理。&quot;内核级线程&quot; 就是 &quot;从操作系统内核视角看能看到的线程&quot;</li>\n<li>优缺点：\n<ul>\n<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li>\n<li>缺点：一个用户进程会占用多个内核线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多线程模型\"><a class=\"anchor\" href=\"#多线程模型\">#</a> 多线程模型</h4>\n<p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型</p>\n<ul>\n<li>一对一模型：一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程\n<ul>\n<li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行</li>\n<li>缺点：一个用户进程会占用多个内核线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销</li>\n</ul>\n</li>\n<li>多对一模型：多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程\n<ul>\n<li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>\n<li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并发运行</li>\n</ul>\n</li>\n</ul>\n<p>重点：操作系统只 &quot;看得见&quot; 内核级线程，因此只有内核级线程才是处理机分配的单位</p>\n<ul>\n<li>多对多模型：n 用户级线程映射到 m 个内核级线程 (n&gt;=m)。每个用户进程对应 m 个内核级线程\n<ul>\n<li>克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"线程的状态与转换\"><a class=\"anchor\" href=\"#线程的状态与转换\">#</a> 线程的状态与转换</h3>\n<p><img data-src=\"https://s2.loli.net/2024/08/02/QDCOhpBgdXo7mUt.png\" alt=\"三状态转换图\" /></p>\n<p>线程的组织与控制：</p>\n<p><img data-src=\"https://s2.loli.net/2024/08/02/3P8VuwTtigWz1ye.png\" alt=\"组织控制图\" /></p>\n",
            "tags": [
                "计算机科学",
                "操作系统",
                "考研408",
                "操作系统"
            ]
        }
    ]
}