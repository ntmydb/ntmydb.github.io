<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.jpg"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="Whispering's Blog" href="http://ntmydb/github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="Whispering's Blog" href="http://ntmydb/github.io/atom.xml"><link rel="alternate" type="application/json" title="Whispering's Blog" href="http://ntmydb/github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="考研408,操作系统"><link rel="canonical" href="http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/"><title>操作系统 408-3-1 - 操作系统 - 计算机科学 | Flüstern = Whispering's Blog = 无需过去，无关未来，只有现在</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">操作系统 408-3-1</h1><div class="meta"><span class="item" title="创建时间：2024-08-05 21:53:38"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2024-08-05T21:53:38+08:00">2024-08-05</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>11k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>10 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Flüstern</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2023/10/27/gwokc9U1GDA5sZK.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/10/29/uBa9qmiRekwHKfs.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/10/27/hfc7q4pMWgDSB9v.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/10/26/NC6gibTseq9KhOr.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/10/25/I5QdftlE6wGqPnj.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2023/10/27/xBQo6N7jiG4rtVJ.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computer-science/operating-system/" itemprop="item" rel="index" title="分类于 操作系统"><span itemprop="name">操作系统</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Whispering"><meta itemprop="description" content="无需过去，无关未来，只有现在, Whispering's Blog"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Whispering's Blog"></span><div class="body md" itemprop="articleBody"><p><span id="more"></span></p><h3 id="内存的基本知识"><a class="anchor" href="#内存的基本知识">#</a> 内存的基本知识</h3><p>内存可存放数据。程序执行前需要先放到内存中才能被 CPU 处理 —— 缓和 CPU 和硬盘之间的速度矛盾</p><p>内存被分为了很多存储单元，内存地址从 0 开始，每个地址对应一个存储单元</p><p>如果计算机 &quot;按字节编址&quot;，则每个存储单元大小为 1 字节，即 1B，8 个二进制位</p><p>如果字长为 16 位的计算机 &quot;按字编址&quot;，则每个存储单元大小为 1 个字，每个字的大小为 16 个二进制位</p><p><strong>补充</strong></p><p 30="">1K=2^{10},1M=2^{20},1G=2^</p><p>逻辑地址 -&gt; 物理地址</p><p>编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）</p><p>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块</p><p>装入（装载）：由装入程序将装入模块装入内存运行</p><p><strong>三种装入方法</strong></p><ul><li>绝对装入<ul><li>在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存</li><li>编译、链接后得到的装入模块的指令直接就使用了绝对地址，即在编译时把逻辑地址转为物理地址</li><li>绝对装入只适用于单道程序环境</li></ul></li><li>可重定位装入（静态重定位）<ul><li>编译、链接后的装入模块的地址都是从 0 开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行 &quot;重定位&quot;，将逻辑地址变换为物理地址 (地址变换是装入时一次完成的)</li><li>静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业</li><li>作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间</li></ul></li><li>动态运行时装入（动态重定位）<ul><li>编译、链接后的装入模块的地址都是从 0 开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址转换推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持</li><li>重定位寄存器：存放装入模块存放的起始位置</li><li>采用动态重定位时允许程序在内存中发生移动</li><li>可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li></ul></li></ul><p><strong>链接的三种方式</strong></p><ul><li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开</li><li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li><li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享</li></ul><h3 id="内存管理"><a class="anchor" href="#内存管理">#</a> 内存管理</h3><p>内存空间的分配与回收</p><ul><li>操作系统负责内存空间的分配与回收</li></ul><p>内存空间的扩充（实现虚拟性）</p><ul><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li></ul><p>地址转换</p><ul><li>操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换<ul><li>为了让编程人员更方便，程序员写程序时应该只需要关注指令、数据的逻辑地址。而逻辑地址到物理地址的转换（这个过程称为地址重定位）应该由操作系统负责，这样就保证了程序员写程序时不需要关注物理内存的实际情况</li></ul></li></ul><p>存储保护：</p><ul><li><p>操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰</p></li><li><p>内存保护可采取两种方法：</p><ul><li>在 CPU 上设置一对上、下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU 检查是否越界</li><li>采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器中存放的是进程的最大逻辑地址</li></ul></li></ul><h3 id="覆盖与交换"><a class="anchor" href="#覆盖与交换">#</a> 覆盖与交换</h3><p><strong>覆盖技术</strong></p><p>覆盖技术：解决程序大小超过物理内存总和的问题</p><p>覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段在需要时调入内存</p><p>内存中分为一个 &quot;固定区&quot; 和若干个 &quot;覆盖区&quot;。</p><p>需要常驻内存的段放在 &quot;固定区&quot; 中，调入后就不再调出 (除非运行结束)</p><p>不常用的段放在 &quot;覆盖区&quot;，需要用到时调入内存，用不到时调出内存</p><p>必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：对用户不透明，增加了用户编程负担。</p><p>覆盖技术只用于早期的操作系统中，现在已成为历史</p><p><strong>交换技术</strong></p><p>交换 (对换) 技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存 (进程在内存与磁盘间动态调度)</p><p>中级调度（内存调度）：决定将哪个处于挂起状态的进程重新调入内存</p><ul><li><p>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分，文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的 I/O 速度比文件区更快</p></li><li><p>交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。</p></li><li><p>可优先换出阻塞进程，可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间</p></li></ul><p>注意：PCB 会常驻内存，不会被换出外存</p><h3 id="连续分配管理方式"><a class="anchor" href="#连续分配管理方式">#</a> 连续分配管理方式</h3><p>连续分配：指为用户进程分配的必须是一个连续的内存空间</p><h4 id="单一连续分配"><a class="anchor" href="#单一连续分配">#</a> 单一连续分配</h4><p>在单一连续分配方式中，内存被分为系统区和用户区</p><p>系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据</p><p>内存中只能有一道用户程序，用户程序独占整个用户区空间</p><p>优点：实现简单；无外部碎片；可以采用覆盖技术扩充内存；不一定需要采取内存保护</p><p>缺点：只能用于单用户、单任务的操作系统中；有内部碎片；存储器利用率极低</p><ul><li>内部碎片：分配给某进程的内存区域当中，没有被用上的某些部分就是内部碎片</li></ul><h4 id="固定分区分配"><a class="anchor" href="#固定分区分配">#</a> 固定分区分配</h4><p>为了能在内存中装入多道程序，且这些程序又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成最早的、最简单的一种可运行多道程序的内存管理方式</p><ul><li>分区大小相等<ul><li>缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合</li></ul></li><li>分区大小不等<ul><li>增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区，适量中分区，少量大分区）</li></ul></li></ul><p>操作系统需要建立一个数据结构 —— 分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）</p><p>当某用户程序要装入内存时，由操作系统内核程序根据用户大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为 &quot;已分配&quot;</p><p>优点：实现简单，无外部碎片</p><p>缺点：</p><ul><li>当程序太大时，可能所有的分区都不能满足需求，此时不得不采取覆盖技术来解决，但这又会降低性能；</li><li>会产生内部碎片，内存利用率低</li></ul><h4 id="动态分区分配"><a class="anchor" href="#动态分区分配">#</a> 动态分区分配</h4><p>动态分区分配又称为可变分区分配，这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小是可变的。</p><ul><li><p>操作系统用什么数据结构记录内存的使用情况</p><ul><li>空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息</li><li>空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息</li></ul></li><li><p>当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p><ul><li>按照一定的动态分区分配算法，从空闲分区表或空闲分区链中选一个分区分配给该作业</li></ul></li><li><p>如何进行分区的分配与回收操作</p><ul><li>情况一：回收区的后面有一个相邻的空闲分区：两个相邻的空闲分区合并为一个，修改相应的起始地址</li><li>情况二：回收区的前面有一个相邻的空闲分区：两个相邻的空闲分区合并为一个，修改相应的起始地址</li><li>情况三：回收区的前、后各有一个相邻的空闲分区：三个相邻的空闲分区合并为一个，修改相应的起始地址</li><li>情况四：回收区的前、后都没有相邻的空闲分区：增加一个表项</li></ul></li></ul><p>注：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定</p><p>动态分区分配没有内部碎片，但是有外部碎片</p><p>内部碎片，分配给某进程的内存区域中，如果有些部分没有用上。</p><p>外部碎片，是指内存中的某些空闲分区由于太小而难以利用</p><p>如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些 &quot;碎片&quot; 不能满足进程的需求。可以通过紧凑技术来解决外部碎片</p><h3 id="动态分区分配算法"><a class="anchor" href="#动态分区分配算法">#</a> 动态分区分配算法</h3><p>动态分区分配算法：在动态分区分配方式中，当很多个空闲分区都能满足需求时，应该选择哪一个分区进行分配</p><h4 id="首次适应算法"><a class="anchor" href="#首次适应算法">#</a> 首次适应算法</h4><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区</p><p>如何实现：空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链 (或空闲分区表)，找到大小能满足要求的第一个空闲分区</p><h4 id="最佳适应算法"><a class="anchor" href="#最佳适应算法">#</a> 最佳适应算法</h4><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当 &quot;大进程&quot; 到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区</p><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链 (或空闲分区表)，找到大小能满足要求的第一个空闲分区</p><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块，因此这种方式会产生很多的外部碎片。</p><h4 id="最坏适应算法"><a class="anchor" href="#最坏适应算法">#</a> 最坏适应算法</h4><p>又称最大适应算法</p><p>算法思想：为了解决最佳适应算法的问题 —— 即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲分区，这样分配剩余的空间区就不会太小，更方便实用</p><p>如何实现：空闲分区按容量进行递减次序链接。每次分配内存时顺序查找空闲分区链 (空闲分区表)，找到大小能满足要求的第一个空闲分区</p><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲分区被迅速用完。如果之后有 &quot;大进程&quot; 达到，就没有内存分区可用了</p><h4 id="邻近适应算法"><a class="anchor" href="#邻近适应算法">#</a> 邻近适应算法</h4><p>算法思想：首次适应算法每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列（可排列成一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区</p><p>首次适应算法每次都要从头查找，每次都要检索低地址的小分区，但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也会导致高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点）</p><p>综合来看，四种算法中，首次适应算法的效果反而更好</p><h3 id="基本分页存储管理"><a class="anchor" href="#基本分页存储管理">#</a> 基本分页存储管理</h3><p>将内存空间分为一个个大小相等的分区，每个分区就是一个 &quot;页框&quot;（页框 = 页帧 = 内存块 = 物理块 = 物理页面）。每个页面有一个编号，即 &quot;页框号&quot;（页框号 = 页帧号 = 内存块号 = 物理块号 = 物理页号），页框号从 0 开始</p><p>将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个 &quot;页&quot; 或 &quot;页面&quot;。每个页面也有一个编号，即 &quot;页号&quot;，页号也是从 0 开始</p><p>操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。各个页面不必连续存放，可以放到不相邻的各个页框中</p><h4 id="重要的数据结构页表"><a class="anchor" href="#重要的数据结构页表">#</a> 重要的数据结构 —— 页表</h4><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表</p><p>注：页表通常存在 PCB (进程控制块) 中</p><ul><li><p>一个进程对应一张页表</p></li><li><p>进程的每个页表对应一个页表项</p></li><li><p>每个页表项由 &quot;页号&quot; 和 &quot;块号&quot; 组成</p></li><li><p>页表记录进程页面和实际存放的内存块之间的映射关系</p></li></ul><p>重要考点：计算机中内存块的数量 -&gt; 页表项中块号至少占多少字节</p><p>例：假设某系统中物理内存大小为 4GB，页面大小为 4KB，则每个页表项至少应该为多少字节？</p><ul><li>内存块大小 = 页面大小 = 4KB</li><li>物理内存可以分成 4GB=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>∗</mo><msup><mn>2</mn><mn>30</mn></msup><mi mathvariant="normal">/</mi><mn>4</mn><mi>K</mi><mi>B</mi><mo>=</mo><msup><mn>2</mn><mn>32</mn></msup><mi mathvariant="normal">/</mi><msup><mn>2</mn><mn>12</mn></msup><mo>=</mo><msup><mn>2</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">4*2^{30}/4KB=2^{32}/2^{12}=2^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">4</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord">4</span><span class="mord mathnormal" style="margin-right:.07153em">K</span><span class="mord mathnormal" style="margin-right:.05017em">B</span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span></span></span></span> 个块</li><li>内存块号的范围应该是 0~<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>20</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{20}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.897438em;vertical-align:-.08333em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span></li><li>内存块至少需要 20 个 bit 表示</li><li>至少需要 3B=3*8bit=24bit&gt;20bit 来表示块号，因此每个页表项至少应该为 3 字节</li></ul><p>页表项连续存放，因此页号可以是隐含的，不占存储空间 (类比数组)</p><ul><li>由于页号是隐含的，因此每个页表项占 3B，储存整个页表至少需要<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><mo>×</mo><msup><mn>2</mn><mn>20</mn></msup><mo>=</mo><mn>3</mn><mo>×</mo><msup><mn>2</mn><mn>21</mn></msup></mrow><annotation encoding="application/x-tex">3\times2^{20}=3\times2^{21}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.72777em;vertical-align:-.08333em"></span><span class="mord">3</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 页</li></ul><p><strong>地址转换</strong></p><p>重定位寄存器：指明了进程在内存中起始位置</p><p>相对于起始位置的 &quot;偏移量&quot;</p><p>特点：虽然进程的各个页面是离散存放的，但是页面内部是连续存放的</p><p>如果要访问逻辑地址 A，则：</p><ul><li><p>确定逻辑地址 A 对应的页号 P</p></li><li><p>找到 P 号页面在内存中的起始地址 (需要查页表)</p></li><li><p>确定逻辑地址 A 的 &quot;页内偏移量&quot;W</p></li><li><p>逻辑地址 A 对应的物理地址 = P 号页在内存中的起始地址 + 页内偏移量 W</p></li></ul><p>页号 = 逻辑地址 / 页面长度（取除法的整数部分）</p><p>页内偏移量 = 逻辑地址 % 页面长度（取除法的余数部分）</p><p>逻辑地址可以拆分为（页号，页内偏移量）</p><p>通过页号查询页表，可知页面在内存中的起始地址</p><p>页面在内存中的起始地址 + 页内偏移量 = 实际的物理地址</p><p>结论：如果每个页面大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span></span></span></span></span></span></span></span></span></span></span>B，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号</p><p>根据页号可以查询页表，而页表中记录的只是内存块号，而不是内存块的起始地址，J 号内存块的起始地址 = J * 内存块大小</p><p>结论：如果页面大小刚好是 2 的整数幂，则只需把页表中记录的物理块号拼接上页内偏移量就能得到对应的物理地址</p><p><strong>页面大小刚好是 2 的整数幂由什么好处</strong></p><ul><li>逻辑地址的拆分更加迅速 —— 如果每个页面大小为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span></span></span></span></span></span></span></span></span></span></span>B，用二进制数表示逻辑地址，则末尾 K 位即为页内偏移量，其余部分就是页号。因此，如果让每个页面大小为 2 的整数幂计算机硬件就可以很方便地得出一个逻辑地址对应的页号和页内偏移量，而无需进行除法运算，从而提升了运行速度</li><li>物理地址的计算更加迅速 —— 根据逻辑地址得到页号，根据页号查询页表从而找到页面存放的内存块号，将二进制表示的内存块号和页内偏移量拼接起来，就可以得到最终的物理地址</li></ul><p><strong>逻辑地址结构</strong></p><p>如果有 K 位表示页内偏移量，则说明该系统中一个页面的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>K</mi></msup></mrow><annotation encoding="application/x-tex">2^K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.07153em">K</span></span></span></span></span></span></span></span></span></span></span> 个内存单元</p><p>如果有 M 位表示页号，则说明在该系统中，一个进程最多允许由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>M</mi></msup></mrow><annotation encoding="application/x-tex">2^M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8413309999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8413309999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:.10903em">M</span></span></span></span></span></span></span></span></span></span></span> 个页面</p><h3 id="基本地址变换机构"><a class="anchor" href="#基本地址变换机构">#</a> 基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页面将逻辑地址转换为物理地址。</p><p><strong>页表寄存器</strong></p><p>通常会在系统中设置一个页表寄存器（PTR），存放页表在内存中的起始地址 F 和页表长度 M。</p><p>进程未执行时，页表的始址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把他们放到页表寄存器中</p><p><strong>地址变换过程</strong></p><p>设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下：</p><ul><li>计算页号 P 和页内偏移量 W（如果用十进制数手算，则 P=A/L，W=A% L；但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量）</li><li>比较页号 P 和页表长度 M，若 P&gt;=M，则产生越界中断，否则继续执行（注意：页号是从 0 开始的，而页表长度至少是 1，因此 P=M 时也会越界）</li><li>页表中页号 P 对应的页表项地址 = 页表起始地址 F + 页号 * 页表项长度，取出该页表项内容 b，即为内存块号。（注意区分页表项长度、页表长度、页面大小的区别。页表长度指的是这个页表中总共有几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页面大小指的是一个页面占多大的存储空间）</li><li>计算 E=b*L+W，用得到的物理地址 E 去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）</li></ul><p>简洁版：</p><ul><li>根据逻辑地址计算出页号、页内偏移量</li><li>判断页号是否越界</li><li>查询页表，找到页号对应的页表项，确定页面存放的内存块号</li><li>用内存块号和页内偏移量得到物理地址</li><li>访问目标内存单元</li></ul><p>例题：若某页面大小 L 为 1K 字节，页号 2 对应的内存块号 b=8，将逻辑地址 A=2500 转换为物理地址 E。</p><p>解析：求页号 = 2500/1024=2，页内偏移量 = 2500%1024=452，对应内存块号为 8，物理地址 E=8*1024+452=8644</p><p>在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的，即，只要给出了一个逻辑地址，系统就可以自动地算出页号、页内偏移量两个部分，并不需要显式地告诉系统这个逻辑地址中，页内偏移量占多少位</p><p><strong>对页表项大小的进一步探讨</strong></p><p>结论：理论上长度为 3B 即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多字节，使得每个页面恰好可以装得下整数个页表项</p><p>进程页表通常是装在连续的内存块中</p><h3 id="具有快表的地址变换机构"><a class="anchor" href="#具有快表的地址变换机构">#</a> 具有快表的地址变换机构</h3><p><strong>快表</strong></p><p>快表：又称联想寄存器，是一种访问速度比内存快很多的高速缓存 (TLB 不是内存)，用来存放最近访问的页表项的副本，可以加速地址变换的速度。于此对应，内存中的页表常称为慢表</p><p><strong>引入快表后，地址的变换过程</strong></p><ul><li>CPU 给出逻辑地址，由某个硬件算得页号。页内偏移量，将页号与快表中的所有页号进行比较</li><li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可</li><li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）</li></ul><p>由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。</p><p>例题：某系统使用基本分页存储管理，并采用了具有快表的地址变换机构，访问一次快表耗时 1us，访问一次内存耗时 100us。若快表的命中率为 90%，那么访问一个逻辑地址的平均耗时是多少？</p><p>解析：平均耗时为 0.9x (1+100) us+0.1x (1+100+100) us=111us</p><p>有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是 (1+100) x0.8+(100+100)*0.1=110.9us</p><p>若未采用快表机制，则访问一个逻辑地址需要 100+100=200us</p><p><strong>局部性原理</strong></p><p>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数组已被访问过，不久之后该数据很可能再次被访问。（因为程序中存在着大量的循环）</p><p>空间局部性：一旦程序访问了某个存储单元，在不久后，其附近的存储单元也很有可能被访问。（因为很多数据在内存中都是连续存放的）</p><p>TLB 和 Cache 的区别 ——TLB 中只有页表项的副本，而普通 Cache 中可能会有其他各种数据的副本</p><h3 id="两级页表"><a class="anchor" href="#两级页表">#</a> 两级页表</h3><p><strong>单级页表存在的问题</strong></p><p>根据页号的方法：K 号页对应的页表项存放位置 = 页表起始地址 + K*4，要在所有的页表项都连续存放的基础上才能使用这种方法查找页表项。</p><p>根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行了。因此没有必要让整个页表都常驻内存</p><p>问题：</p><ul><li>页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框</li><li>没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面<ul><li>可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存</li><li>若想访问的页面不在内存，则产生缺页中断（内中断），然后将目标页面从外存调入内存</li></ul></li></ul><p>可将长页表进行分组，使每个内存块刚好可以放入一个分组。</p><p>另外，要为离散分配的页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表</p><p><strong>两级页表地址变换</strong></p><ul><li><p>按照地址结构将逻辑地址拆分成三部分</p></li><li><p>从 PCB 中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置</p></li><li><p>根据二级页号查表，找到最终想访问的内存块号</p></li><li><p>结合页内偏移量得到物理地址</p></li></ul><p><strong>细节事项</strong></p><ul><li>若采用多级页表机制，则各级页表的大小不能超过一个页面</li></ul><p>例：某系统按字节编址，采用 40 位逻辑地址，页面大小为 4KB，页表项大小为 4B，假设采用纯页式存储，则要采用（）级页表，页内偏移量为（）位？</p><p>解析：页面大小 = 4KB=<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>12</mn></msup><mi>B</mi></mrow><annotation encoding="application/x-tex">2^{12}B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8141079999999999em;vertical-align:0"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.05017em">B</span></span></span></span>，页内偏移量为 12 位，页号为 40-12=28 位，每个页面可以存放 4KB/4B=1024 个页表项，10 位可以表示出 1024 个页表项，因此 28 位最多可以表示三级页表，最终逻辑地址分为一级页号 (8 位)+ 二级页号 (10 位)+ 三级页号 (10 位)+ 页内偏移量 (12 位)</p><ul><li>两级页表的访存次数分析 (假设没有快表机构)<ul><li>第一次访存：访问内存中的页目录表</li><li>第二次访存：访问内存中的二级页表</li><li>第三次访存：访问目标内存单元</li></ul></li></ul><h3 id="基本分段式存储管理方式"><a class="anchor" href="#基本分段式存储管理方式">#</a> 基本分段式存储管理方式</h3><p>与分页最大的区别就是 —— 离散分配时所分配地址空间的基本单位不同</p><h4 id="分段"><a class="anchor" href="#分段">#</a> 分段</h4><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名（在低级语言中，程序员使用段名来编程），每段从 0 开始编址</p><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p><p>由于是按逻辑功能模块划分，用户编程更方便，程序的可读性更高</p><p>分段系统的逻辑地址结构由段号 (段名) 和段内地址 (段内偏移量) 所组成</p><p>段号的位数决定了每个进程最多可以分几个段</p><p>段内地址位数决定了每个段的最大长度是多少</p><h4 id="段表"><a class="anchor" href="#段表">#</a> 段表</h4><p>程序分为多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称 &quot;段表&quot;</p><ul><li>每个段对应一个段表项，其中记录了该段在内存中的起始位置 (又称 &quot;基址&quot;) 和段的长度</li><li>各个段表项的长度是相同的。段号可以是隐含的，不占存储空间</li></ul><p><strong>地址变换</strong></p><p>简洁版：</p><ul><li>根据逻辑地址计算出段号、段内偏移量</li><li>判断段号是否越界。若 S (段号)&gt;=M (段表长度)，则产生越界中断，否则继续执行</li><li>查询段表，找到段号对应的段表项，段表项的存放地址为 F (段表始址)+S (段号)* 段表项长度</li><li>检查段内地址是否超过段长。若 W (段内地址)&gt;=C (段长)，则产生越界中断，否则继续执行</li><li>计算得到物理地址</li><li>访问目标内存单元</li></ul><h4 id="分段-分页管理对比"><a class="anchor" href="#分段-分页管理对比">#</a> 分段、分页管理对比</h4><p>页是信息的物理单位。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的</p><p>段是信息的逻辑单位。分段的主要目的是为了更好地满足用户需求，一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名</p><p>页的大小固定且由系统决定。段的长度却不固定，决定于用户编写的程序</p><p>分页的用户进程地址空间是一维的，程序员只需给出一个记忆符即可表示一个地址</p><p>分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址</p><p>分段比分页更容易实现信息的共享和保护</p><p>不能被修改的代码称为纯代码或可重入代码 (不属于临界资源)，这样的代码是可以共享的。可修改的代码是不能共享的 (比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)</p><p>分段比分页更容易实现信息的共享和保护</p><p>访问一个逻辑地址需要几次访存：</p><ul><li>分页 (单级页表)：第一次访存 —— 查内存中的页表，第二次访存 —— 访问目标内存单元，总共两次访存</li><li>分段：第一次访存 —— 查内存中的段表，第二次访存 —— 访问目标内存单元，总共两次访存</li></ul><p>与分页系统类似，分段系统中也可以引入快表机构。将近期访问的段表项放到快表中，这样可以少一次访存，加快地址变换速度</p><h3 id="段页式管理方式"><a class="anchor" href="#段页式管理方式">#</a> 段页式管理方式</h3><h4 id="分段-分页的优缺点分析"><a class="anchor" href="#分段-分页的优缺点分析">#</a> 分段、分页的优缺点分析</h4><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>分页管理</td><td>内存空间利用率高，不会产生外部碎片，只会有少量的页内碎片</td><td>不方便按逻辑模块实现信息的共享和保护</td></tr><tr><td>分段管理</td><td>很方便按照逻辑模块实现信息的共享和保护</td><td>如果段长过大，为其分配很大的连续空间会很不方便。另外，段式管理会产生外部碎片</td></tr></tbody></table><p>分段管理产生的外部碎片也可以用 &quot;紧凑&quot; 来解决，只是需要付出较大的时间代价</p><h4 id="分段分页段页式管理"><a class="anchor" href="#分段分页段页式管理">#</a> 分段 + 分页 = 段页式管理</h4><p>将进程按逻辑模块分段，再将各段分页</p><p>再将内存空间分为大小相同的内存块 / 页面 / 物理块</p><p>进程前将各页面分别装入各内存块中</p><h4 id="段页式管理的逻辑地址结构"><a class="anchor" href="#段页式管理的逻辑地址结构">#</a> 段页式管理的逻辑地址结构</h4><p>段页式系统的逻辑地址结构由段号、页号、页内地址 (页内偏移量) 组成</p><p>段号的位数决定了每个进程最多可以分几个段</p><p>页号的位数决定了每个段最大有多少页</p><p>页内偏移量决定了页面大小，内存块大小是多少</p><p>段页式管理的地址结构和分段式管理一样，是二维的</p><h4 id="段表-页表"><a class="anchor" href="#段表-页表">#</a> 段表、页表</h4><p>每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号 (页表起始地址) 组成。每个段表项长度相等，段号是隐含的</p><p>每个页面对应一个页表项。每个页表项由页号、页面存放的内存块号组成，每个页表项长度相等，页号是隐含的</p><h4 id="地址变换过程"><a class="anchor" href="#地址变换过程">#</a> 地址变换过程</h4><ul><li><p>根据逻辑地址得到段号、页号、页内偏移地址</p></li><li><p>判断段号是否越界，若 S (段号)&gt;=M (段表长度)，则产生越界中断，否则继续进行</p></li><li><p>查询段表，找到对应的段表项，段表项的存放地址是 F (段表始址)+S (段号)* 段表项长度</p></li><li><p>检查页号是否越界，若页号 &gt;= 页表长度，则发生越界中断，否则继续执行</p></li><li><p>根据页表存放块号、页号查询页表，找到对应页表项</p></li><li><p>根据内存块号、页内偏移量得到最终的物理地址</p></li><li><p>访问目标内存单元</p></li></ul><p>也可引入快表机制，用段号和页号作为查询快表的关键字，若快表命中则仅需一次访存</p><div class="tags"><a href="/tags/%E8%80%83%E7%A0%94408/" rel="tag"><i class="ic i-tag"></i> 考研408</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"><i class="ic i-tag"></i> 操作系统</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-08-07 21:47:49" itemprop="dateModified" datetime="2024-08-07T21:47:49+08:00">2024-08-07</time> </span><span id="computer-science/operating-system/操作系统408-3-1/" class="item leancloud_visitors" data-flag-title="操作系统 408-3-1" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Whispering <i class="ic i-at"><em>@</em></i>Whispering's Blog</li><li class="link"><strong>本文链接：</strong> <a href="http://ntmydb/github.io/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/" title="操作系统 408-3-1">http://ntmydb/github.io/computer-science/operating-system/操作系统408-3-1/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;10&#x2F;26&#x2F;eM7puDvfB1AIK2r.jpg" title="计网408-3-1"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机网络</span><h3>计网408-3-1</h3></a></div><div class="item right"><a href="/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-2/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2023&#x2F;10&#x2F;26&#x2F;9YW14QpAcleykjg.jpg" title="计网408-3-2"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机网络</span><h3>计网408-3-2</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">内存的基本知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">覆盖与交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="toc-number">4.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="toc-number">4.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">动态分区分配算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">5.1.</span> <span class="toc-text">首次适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">最佳适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%9D%8F%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">5.3.</span> <span class="toc-text">最坏适应算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E8%BF%91%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.</span> <span class="toc-text">邻近适应算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">基本分页存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A1%B5%E8%A1%A8"><span class="toc-number">6.1.</span> <span class="toc-text">重要的数据结构 —— 页表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">基本地址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="toc-number">8.</span> <span class="toc-text">具有快表的地址变换机构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">两级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%88%86%E6%AE%B5%E5%BC%8F%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">基本分段式存储管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">10.1.</span> <span class="toc-text">分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8"><span class="toc-number">10.2.</span> <span class="toc-text">段表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5-%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-number">10.3.</span> <span class="toc-text">分段、分页管理对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">11.</span> <span class="toc-text">段页式管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5-%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">11.1.</span> <span class="toc-text">分段、分页的优缺点分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E5%88%86%E9%A1%B5%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">11.2.</span> <span class="toc-text">分段 + 分页 &#x3D; 段页式管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E7%AE%A1%E7%90%86%E7%9A%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-number">11.3.</span> <span class="toc-text">段页式管理的逻辑地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AE%B5%E8%A1%A8-%E9%A1%B5%E8%A1%A8"><span class="toc-number">11.4.</span> <span class="toc-text">段表、页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">11.5.</span> <span class="toc-text">地址变换过程</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%80/" rel="bookmark" title="操作系统实验一">操作系统实验一</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E4%B8%80/" rel="bookmark" title="操作系统复习一">操作系统复习一</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E4%BA%8C/" rel="bookmark" title="操作系统复习二">操作系统复习二</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%BA%8C/" rel="bookmark" title="操作系统实验二">操作系统实验二</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E4%B8%89/" rel="bookmark" title="操作系统复习三">操作系统复习三</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E5%9B%9B/" rel="bookmark" title="操作系统复习四">操作系统复习四</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-1-1&2/" rel="bookmark" title="操作系统408-1-1&2">操作系统408-1-1&2</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-1-3&4&5&6/" rel="bookmark" title="操作系统408-1-3&4&5&6">操作系统408-1-3&4&5&6</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-1/" rel="bookmark" title="操作系统408-2-1">操作系统408-2-1</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-2/" rel="bookmark" title="操作系统408-2-2">操作系统408-2-2</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-3/" rel="bookmark" title="操作系统408-2-3">操作系统408-2-3</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-2-4/" rel="bookmark" title="操作系统408-2-4">操作系统408-2-4</a></li><li class="active"><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/" rel="bookmark" title="操作系统408-3-1">操作系统408-3-1</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-2/" rel="bookmark" title="操作系统408-3-2">操作系统408-3-2</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-4-1/" rel="bookmark" title="操作系统408-4-1">操作系统408-4-1</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-4-3/" rel="bookmark" title="操作系统408-4-3">操作系统408-4-3</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-1/" rel="bookmark" title="操作系统408-5-1">操作系统408-5-1</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-2/" rel="bookmark" title="操作系统408-5-2">操作系统408-5-2</a></li><li><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-3/" rel="bookmark" title="操作系统408-5-3">操作系统408-5-3</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Whispering" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Whispering</p><div class="description" itemprop="description">Whispering's Blog</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">128</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">11</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">39</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL250bXlkYg==" title="https:&#x2F;&#x2F;github.com&#x2F;ntmydb"><i class="ic i-github"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/computer-network/%E8%AE%A1%E7%BD%91408-3-2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/principles-of-computer-composition/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/computer-science/principles-of-computer-composition/%E8%AE%A1%E7%BB%84408-5-1&2/" title="计算机组成原理408-5-1&amp;2">计算机组成原理408-5-1&2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/data-structure/" title="分类于 数据结构">数据结构</a></div><span><a href="/computer-science/data-structure/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84408-7-3/" title="数据结构408-7-3">数据结构408-7-3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/operating-system/" title="分类于 操作系统">操作系统</a></div><span><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E4%BA%8C/" title="操作系统复习二">操作系统复习二</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/mechine-learning/" title="分类于 机器学习">机器学习</a></div><span><a href="/mechine-learning/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0/" title="智能计算系统复习">智能计算系统复习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/principles-of-computer-composition/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/computer-science/principles-of-computer-composition/%E8%AE%A1%E7%BB%84408-2-3/" title="计算机组成原理408-2-3">计算机组成原理408-2-3</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/operating-system/" title="分类于 操作系统">操作系统</a></div><span><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-1-1&2/" title="操作系统408-1-1&amp;2">操作系统408-1-1&2</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/database/" title="分类于 数据库">数据库</a></div><span><a href="/computer-science/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0%E4%B9%9D/" title="数据库复习九">数据库复习九</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/operating-system/" title="分类于 操作系统">操作系统</a></div><span><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-3-1/" title="操作系统408-3-1">操作系统408-3-1</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/principles-of-computer-composition/" title="分类于 计算机组成原理">计算机组成原理</a></div><span><a href="/computer-science/principles-of-computer-composition/%E8%AE%A1%E7%BB%84408-3-3&4/" title="计算机组成原理408-3-3&amp;4">计算机组成原理408-3-3&4</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/operating-system/" title="分类于 操作系统">操作系统</a></div><span><a href="/computer-science/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F408-5-2/" title="操作系统408-5-2">操作系统408-5-2</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-"></i> </span><span class="author" itemprop="copyrightHolder">Whispering @ Flüstern</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">690k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">10:27</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/operating-system/操作系统408-3-1/",favicon:{show:"邀诸位共赏",hide:"请随意吐槽"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,copy_tex:!0,katex:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html>